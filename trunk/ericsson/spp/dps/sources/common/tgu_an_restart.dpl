/*********************************************************************
 * (C) Copyright Wintegra 2000-2002.  All rights reserved.
 * WINTEGRA CONFIDENTIAL PROPRIETARY
 * Contains Confidential Proprietary information of Wintegra.
 * Reverse engineering is prohibited.
 * The copyright notice does not imply publication.
 *****************************************************************************
/****************************************************************************
*
* File: tgu_an_restart.dpl
*
* Description: This file holds the code section of TGU that handles ER-43 bug.
*              ER-43 description:
*              Each time after plugging a cable in, or resetting the phy, there is
*              a synchronization proccess. At very low probability - this proccess
*              will get stuck, and no traffic can go through this port.
*              In order to ReEnable this port, one should invoke an_restart in
*              tcntr register of the relavent phy.
*
* Module Originator: Elad Jacob
* Creation Date: August 9, 2011
*
* Change History:
* +------------+--------------------+----------------------------------------
* | Date       | By                 | Description
* +------------+--------------------+----------------------------------------
* |            |                    |
* +------------+--------------------+----------------------------------------
* |            |                    |
* +------------+--------------------+----------------------------------------
*
*****************************************************************************/

#include "tgu_an_restart.h"
#include "shared.h"

#ifdef _WINPATH_REV_WP3_ENABLE_

section TGU_AN_RESTART
{
   register struct S_Tcr2Reg     Tcr2       = STATUS1_REG;
   register                      Tcr3       = STATUS2_REG;
   register                      TguCounter = r12;
   register                      PortIndex  = r12;
   register                      DivFactor  = r13;
   register                      RegOffset  = r13;
   register                      EnetPortsMask = r14;
   register struct S_TandbgHwReg Tandbg = r15;
   register struct S_TcntrHwReg  Tcntr  = r16;
   register                      GroupOffset = r17;

   global L_An_Restart_Tgu_Start;
   
  L_An_Restart_Tgu_Start:

    TguCounter = Tcr2.CyclicCounter; // get the current counter from the TGU
    DivFactor = Tcr2.DivFactor;
    
    // check next slot only when Counter reaches div_factor
    if ( (TguCounter & DivFactor )!= 0)
    {
       _task_switch(r0, _TERMINATE);
    }

   EnetPortsMask = Tcr3;
      
   while (EnetPortsMask > 0)
   {
      /* get the next port index by _ffs command
       * Port Enet1 will be mapped to MSB bit and so on.
      */
      PortIndex = _ffs(EnetPortsMask);
      SGMII_TGU_CLEAR_INDEX_FROM_PORT_MASK(EnetPortsMask, PortIndex);
      
      GroupOffset = (PortIndex / 2) * SGMII_TGU_NEXT_WINNET_OFFSET;
      GroupOffset += (PortIndex % 2) * SGMII_TGU_NEXT_ENET_IN_WINNET_GROUP_OFFSET;

      /* Obtain Tandbg register */
      RegOffset = SGMII_TGU_WINNET_0_TANDBG_REG_OFFSET + GroupOffset;
      
      Tandbg = 0;
      _mem(r0, B_RIF[RegOffset], SGMII_TGU_REG_SIZE) = Tandbg;

      Tandbg = _mem(r0, B_RIF[RegOffset], SGMII_TGU_REG_SIZE);

      if (Tandbg == 0)
      {
         /* Obtain Tcntr register */
         RegOffset = SGMII_TGU_WINNET_0_TCNTR_REG_OFFSET + GroupOffset;
         
         Tcntr = _mem(r0, B_RIF[RegOffset], SGMII_TGU_REG_SIZE);

         /* Set Restart AN bit */
         Tcntr.RestartAn = 1;         
         _mem(r0, B_RIF[RegOffset], SGMII_TGU_REG_SIZE) = Tcntr;
      }   
   }

   _task_switch(r0, _TERMINATE);   
}
#endif //_WINPATH_REV_WP3_ENABLE_
