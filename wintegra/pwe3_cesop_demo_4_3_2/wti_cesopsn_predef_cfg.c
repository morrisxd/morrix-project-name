/*****************************************************************************
 * (C) Copyright PMC - WIN division (Wintegra) 2011.  All rights reserved.
 * PMC-Sierra (WINTEGRA) CONFIDENTIAL PROPRIETARY
 * Contains Confidential Proprietary information of PMC-Sierra (Wintegra).
 * Reverse engineering is prohibited.
 * The copyright notice does not imply publication.
 ****************************************************************************/
extern void WTI_TerminateOnError(WP_handle handle, WP_CHAR *s, WP_U32 line_num);

/*****************************************************************************/
/*********************************   OCTAL   *********************************/
/*****************************************************************************/

#if WTI_CESOP_TDI
#define WTI_ITERATIONS_NUM     4
#if WTI_CLOCK_REC_MODE
#define DELAY_DURATION_IN_SECONDS 60
#else
#define DELAY_DURATION_IN_SECONDS 90
#endif
/*******************************************************************************
 * Func name  : CLI_F_E1FramedUnFrg16Tdi
 * Description: This Macro simulate 8TDIs, 8RTDIs and 2GMIIs.
 *              Each TDI is configured to E1 Framed mode (No CAS).
 *              The PWE channels are routed to GMII1 in Loopback mode.
 *              On GMII1 we create a single PWE channel which is routed to
 *              himself (PSN to PSN).
 *
 *              In the 'master' test, here is what is needed to configure
 *              in the Main defines:
 *              WTI_CESOP_TDI                   1
 *              WTI_CESOP_CLOCK_RECOVERY_ENABLE 0
 *              WTI_MAX_PW                      128 or 256 or 512
 *              WTI_ENET_PORT                   WP_PORT_ENET1
 *              WTI_2_ENET_DE VICES              1
 *              WTI_AUTOMATION_RUN              0
 *              WTI_DFC_CLASSIFIER              1
 *              WTI_ENET_MODE                   WP_ENET_LOOPBACK
 *              WTI_ENET_TYPE                   WP_ENET_GMII
 *              WTI_GMII_TYPE                   WTI_GMII_OV_FIBER
 *
 *              'WTI_2_ENET_DEVICES' is
 *              set and so the following are also defined:
 *              WTI_SECOND_ENET_MODE            WP_ENET_NORMAL
 *              WTI_SECOND_ENET_PORT            WP_PORT_ENET2
 *              WTI_SECOND_ENET_TYPE            WP_ENET_GMII
 *              WTI_SECOND_GMII_TYPE            WTI_GMII_OV_FIBER
 *
 *              ...and most important, the Two Boards simulation
 *              should be CLEARED:
 *              TWO_BOARDS_SIMULATION           0
 *
 *              Also number of active TDI ports should be set to 16:
 *              WTI_ACTIVE_TDI_PORTS            16
 *
 *              When Configuring the SmartBit to drive the data to the 2nd
 *              GMII is important to config 64 Bytes Packets (60 bytes,
 *              without the CRC) and set the IP Destination address to:
 *              000.000.008.000
 *
 *              Also change the function 'WTI_PsnTrafficRuleConfig()' (reside
 *              in wti_cesopsn_util.c file) so that the dfc rule will reflect
 *              that IP destination address.
 *
 *              Note that in this Macro with override some Pin Mux configuration.
 *              This is to allow the two GMII to work with RTDI.
 *
 *              Note also that the WTI_MAX_PW define determines the number of
 *              PWE channels in this system. This will also create how many
 *              slots per channel are configured.
 *
 * Input      :
 * OutPut     :
 * Return Val :
 ******************************************************************************/
void CLI_F_E1FramedUnFrg16Tdi(char *StrPrm)
{
   WP_CHAR temp_buf[100];
   WP_CHAR Tav[2];
   WP_U32 i;
   WP_U32 tdi_index;
   WP_U32 slot_index;
   WP_U32 pwe_index;
   WP_U32 NumOfChanPerTdi;
   WP_U32 NumOfSlots;
   WP_U32 Tmp_Data,Tmp_Mask;

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, No CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to E1 FRAMED no CAS */
   for (tdi_index=0 ; tdi_index<16 ; tdi_index=tdi_index+1)
   {
      /* tdm index; op_mode (0-T1,1-E1) */
      sprintf(temp_buf, "0 %d 1",tdi_index);
      CLI_F_TdiOperationMode(temp_buf);

      /* tdm index; framing_mode (0-UnFramed,1-Framed) */
      sprintf(temp_buf, "0 %d 1",tdi_index);
      CLI_F_TdiFramingMode(temp_buf);

      /* tdm index; cas_mode (0-No Cas,1-Cas) */
      sprintf(temp_buf, "0 %d 0",tdi_index);
      CLI_F_TdiCasMode(temp_buf);
   }
   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   /* --------------------------------------------- */
   /* Overwrite GPIO Registers to Enbale All RTDI's */
   /* --------------------------------------------- */

   /* --------------------------
      GPIO_A : RTDI5, RTDI6:
      MAP_GS_GPCR_A: 0xbf010c80
      MAP_GS_GPMR_A: 0xbf010cf0
      -------------------------- */

   Tmp_Mask = 0x0003f0fc;

   Tmp_Data = *(WP_U32 *)0xbf010c80;
   Tmp_Data = (Tmp_Data & (~Tmp_Mask));
   *(WP_U32 *)0xbf010c80 = Tmp_Data;

   Tmp_Data = *(WP_U32 *)0xbf010cf0;
   Tmp_Data = (Tmp_Data | Tmp_Mask);
   *(WP_U32 *)0xbf010cf0 = Tmp_Data;

   /* -------------------------------------------
      GPIO_B : RTDI2, RTDI3, RTDI4, RTDI7, RTDI8
      MAP_GS_GPCR_A: 0xbf010c90
      MAP_GS_GPMR_A: 0xbf010cf8
      ------------------------------------------- */

   Tmp_Mask = 0xfffcfffc;

   Tmp_Data = *(WP_U32 *)0xbf010c90;
   Tmp_Data = (Tmp_Data & (~Tmp_Mask));
   *(WP_U32 *)0xbf010c90 = Tmp_Data;

   Tmp_Data = *(WP_U32 *)0xbf010cf8;
   Tmp_Data = (Tmp_Data | Tmp_Mask);
   *(WP_U32 *)0xbf010cf8 = Tmp_Data;

   /* -------------------------------------------
      GPIO_G : RTDI1, RTDI4 (RxClock, RxSync)
      MAP_GS_GPCR_A: 0xbf010ce0
      MAP_GS_GPMR_A: 0xbf010d20

      Note that when GMII1 and RTDI1 can NOT
      operate Together.
      ------------------------------------------- */
   Tmp_Mask = 0x00000030;

   Tmp_Data = *(WP_U32 *)0xbf010ce0;
   Tmp_Data = (Tmp_Data & (~Tmp_Mask));
   *(WP_U32 *)0xbf010ce0 = Tmp_Data;

   Tmp_Data = *(WP_U32 *)0xbf010d20;
   Tmp_Data = (Tmp_Data | Tmp_Mask);
   *(WP_U32 *)0xbf010d20 = Tmp_Data;


   /* --------------------- */
   /* Initiate PWE Channels */
   /* --------------------- */
   NumOfChanPerTdi = (WTI_MAX_PW/16);
   NumOfSlots = (512/WTI_MAX_PW);

   for (pwe_index = 0 ; pwe_index < WTI_MAX_PW ; pwe_index = pwe_index + 1)
   {
      /* TDI Index */
      tdi_index = (pwe_index/NumOfChanPerTdi);

      /* Slot Index */
      slot_index = (pwe_index%NumOfChanPerTdi)*NumOfSlots;

      if (NumOfSlots > 1)
      {
         /* tdm index, transfer_mode (0-T1,1-E1), num_slots, slots_array */
         sprintf(temp_buf, "0 %d 1 %d %d-%d",tdi_index,NumOfSlots,slot_index,(slot_index+(NumOfSlots-1)));
         CLI_F_PwConfigureFramedTdi(temp_buf);
      }
      else
      {
         /* tdm index, transfer_mode (0-T1,1-E1), num_slots, slots_arrayv */
         sprintf(temp_buf, "0 %d 1 %d %d",tdi_index,NumOfSlots,slot_index);
         CLI_F_PwConfigureFramedTdi(temp_buf);
      }

      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 32");
      CLI_F_Pwe3ChannelStatmode("0 1");

      strcpy (temp_buf,"0 ");
      for (i=0 ; i<NumOfSlots ; i=i+1)
      {
         sprintf (Tav,"%d",i);
         strcat (temp_buf,Tav);

         if (i<(NumOfSlots-1))
         {
            strcat (temp_buf,",");
         }
      }
      CLI_F_Pwe3ChannelTxUdpattern(temp_buf);

      strcpy (temp_buf,"0 ");
      for (i=0 ; i<NumOfSlots ; i=i+1)
      {
         sprintf (Tav,"%d",(i+24));
         strcat (temp_buf,Tav);

         if (i<(NumOfSlots-1))
         {
            strcat (temp_buf,",");
         }
      }
      CLI_F_Pwe3ChannelTxDummyUdpattern(temp_buf);

      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/

      CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
      sprintf(temp_buf, "0 45000000 811e0000 40110000 1a1a1a1a %d",(pwe_index+1));
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 38 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

      /**************** PSN --> TDM Tx binding*****************/

      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

      /* oobc mode(0,1) , Clock Master Flag */
      CLI_F_PwCreate("0 0 0 0");

      /* pw_index, Clock Master Flag */
      sprintf(temp_buf,"0 %d 0",pwe_index);
      CLI_F_PwEnable(temp_buf);
   }

   /*********************** END OF SECOND FLOW TO LOAD WINGINS **********************/

} /* CLI_F_E1FramedUnFrg16Tdi() */

#endif

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_DifferentLinesOctal(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

#if WTI_CESOP_TDI
   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   CLI_F_TdiOperationMode("0 0 0");
   CLI_F_TdiFramingMode("0 0 1");
   CLI_F_TdiCasMode("0 0 1");

   CLI_F_TdiOperationMode("0 1 0");
   CLI_F_TdiFramingMode("0 1 1");
   CLI_F_TdiCasMode("0 1 0");

   CLI_F_TdiOperationMode("0 2 0");
   CLI_F_TdiFramingMode("0 2 1");
   CLI_F_TdiCasMode("0 2 1");

   CLI_F_TdiOperationMode("0 3 1");
   CLI_F_TdiFramingMode("0 3 0");
   CLI_F_TdiCasMode("0 3 0");

   CLI_F_TdiOperationMode("0 4 1");
   CLI_F_TdiFramingMode("0 4 1");
   CLI_F_TdiCasMode("0 4 0");

   CLI_F_TdiOperationMode("0 5 1");
   CLI_F_TdiFramingMode("0 5 1");
   CLI_F_TdiCasMode("0 5 1");

   CLI_F_TdiOperationMode("0 6 0");
   CLI_F_TdiFramingMode("0 6 1");
   CLI_F_TdiCasMode("0 6 1");

   CLI_F_TdiOperationMode("0 7 0");
   CLI_F_TdiFramingMode("0 7 1");
   CLI_F_TdiCasMode("0 7 0");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
#else
   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");

   /* configure UFE lines */
   sprintf(temp_buf, "0 0 1 0");
   CLI_F_UfeTransferMode(temp_buf);
   sprintf(temp_buf, "0 1 1 0");
   CLI_F_UfeTransferMode(temp_buf);
   sprintf(temp_buf, "0 2 1 0");
   CLI_F_UfeTransferMode(temp_buf);
   sprintf(temp_buf, "0 3 4 0");
   CLI_F_UfeTransferMode(temp_buf);
   sprintf(temp_buf, "0 4 3 0");
   CLI_F_UfeTransferMode(temp_buf);
   sprintf(temp_buf, "0 5 3 0");
   CLI_F_UfeTransferMode(temp_buf);
   sprintf(temp_buf, "0 6 1 0");
   CLI_F_UfeTransferMode(temp_buf);
   sprintf(temp_buf, "0 7 1 0");
   CLI_F_UfeTransferMode(temp_buf);

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   CLI_F_UfeCasMode("0 0 1");
   CLI_F_UfeCasMode("0 1 0");
   CLI_F_UfeCasMode("0 2 1");
   CLI_F_UfeCasMode("0 3 0");
   CLI_F_UfeCasMode("0 4 0");
   CLI_F_UfeCasMode("0 5 1");
   CLI_F_UfeCasMode("0 6 0");
   CLI_F_UfeCasMode("0 7 1");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   CLI_F_UfeChipInitLineSetup("");
#endif

   for (i=0;i<8;++i)
   {
#if WTI_CESOP_TDI
      if (i==0)
      {
         sprintf(temp_buf, "0 %d 0 24 0-23",i);
         CLI_F_PwConfigureFramedTdi(temp_buf);
      }
      else if (i==1)
      {
         sprintf(temp_buf, "0 %d 0 24 0-23",i);
         CLI_F_PwConfigureFramedTdi(temp_buf);
      }
      else if (i==2)
      {
         sprintf(temp_buf, "0 %d 0 24 0-23",i);
         CLI_F_PwConfigureFramedTdi(temp_buf);
      }
      else if (i==3)
      {
         sprintf(temp_buf, "0 %d 1",i);
         CLI_F_PwConfigureUnframedTdi(temp_buf);
      }
      else if (i==4)
      {
         sprintf(temp_buf, "0 %d 1 32 0-31",i);
         CLI_F_PwConfigureFramedTdi(temp_buf);
      }
      else if (i==5)
      {
         sprintf(temp_buf, "0 %d 1 32 0-31",i);
         CLI_F_PwConfigureFramedTdi(temp_buf);
      }
      else if (i==6)
      {
         sprintf(temp_buf, "0 %d 0 24 0-23",i);
         CLI_F_PwConfigureFramedTdi(temp_buf);
      }
      else if (i==7)
      {
         sprintf(temp_buf, "0 %d 0 24 0-23",i);
         CLI_F_PwConfigureFramedTdi(temp_buf);
      }
#else
      if (i==0)
      {
         sprintf(temp_buf, "0 %d 24 24 24 0-23",i);
         CLI_F_PwConfigureFramed(temp_buf);
      }
      else if (i==1)
      {
         sprintf(temp_buf, "0 %d 24 24 24 0-23",i);
         CLI_F_PwConfigureFramed(temp_buf);
      }
      else if (i==2)
      {
         sprintf(temp_buf, "0 %d 24 24 24 0-23",i);
         CLI_F_PwConfigureFramed(temp_buf);
      }
      else if (i==3)
      {
         sprintf(temp_buf, "0 %d 32 32 32 0-31",i);
         CLI_F_PwConfigureUnframed(temp_buf);
      }
      else if (i==4)
      {
         sprintf(temp_buf, "0 %d 32 32 32 0-31",i);
         CLI_F_PwConfigureFramed(temp_buf);
      }
      else if (i==5)
      {
         sprintf(temp_buf, "0 %d 32 32 32 0-31",i);
         CLI_F_PwConfigureFramed(temp_buf);
      }
      else if (i==6)
      {
         sprintf(temp_buf, "0 %d 24 24 24 0-23",i);
         CLI_F_PwConfigureFramed(temp_buf);
      }
      else if (i==7)
      {
         sprintf(temp_buf, "0 %d 24 24 24 0-23",i);
         CLI_F_PwConfigureFramed(temp_buf);
      }
#endif
      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 256");
      if (i>2 && i<6)
         CLI_F_Pwe3ChannelRxBufferSize("0 32");
      else
         CLI_F_Pwe3ChannelRxBufferSize("0 192");
      CLI_F_Pwe3ChannelStatmode("0 1");

      if (i>2 && i<6)
      {
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
      }
      else
      {
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
      }

      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/

      CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");

      if (i==0)
      {
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+0,0x0a00020a+0);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
      }
      else if (i==1)
      {
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+10,0x0a00020a+10);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
      }
      else if (i==2)
      {
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+20,0x0a00020a+20);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
      }
      else if (i==3)
      {
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+30,0x0a00020a+30);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
      }
      else if (i==4)
      {
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+40,0x0a00020a+40);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
      }
      else if (i==5)
      {
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+45,0x0a00020a+45);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
      }
      else if (i==6)
      {
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+50,0x0a00020a+50);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
      }
      else if (i==7)
      {
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+60,0x0a00020a+60);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
      }

      if (i>2 && i<6)
      {
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 38 0");
      }
      else
      {
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 d8 0");
      }

      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

      /**************** PSN --> TDM Tx binding*****************/

      CLI_F_Psn2TdmTxBinWindowThreshold("0 128");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 64");

      CLI_F_PwCreate("0 0 0 0");
      sprintf(temp_buf, "0 %d",i);
      CLI_F_PwEnable(temp_buf);
   }
}

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_E1UnframedNoCasOctal(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

#if WTI_CESOP_TDI
   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to E1 UNFRAMED no CAS */
   for (i=0;i<4;i++)
   {
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   CLI_F_PwConfigureUnframedTdi("0 1 1");
#else
   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");

   /* configure UFE lines */
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 4 0",i);
      CLI_F_UfeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   CLI_F_UfeCasMode("0 0 0");
   CLI_F_UfeCasMode("0 1 0");
   CLI_F_UfeCasMode("0 2 0");
   CLI_F_UfeCasMode("0 3 0");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureUnframed("0 0 64 32");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 130");/*256*/
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 17");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 17");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

#ifdef WTI_BOARD_1
   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 1a1a1a1a 11111111");
#else
   CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 aa 00 aa 00 aa aa aa aa aa aa aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 11111111 1a1a1a1a");
#endif
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 9a 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
#if WTI_ACTIVE_ABSOLUTE_MODE
   sprintf(temp_buf, "0 1 0 0");
#else
   sprintf(temp_buf, "0 0 0 0");
#endif
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
   CLI_F_Tdm2PsnFlowAggTsConstSet("0 4");/*3*/

   /* example for ABS mode:
   1. RxBufferSize = 200
      TsConst = 6
      therefore: N*(RxBuf*8(bits/byte)/256) = 6*(200*8)/256 = 37.5
      => in Hexa we will get 25h/26h alternately.
      follow the RTP's TS and see the results.
   2. if TsConst=3 => 18.75 => [12,13,13,13]
    */
   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");
   CLI_F_Psn2TdmTxBinLOPSDetection("0 1 6 4");             /* LOPS parameters */

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");

#if WTI_CESOP_TDI
   CLI_F_PwConfigureUnframedTdi("0 2 1");
#else
   CLI_F_PwConfigureUnframed("0 1 64 32");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 256");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 34");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 34");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 1b1b1b1b 22222222");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 118 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
#if WTI_ACTIVE_ABSOLUTE_MODE
   sprintf(temp_buf, "0 1 0 0");
#else
   sprintf(temp_buf, "0 0 1 1");
#endif
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
   CLI_F_Tdm2PsnFlowAggTsConstSet("0 256");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");
   CLI_F_Psn2TdmTxBinLOPSDetection("0 1 6 4");             /* LOPS parameters */

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 1 0");

#if WTI_CESOP_TDI
   CLI_F_PwConfigureUnframedTdi("0 2 1");
#else
   CLI_F_PwConfigureUnframed("0 2 64 32");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 256");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 51");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 51");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 1c1c1c1c 33333333");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 118 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
#if WTI_ACTIVE_ABSOLUTE_MODE
   sprintf(temp_buf, "0 1 0 0");
#else
   sprintf(temp_buf, "0 0 1 1");
#endif
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
   CLI_F_Tdm2PsnFlowAggTsConstSet("0 256");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");
   CLI_F_Psn2TdmTxBinLOPSDetection("0 1 6 4");             /* LOPS parameters */

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 2 0");

#if WTI_CESOP_TDI
   CLI_F_PwConfigureUnframedTdi("0 2 1");
#else
   CLI_F_PwConfigureUnframed("0 3 64 32");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 256");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 68");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 68");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 1d1d1d1d 44444444");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 118 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
#if WTI_ACTIVE_ABSOLUTE_MODE
   sprintf(temp_buf, "0 1 0 0");
#else
   sprintf(temp_buf, "0 0 1 1");
#endif
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
   CLI_F_Tdm2PsnFlowAggTsConstSet("0 256");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");
   CLI_F_Psn2TdmTxBinLOPSDetection("0 1 6 4");             /* LOPS parameters */

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 3 0");

}

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_E1Framed1DS0NoCasOctal(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

#if WTI_CESOP_TDI
   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to E1 FRAMED no CAS */
   for (i=0;i<3;i++)
   {
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   CLI_F_PwConfigureFramedTdi("0 1 1 1 31");
#else
   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");

   /* configure UFE lines */
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 3 0",i);
      CLI_F_UfeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   CLI_F_UfeCasMode("0 1 0");
   CLI_F_UfeCasMode("0 2 0");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureFramed("0 1 20 10 1 31");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 40");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 31");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 1a1a1a1a 11111111");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 40 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
#if WTI_ACTIVE_ABSOLUTE_MODE
   sprintf(temp_buf, "0 1 0 0");
#else
   sprintf(temp_buf, "0 0 0 0");
#endif
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
   CLI_F_Tdm2PsnFlowAggTsConstSet("0 1");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");

#if WTI_CESOP_TDI
   CLI_F_PwConfigureFramedTdi("0 2 1 1 31");
#else
   CLI_F_PwConfigureFramed("0 2 20 10 1 31");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 40");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 32");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 1b1b1b1b 22222222");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 40 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
#if WTI_ACTIVE_ABSOLUTE_MODE
   sprintf(temp_buf, "0 1 0 0");
#else
   sprintf(temp_buf, "0 0 1 1");
#endif
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
   CLI_F_Tdm2PsnFlowAggTsConstSet("0 256");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 1 0");

}

/***************************************************************
 * Func name  :CLI_F_E1Framed1DS0NoCasShortPacketsOctal
 * Description: The Test use the  smallest TDM  payload size.
 *              The test can test the LEN field in the CW.
 *              LEN(PACKET SIZE) , PL = TDM PAYLOAD
 *              PACKET SIZE>=64 : LEN =0 (no padding)
 *              PACKET SIZE<64 with RTP : LEN = PL + CW(4) + RTP(12)  need  padding
 *              PACKET SIZE<64 no RTP   : LEN = PL + CW(4)            need  padding
 *
 *              When iw mode is bridging and with no rtp the
 *              Use of LEN field in the CW is tested (packets < 64)
 *              In order to run with bridging see 37901 test.
 *              In order to remove RTP header :
 *              WTI_TDM2PSN_RTP_MODE  WP_DISABLE
 *              WTI_RTP_HEADER_LEN    0
 *
 *              When iw mode is routing the padding size can be calculated from the Ip length field
 *              Therefore LEN field in the CW is not used for the clculation of the PL size.
 *
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_E1Framed1DS0NoCasShortPacketsOctal(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();
#if WTI_CESOP_TDI
   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to E1 FRAMED no CAS */
   for (i=0;i<3;i++)
   {
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   CLI_F_PwConfigureFramedTdi("0 1 1 1 31");
#else
   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");

   /* configure UFE lines */
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 3 0",i);
      CLI_F_UfeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   CLI_F_UfeCasMode("0 1 0");
   CLI_F_UfeCasMode("0 2 0");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureFramed("0 1 2 2 1 31");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 2"); /* Paylaod size = 2 */
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 31");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 1a1a1a1a 11111111");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 1a 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");

   if ((!WTI_TDM2PSN_RTP_MODE)&&(WTI_RTP_HEADER_LEN == 0)&&(WTI_IW_SYSTEM_MODE == WTI_IW_SYSTEM_BRIDGE))
      /* Packet size = eth(14)+IP(20)+UDP(8)+CW(4)+PL(2)+FCS(4) = 52 < 64 -> padding   */
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 6 0");/* LEN = 2 PL + 4 CW (no RTP) */
   else
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_ACTIVE_ABSOLUTE_MODE
   sprintf(temp_buf, "0 1 0 0");
#else
   sprintf(temp_buf, "0 0 0 0");
#endif
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
   CLI_F_Tdm2PsnFlowAggTsConstSet("0 256");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");

#if WTI_CESOP_TDI
   CLI_F_PwConfigureFramedTdi("0 2 1 1 31");
#else
   CLI_F_PwConfigureFramed("0 2 2 2 1 31");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 2");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 32");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 1b1b1b1b 22222222");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 1a 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");

   if ((!WTI_TDM2PSN_RTP_MODE)&&(WTI_RTP_HEADER_LEN == 0)&&(WTI_IW_SYSTEM_MODE == WTI_IW_SYSTEM_BRIDGE))
      /* Packet size = eth(14)+IP(20)+UDP(8)+CW(4)+PL(2)+FCS(4) = 52 < 64 -> padding   */
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 6 0");/* LEN = 2 PL + 4 CW (no RTP)*/
   else
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_ACTIVE_ABSOLUTE_MODE
   sprintf(temp_buf, "0 1 0 0");
#else
   sprintf(temp_buf, "0 0 1 1");
#endif
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
   CLI_F_Tdm2PsnFlowAggTsConstSet("0 256");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 1 0");

}
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_E1Framed32DS0NoCasOctal(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

#if WTI_CESOP_TDI
   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to E1 FRAMED no CAS */
   for (i=0;i<3;i++)
   {
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   CLI_F_PwConfigureFramedTdi("0 1 1 32 0-31");
#else
   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");

   /* configure UFE lines */
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 3 0",i);
      CLI_F_UfeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   CLI_F_UfeCasMode("0 1 0");
   CLI_F_UfeCasMode("0 2 0");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureFramed("0 0 32 32 32 0-31");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32"); /* must be <= N_TRANS_TX_QUEUE_RING_LENGTH */
   CLI_F_Pwe3ChannelRxBufferSize("0 32");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 1a1a1a1a 11111111");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 38 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
#if WTI_ACTIVE_ABSOLUTE_MODE
   sprintf(temp_buf, "0 1 0 0");
#else
   sprintf(temp_buf, "0 0 0 0");
#endif
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
   CLI_F_Tdm2PsnFlowAggTsConstSet("0 1");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");

#if WTI_CESOP_TDI
   CLI_F_PwConfigureFramedTdi("0 2 1 32 0-31");
#else
   CLI_F_PwConfigureFramed("0 1 32 32 32 0-31");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 32");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 1b1b1b1b 22222222");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 38 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
#if WTI_ACTIVE_ABSOLUTE_MODE
   sprintf(temp_buf, "0 1 0 0");
#else
   sprintf(temp_buf, "0 0 1 1");
#endif
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
   CLI_F_Tdm2PsnFlowAggTsConstSet("0 256");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 1 0");

#if WTI_CESOP_TDI
   CLI_F_PwConfigureFramedTdi("0 2 1 32 0-31");
#else
   CLI_F_PwConfigureFramed("0 2 32 32 32 0-31");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 32");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 1c1c1c1c1c 33333333");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 38 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
#if WTI_ACTIVE_ABSOLUTE_MODE
   sprintf(temp_buf, "0 1 0 0");
#else
   sprintf(temp_buf, "0 0 1 1");
#endif
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
   CLI_F_Tdm2PsnFlowAggTsConstSet("0 256");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 2 0");

#if WTI_CESOP_TDI
   CLI_F_PwConfigureFramedTdi("0 2 1 32 0-31");
#else
   CLI_F_PwConfigureFramed("0 3 32 32 32 0-31");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 32");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 1d1d1d1d 44444444");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 38 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
#if WTI_ACTIVE_ABSOLUTE_MODE
   sprintf(temp_buf, "0 1 0 0");
#else
   sprintf(temp_buf, "0 0 1 1");
#endif
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
   CLI_F_Tdm2PsnFlowAggTsConstSet("0 256");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 3 0");

}
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_E1Framed1DS0CasUnFrgOctal(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

#if WTI_CESOP_TDI
   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to E1 FRAMED CAS */
   for (i=0;i<3;i++)
   {
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   CLI_F_PwConfigureFramedTdi("0 1 1 1 1");
#else
   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");

   /* configure UFE lines */
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 3 0",i);
      CLI_F_UfeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   CLI_F_UfeCasMode("0 1 1");
   CLI_F_UfeCasMode("0 2 1");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureFramed("0 1 16 16 1 1");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 16");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 31");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 1a1a1a1a 11111111");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 2f 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 1 0 0");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");

#if WTI_CESOP_TDI
   CLI_F_PwConfigureFramedTdi("0 2 1 1 1");
#else
   CLI_F_PwConfigureFramed("0 2 16 16 1 1");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 16");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 32");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 1b1b1b1b 22222222");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 2f 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 1");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 1 0");

}

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_E1Framed30DS0CasUnFrgOctal(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

#if WTI_CESOP_TDI
   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to E1 FRAMED CAS */
   for (i=0;i<3;i++)
   {
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   CLI_F_PwConfigureFramedTdi("0 1 1 30 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
#else
   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");

   /* configure UFE lines */
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 3 0",i);
      CLI_F_UfeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   CLI_F_UfeCasMode("0 0 1");
   CLI_F_UfeCasMode("0 1 1");
   CLI_F_UfeCasMode("0 2 1");
   CLI_F_UfeCasMode("0 3 1");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureFramed("0 0 30 30 30 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 480"); /* 16 (frames per multiframe) * 30 (slots per frame) */
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 d");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 1a1a1a1a 11111111");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 207 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 0 0");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");

#if WTI_CESOP_TDI
   CLI_F_PwConfigureFramedTdi("0 2 1 30 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
#else
   CLI_F_PwConfigureFramed("0 1 30 30 30 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 480"); /* 16 (frames per multiframe) * 30 (slots per frame) */
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 d");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 1b1b1b1b 22222222");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 207 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 1");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 1 0");

#if WTI_CESOP_TDI
   CLI_F_PwConfigureFramedTdi("0 2 1 30 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
#else
   CLI_F_PwConfigureFramed("0 2 30 30 30 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 480"); /* 16 (frames per multiframe) * 30 (slots per frame) */
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 d");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 1b1b1b1c 22222223");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 207 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 1");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 2 0");

#if WTI_CESOP_TDI
   CLI_F_PwConfigureFramedTdi("0 2 1 30 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
#else
   CLI_F_PwConfigureFramed("0 3 30 30 30 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 480"); /* 16 (frames per multiframe) * 30 (slots per frame) */
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 d");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 1b1b1b1d 22222224");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 207 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 1");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 3 0");

}

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_E1Framed30DS0CasUnFrgOctal_withModify(char *StrPrm)
{
   WP_U32 i;
#if !WTI_CESOP_TDI
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   int active_ufe_lines = N_ACTIVE_UFE_OCT_LINES;
#endif

   /* allocate CESoP system */
   WTI_SystemAlloc();

#if WTI_CESOP_TDI
   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM1 interfaces to E1 FRAMED CAS */
   CLI_F_TdiOperationMode("0 1 1");  /* set TDM i to E1 */
   CLI_F_TdiFramingMode("0 1 1");  /* set to framed mode */
   CLI_F_TdiCasMode("0 1 1"); /* set CAS enable */

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   CLI_F_PwConfigureFramedTdi("0 1 1 30 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");

#else

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1"); /* Octal, CAD interface */

   /* configure UFE lines */
   for (i=0; i<active_ufe_lines; i++)
   {
      sprintf(temp_buf, "0 %d 3 0", i); /* E1 framed */
      CLI_F_UfeTransferMode(temp_buf);
      sprintf(temp_buf, "0 %d 1", i); /* CAS eabled */
      CLI_F_UfeCasMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureFramed("0 1 30 30 30 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 240"); /* 16 (frames per multiframe) * 30 (slots per frame) */
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 d");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 1a1a1a1a 11111111");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 108 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 0 0");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");

   printf("\nOne PW created. start modify: PW Disable -> PW Modify (Payload size exchange; from 480 to 240) -> PW Enable.\n");
   printf("Press any key to continue or '9' to quit.\n");
   i = getchar();

   if (i != '9' )
   {
      WP_status status;
      WP_U32 qdepth;
      status = WP_ChannelQDepth(the_system->pw[0].trans_tx, &qdepth);
      printf("before disable: qdepth %d\n",qdepth);


      /* IW flow disable */
      WTI_Psn2TdmIwFlowRuleDisable(0);

      for(i=0; i<100;i++)
      {

         status = WP_ChannelQDepth(the_system->pw[0].trans_tx, &qdepth);
         if (status != WP_OK)
            return;

         printf("qdepth %d\n",qdepth);

         if(qdepth==0)
            break;
         WP_Delay(1000);
         if(i==99)
            return;

      }

      WTI_PwDisable(0);

      CLI_F_Tdm2PsnCesopFlowAggModify("0 0 13 480 0"); /* change payload_size from 480 to 240 */
      CLI_F_Psn2TdmCesopFlowAggModify("0 0 13 480 0"); /* change payload_size from 480 to 240 */
      CLI_F_Pwe3TransRxChannelModify("0 0 3 480 0");/*&cmd, &index, &mod, &val (orig=480, new=60) RX_BUFFERSIZE*/

      {
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 480");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 d");
         CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
         CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 1a1a1a1a 11111111");
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 1f8 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
         CLI_F_Tdm2PsnFlowAggTsParams("0 0 0 0");
      }
      CLI_F_Tdm2PsnCesopFlowAggModify("0 0 21 480 0"); /*&cmd, &index, &mod==13, &val=60(header E)*/

      /* iw flow enable */
      WTI_Psn2TdmIwFlowRuleEnable(0);
      WTI_PwEnable(0);
      /* CLI_F_PwEnable("0 0 0"); this is only for CR!! the 3rd '0' is for master/slave ????????*/
   }
}

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_E1Framed30DS0CasFrgOctal(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

#if WTI_CESOP_TDI
   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to E1 FRAMED CAS */
   for (i=0;i<3;i++)
   {
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   CLI_F_PwConfigureFramedTdi("0 1 1 30 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
#else
   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");

   /* configure UFE lines */
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 3 0",i);
      CLI_F_UfeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   CLI_F_UfeCasMode("0 1 1");
   CLI_F_UfeCasMode("0 2 1");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureFramed("0 1 30 30 30 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 240"); /* (16*30)/2 */
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 d");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 1a1a1a1a 11111111");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 108 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 0 0");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");

#if WTI_CESOP_TDI
   CLI_F_PwConfigureFramedTdi("0 2 1 30 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
#else
   CLI_F_PwConfigureFramed("0 2 30 30 30 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 240"); /* (16*30)/2 */
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 1b1b1b1b 22222222");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 108 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 1");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 1 0");

}
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_E1Framed1DS0CasFrgOctal(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

#if WTI_CESOP_TDI
   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to E1 FRAMED CAS */
   for (i=0;i<3;i++)
   {
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   CLI_F_PwConfigureFramedTdi("0 1 1 1 1");
#else
   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");

   /* configure UFE lines */
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 3 0",i);
      CLI_F_UfeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   CLI_F_UfeCasMode("0 1 1");
   CLI_F_UfeCasMode("0 2 1");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureFramed("0 1 8 8 1 1");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 8");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 31");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 1a1a1a1a 11111111");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 20 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 1 0 0");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");

#if WTI_CESOP_TDI
   CLI_F_PwConfigureFramedTdi("0 2 1 1 1");
#else
   CLI_F_PwConfigureFramed("0 2 8 8 1 1");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 8");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 32");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 1b1b1b1b 22222222");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 20 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 1");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 1 0");

}
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_T1UnframedNoCasOctal(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

#if WTI_CESOP_TDI
   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to T1 UNFRAMED no CAS */
   for (i=0;i<3;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   CLI_F_PwConfigureUnframedTdi("0 1 0");
#else
   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");

   /* configure UFE lines */
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 2 0",i);
      CLI_F_UfeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   CLI_F_UfeCasMode("0 1 0");
   CLI_F_UfeCasMode("0 2 0");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureUnframed("0 1 48 24");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 192");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 32");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 24");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 1a1a1a1a 11111111");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 d8 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
#if WTI_ACTIVE_ABSOLUTE_MODE
   sprintf(temp_buf, "0 1 0 0");
#else
   sprintf(temp_buf, "0 0 0 0");
#endif
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
   CLI_F_Tdm2PsnFlowAggTsConstSet("0 130");/*193*/

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");

#if WTI_CESOP_TDI
   CLI_F_PwConfigureUnframedTdi("0 2 0");
#else
   CLI_F_PwConfigureUnframed("0 2 48 24");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 192");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 32");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 24");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 1b1b1b1b 22222222");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 d8 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
#if WTI_ACTIVE_ABSOLUTE_MODE
   sprintf(temp_buf, "0 1 0 0");
#else
   sprintf(temp_buf, "0 0 1 1");
#endif
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
   CLI_F_Tdm2PsnFlowAggTsConstSet("0 193");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 1 0");

}

#if (!WTI_CESOP_TDI)
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_T1UnframedNoCasOctalBoard1(char *StrPrm)
{
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR ip_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 i;

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);
   memset(ip_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");
   /* configure UFE lines */
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 2 0",i);
      CLI_F_UfeTransferMode(temp_buf);
   }
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_UfeCasMode(temp_buf);
   }
   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   CLI_F_UfeChipInitLineSetup("");

   for (i=0;i<8;i++)
   {
      sprintf(temp_buf, "0 %d 24 24",i);
      CLI_F_PwConfigureUnframed(temp_buf);

      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 256");
      CLI_F_Pwe3ChannelRxBufferSize("0 24");
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 32");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 24");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/

      CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 B0 D0 B8 FA 4A 00 00 00 00 00 00 0800");
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 30 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
      CLI_F_Tdm2PsnFlowAggTsParams("0 1 0 0");

      /**************** PSN --> TDM IW *****************/

      CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

      /**************** PSN --> TDM Tx binding*****************/

      CLI_F_Psn2TdmTxBinWindowThreshold("0 128");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 64");

      CLI_F_PwCreate("0 0 0 0");
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_PwEnable(temp_buf);
   }
}
#endif

#if (!WTI_CESOP_TDI)
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_E1UnframedNoCasOctalBoard1(char *StrPrm)
{
   WP_CHAR enet_hdr[100];
   WP_CHAR ip_hdr[100];
   WP_CHAR temp_buf[100];
   WP_U32 i;

   memset(enet_hdr,0,100);
   memset(ip_hdr,0,100);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");
   CLI_F_UfeTransferMode("0 0 4 0");
   CLI_F_UfeTransferMode("0 1 4 0");
   CLI_F_UfeTransferMode("0 2 4 0");
   CLI_F_UfeTransferMode("0 3 4 0");
   CLI_F_UfeTransferMode("0 4 4 0");
   CLI_F_UfeTransferMode("0 5 4 0");
   CLI_F_UfeTransferMode("0 6 4 0");
   CLI_F_UfeTransferMode("0 7 4 0");

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   CLI_F_UfeCasMode("0 0 0");
   CLI_F_UfeCasMode("0 1 0");
   CLI_F_UfeCasMode("0 2 0");
   CLI_F_UfeCasMode("0 3 0");
   CLI_F_UfeCasMode("0 4 0");
   CLI_F_UfeCasMode("0 5 0");
   CLI_F_UfeCasMode("0 6 0");
   CLI_F_UfeCasMode("0 7 0");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   CLI_F_UfeChipInitLineSetup("");

   for (i=0;i<1;i++)
   {
      sprintf(temp_buf, "0 %d 32 32",i);
      CLI_F_PwConfigureUnframed(temp_buf);

      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 256");
      CLI_F_Pwe3ChannelRxBufferSize("0 32");
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 32");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 24");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
      /* When using vlan*/
      /* 0 , dest mac, source mac,8100, (includes 3 bits for priority(7), 1 bit CFI (0) and 12 bits vlan id (1)),0800 */
      CLI_F_Tdm2PsnFlowAggEnet802Header("0 00 08 74 AC 53 1E 00 00 00 00 00 00 8100 e001 0800");/* Priority 7 vlan 1 */
#else
      /* 0 , dest mac, source mac,0800*/
      CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 08 74 AC 53 1E 00 00 00 00 00 00 0800");

#endif
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 38 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
      CLI_F_Tdm2PsnFlowAggTsParams("0 1 0 0");

      /**************** PSN --> TDM IW *****************/

      CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

      /**************** PSN --> TDM Tx binding*****************/

      CLI_F_Psn2TdmTxBinWindowThreshold("0 128");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 64");

      CLI_F_PwCreate("0 0 0 0");
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_PwEnable(temp_buf);
   }
}
#endif /* (!WTI_CESOP_TDI) */

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_T1Framed1DS0NoCasOctal(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

#if WTI_CESOP_TDI
   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to T1 FRAMED no CAS */
   for (i=0;i<3;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   CLI_F_PwConfigureFramedTdi("0 1 0 1 23");
#else
   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");
   /* configure UFE lines */
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 1 0",i);
      CLI_F_UfeTransferMode(temp_buf);
   }
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   CLI_F_UfeCasMode("0 1 0");
   CLI_F_UfeCasMode("0 2 0");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureFramed("0 1 20 10 1 23");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 40");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 24");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 1a1a1a1a 11111111");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 40 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
#if WTI_ACTIVE_ABSOLUTE_MODE
   sprintf(temp_buf, "0 1 0 0");
#else
   sprintf(temp_buf, "0 0 0 0");
#endif
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
   CLI_F_Tdm2PsnFlowAggTsConstSet("0 193");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");

#if WTI_CESOP_TDI
   CLI_F_PwConfigureFramedTdi("0 2 0 1 23");
#else
   CLI_F_PwConfigureFramed("0 2 20 10 1 23");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 40");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 24");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 1b1b1b1b 22222222");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 40 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
#if WTI_ACTIVE_ABSOLUTE_MODE
   sprintf(temp_buf, "0 1 0 0");
#else
   sprintf(temp_buf, "0 0 1 1");
#endif
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
   CLI_F_Tdm2PsnFlowAggTsConstSet("0 193");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 1 0");

}

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_T1Framed24DS0NoCasOctal(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

#if WTI_CESOP_TDI
   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to T1 FRAMED no CAS */
   for (i=0;i<3;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   CLI_F_PwConfigureFramedTdi("0 1 0 24 0-23");
#else
   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");

   /* configure UFE lines */
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 1 0",i);
      CLI_F_UfeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   CLI_F_UfeCasMode("0 1 0");
   CLI_F_UfeCasMode("0 2 0");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureFramed("0 1 48 24 24 0-23");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 192");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 1a1a1a1a 11111111");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 d8 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
#if WTI_ACTIVE_ABSOLUTE_MODE
   sprintf(temp_buf, "0 1 0 0");
#else
   sprintf(temp_buf, "0 0 1 0");
#endif
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
   CLI_F_Tdm2PsnFlowAggTsConstSet("0 193");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");

#if WTI_CESOP_TDI
   CLI_F_PwConfigureFramedTdi("0 2 0 24 0-23");
#else
   CLI_F_PwConfigureFramed("0 2 48 24 24 0-23");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 192");/*24*/
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 1b1b1b1b 22222222");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 d8 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
#if WTI_ACTIVE_ABSOLUTE_MODE
   sprintf(temp_buf, "0 1 0 0");
#else
   sprintf(temp_buf, "0 0 1 1");
#endif
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
   CLI_F_Tdm2PsnFlowAggTsConstSet("0 193");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 1 0");

}
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_T1Framed1DS0CasUnFrgOctal(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

#if WTI_CESOP_TDI
   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to T1 FRAMED CAS */
   for (i=0;i<3;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   CLI_F_PwConfigureFramedTdi("0 1 0 1 1");
#else
   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");
   /* configure UFE lines */
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 1 0",i);
      CLI_F_UfeTransferMode(temp_buf);
   }
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   CLI_F_UfeCasMode("0 1 1");
   CLI_F_UfeCasMode("0 2 1");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureFramed("0 1 24 24 1 1");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 24");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 23");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 1a1a1a1a 11111111");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 31 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 1 0 0");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");

#if WTI_CESOP_TDI
   CLI_F_PwConfigureFramedTdi("0 2 0 1 1");
#else
   CLI_F_PwConfigureFramed("0 2 24 24 1 1");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 24");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 32");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 1b1b1b1b 22222222");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 31 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 1");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 1 0");

}
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_T1Framed24DS0CasUnFrgOctal(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

#if WTI_CESOP_TDI
   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to T1 FRAMED CAS */
   for (i=0;i<3;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   CLI_F_PwConfigureFramedTdi("0 1 0 24 0-23");
#else
   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");
   /* configure UFE lines */
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 1 0",i);
      CLI_F_UfeTransferMode(temp_buf);
   }
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   CLI_F_UfeCasMode("0 1 1");
   CLI_F_UfeCasMode("0 2 1");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureFramed("0 1 24 24 24 0-23");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 576"); /* 24 (frames per multiframe) * 24 (slots per frame) */
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 d");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 1a1a1a1a 11111111");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 264 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 1 0 0");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");

#if WTI_CESOP_TDI
   CLI_F_PwConfigureFramedTdi("0 2 0 24 0-23");
#else
   CLI_F_PwConfigureFramed("0 2 24 24 24 0-23");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 576");
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 1b1b1b1b 22222222");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 264 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 1");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 1 0");

}

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_T1Framed1DS0CasFrgOctal(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

#if WTI_CESOP_TDI
   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to T1 FRAMED CAS */
   for (i=0;i<3;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   CLI_F_PwConfigureFramedTdi("0 1 0 1 1");
#else
   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");
   /* configure UFE lines */
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 1 0",i);
      CLI_F_UfeTransferMode(temp_buf);
   }
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   CLI_F_UfeCasMode("0 1 1");
   CLI_F_UfeCasMode("0 2 1");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureFramed("0 1 8 8 1 1");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 8");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 23");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 1a1a1a1a 11111111");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 20 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 1 0 0");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");

#if WTI_CESOP_TDI
   CLI_F_PwConfigureFramedTdi("0 2 0 1 1");
#else
   CLI_F_PwConfigureFramed("0 2 8 8 1 1");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 8");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 23");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 1b1b1b1b 22222222");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 20 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 1");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 1 0");

}
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_T1Framed24DS0CasFrgOctal(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

#if WTI_CESOP_TDI
   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to T1 FRAMED CAS */
   for (i=0;i<3;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   CLI_F_PwConfigureFramedTdi("0 1 0 24 0-23");
#else
   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");
   /* configure UFE lines */
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 1 0",i);
      CLI_F_UfeTransferMode(temp_buf);
   }
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   CLI_F_UfeCasMode("0 1 1");
   CLI_F_UfeCasMode("0 2 1");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureFramed("0 1 24 24 24 0-23");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 192"); /* 8 frames */
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 1a1a1a1a 11111111");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 d8 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 1 0 0");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");

#if WTI_CESOP_TDI
   CLI_F_PwConfigureFramedTdi("0 2 0 24 0-23");
#else
   CLI_F_PwConfigureFramed("0 2 24 24 24 0-23");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 192"); /* 8 frames */
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 1b1b1b1b 22222222");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 d8 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 1");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 1 0");

}

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_T1Framed1DS0CasUnFrgOctalOobc(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
#if (!WTI_CESOP_TDI)
   WP_status status;
#endif

   /* allocate CESoP system */
   WTI_SystemAlloc();

#if WTI_CESOP_TDI
   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to T1 FRAMED CAS */
   for (i=0;i<3;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   /* port_index, transfer_mode (0-T1, 1-E1), num_slots, slots_array */
   CLI_F_PwConfigureFramedTdi("0 1 0 1 0");

#else
   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");
   /* configure UFE lines */
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 1 0",i);
      CLI_F_UfeTransferMode(temp_buf);
   }
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   CLI_F_UfeCasMode("0 1 1");
   CLI_F_UfeCasMode("0 2 1");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   /* register event handler function */
   status = WP_ControlRegister(WP_EVENT_POLLED_RX_INDICATE, cesop_event_function);/* in ofbc */
   WTI_TerminateOnError(status, "WP_ControlRegister", __LINE__);

   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureFramed("0 1 24 24 1 1");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 24");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 23");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 e");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 1a1a1a1a 11111111");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 30 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 1 0 0");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 1 0 0"); /* The middle must be 1 in oobc */
   CLI_F_PwEnable("0 0 0");

   /* Th Following is for the 2nd T1 */
#if WTI_CESOP_TDI
   CLI_F_PwConfigureFramedTdi("0 2 0 1 1");
#else
   CLI_F_PwConfigureFramed("0 2 24 24 1 1");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 24");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 32");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 7");

   /* **************** TDM --> PSN IW ***************** */

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 1b1b1b1b 22222222");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 30 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 1");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /* **************** PSN --> TDM Tx binding***************** */

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 1 0 0");
   CLI_F_PwEnable("0 1 0");

} /* CLI_F_T1Framed1DS0CasUnFrgOctalOobc() */

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_E1Framed1DS0CasUnFrgOctalOobc(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
#if (!WTI_CESOP_TDI)
   WP_status status;
#endif

   /* allocate CESoP system */
   WTI_SystemAlloc();

#if WTI_CESOP_TDI
   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to E1 FRAMED CAS */
   for (i=0;i<3;i++)
   {
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   CLI_F_PwConfigureFramedTdi("0 1 1 1 1");
#else
   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");
   /* configure UFE lines */
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 3 0",i);
      CLI_F_UfeTransferMode(temp_buf);
   }
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   CLI_F_UfeCasMode("0 1 1");
   CLI_F_UfeCasMode("0 2 1");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   /* register event handler function */
   status = WP_ControlRegister(WP_EVENT_POLLED_RX_INDICATE, cesop_event_function);
   WTI_TerminateOnError(status, "WP_ControlRegister", __LINE__);

   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureFramed("0 1 16 16 1 1");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 16");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 25");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 e");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 1a1a1a1a 11111111");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 28 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 1 0 0");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 1 0 0");
   CLI_F_PwEnable("0 0 0");

#if WTI_CESOP_TDI
   CLI_F_PwConfigureFramedTdi("0 2 1 1 1");
#else
   CLI_F_PwConfigureFramed("0 2 16 16 1 1");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 16");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 25");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 7");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 1b1b1b1b 22222222");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 28 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 1");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 1 0 0");
   CLI_F_PwEnable("0 1 0");

}

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_T1Framed1DS0CasUnFrgOctalOobc_2Boards(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR ip_hdr[WTI_MAX_STRING_SIZE];
#if !WTI_CESOP_TDI
   WP_status status;
#endif
   /* allocate CESoP system */
   WTI_SystemAlloc();

#if WTI_CESOP_TDI
   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to T1 FRAMED CAS */
   for (i=0;i<3;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   /* port_index, transfer_mode (0-T1, 1-E1), num_slots, slots_array */
   /* CLI_F_PwConfigureFramedTdi("0 1 0 1 0"); */
   CLI_F_PwConfigureFramedTdi("0 1 0 24 0-23");

#else
   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");
   /* configure UFE lines */
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 3 0",i);
      CLI_F_UfeTransferMode(temp_buf);
   }
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   CLI_F_UfeCasMode("0 1 1");
   CLI_F_UfeCasMode("0 2 1");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   /* register event handler function */
   status = WP_ControlRegister(WP_EVENT_POLLED_RX_INDICATE, cesop_event_function);/* in ofbc */
   WTI_TerminateOnError(status, "WP_ControlRegister", __LINE__);

   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureFramed("0 1 16 16 1 1");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   /* CLI_F_Pwe3ChannelRxBufferSize("0 24"); */
   CLI_F_Pwe3ChannelRxBufferSize("0 96");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 23");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 e");

   /**************** TDM --> PSN IW *****************/
#ifdef WTI_BOARD_1
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 00 00 00 00 00 0800");
   strcpy(ip_hdr, "0 45000000 811e0000 40110000 0a00010a 0a00020a");
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 00 00 00 00 00 0800");
   strcpy(ip_hdr, "0 45000000 811e0000 40110000 0a00020a 0a00010a");
#endif
   CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
   CLI_F_Tdm2PsnFlowAggIpHeader(ip_hdr);
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 78 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 1 0 0");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   /* oobc mode(0,1) , Clock Master Flag */
   CLI_F_PwCreate("0 1 0 0");

   /* pw_index, Clock Master Flag */
   CLI_F_PwEnable("0 0 0");

} /* CLI_F_T1Framed1DS0CasUnFrgOctalOobc_2Boards() */

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_E1Framed1DS0CasUnFrgOctalOobc_2Boards(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR ip_hdr[WTI_MAX_STRING_SIZE];
#if !WTI_CESOP_TDI
   WP_status status;
#endif
   /* allocate CESoP system */
   WTI_SystemAlloc();

#if WTI_CESOP_TDI
   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to E1 FRAMED CAS */
   for (i=0;i<3;i++)
   {
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   /* port_index, transfer_mode (0-T1, 1-E1), num_slots, slots_array */
   /* CLI_F_PwConfigureFramedTdi("0 1 1 1 1"); */
   CLI_F_PwConfigureFramedTdi("0 1 1 30 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");

#else
   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");
   /* configure UFE lines */
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 3 0",i);
      CLI_F_UfeTransferMode(temp_buf);
   }
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   CLI_F_UfeCasMode("0 1 1");
   CLI_F_UfeCasMode("0 2 1");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   /* register event handler function */
   status = WP_ControlRegister(WP_EVENT_POLLED_RX_INDICATE, cesop_event_function);/* in ofbc */
   WTI_TerminateOnError(status, "WP_ControlRegister", __LINE__);

   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureFramed("0 1 16 16 1 1");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   /* CLI_F_Pwe3ChannelRxBufferSize("0 16"); */
   CLI_F_Pwe3ChannelRxBufferSize("0 240");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 25");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 e");

   /**************** TDM --> PSN IW *****************/
#ifdef WTI_BOARD_1
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 00 00 00 00 00 0800");
   strcpy(ip_hdr, "0 45000000 811e0000 40110000 0a00010a 0a00020a");
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 00 00 00 00 00 0800");
   strcpy(ip_hdr, "0 45000000 811e0000 40110000 0a00020a 0a00010a");
#endif
   CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
   CLI_F_Tdm2PsnFlowAggIpHeader(ip_hdr);
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 108 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 1 0 0");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   /* oobc mode(0,1) , Clock Master Flag */
   CLI_F_PwCreate("0 1 0 0");

   /* pw_index, Clock Master Flag */
   CLI_F_PwEnable("0 0 0");

} /* CLI_F_E1Framed1DS0CasUnFrgOctalOobc_2Boards() */

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_E1Framed1DS0CasFrgOctalOobc(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
#if (!WTI_CESOP_TDI)
   WP_status status;
#endif

   /* allocate CESoP system */
   WTI_SystemAlloc();

#if WTI_CESOP_TDI
   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to E1 FRAMED CAS */
   for (i=0;i<3;i++)
   {
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   CLI_F_PwConfigureFramedTdi("0 1 1 8 1-8");
#else
   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");
   /* configure UFE lines */
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 3 0",i);
      CLI_F_UfeTransferMode(temp_buf);
   }
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   CLI_F_UfeCasMode("0 1 1");
   CLI_F_UfeCasMode("0 2 1");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   /* register event handler function */
   status = WP_ControlRegister(WP_EVENT_POLLED_RX_INDICATE, cesop_event_function);
   WTI_TerminateOnError(status, "WP_ControlRegister", __LINE__);

   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureFramed("0 1 8 8 8 1-8");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 8");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 25,26,27,28,29,30,31,32");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 e");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 1a1a1a1a 11111111");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 20 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 1 0 0");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 1 0 0");
   CLI_F_PwEnable("0 0 0");

#if WTI_CESOP_TDI
   CLI_F_PwConfigureFramedTdi("0 2 1 2 1-2");
#else
   CLI_F_PwConfigureFramed("0 2 2 2 2 1-2");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 16");
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 25,26");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 7");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 1b1b1b1b 22222222");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 28 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 1");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 1 0 0");
   CLI_F_PwEnable("0 1 0");

}

#if WTI_CESOP_TDI
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_E1Framed256DS0CasFrgOctal(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to E1 FRAMED CAS */
   for (i=0;i<8;i++)
   {
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   for (i=0;i<256;++i)
   {
      sprintf(temp_buf, "0 %d 1 1 %d", i/32, i%32);
      CLI_F_PwConfigureFramedTdi(temp_buf);

      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 8");
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 31");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/

      CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
      sprintf(temp_buf, "0 45000000 811e0000 40110000 1a1a1a1a %d", i+1);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 20 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
      CLI_F_Tdm2PsnFlowAggTsParams("0 1 0 0");

      /**************** PSN --> TDM IW *****************/

      CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

      /**************** PSN --> TDM Tx binding*****************/

      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

      CLI_F_PwCreate("0 0 0 0");
      sprintf(temp_buf, "0 %d 0", i);
      CLI_F_PwEnable(temp_buf);
   }
}

#if WTI_CESOP_TO_MPLS_FA_CASCADING
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_E1Framed256DS0CasFrgOctalMplsCascading(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to E1 FRAMED CAS */
   for (i=0;i<8;i++)
   {
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   for (i=0;i<WTI_MAX_NUM_OF_MPLS_FA;++i)
   {
#if WTI_CESOP_MPLS_OVER_ENET
      /* create the l2 router MPLS flow aggregations */
      CLI_F_Tdm2PsnFlowAggEnetHeaderMpls("0 aa aa aa aa aa aa bb bb bb bb bb bb 8847");
      CLI_F_MplsFlowAggPrefixLength("0 18");
      sprintf(temp_buf,
              "0 %x %x %x %x %x %x",
              3*i,
              3*i+1,
              3*i+2,
              0x81000005,
              (0x88470000 | ((((WTI_MPLS_LABEL) >> 12) + WTI_MAX_PW + 1 + i) >> 4)),
              ((((((WTI_MPLS_LABEL) >> 12)  + WTI_MAX_PW + 1 + i) & 0xff) << 28) | 0x00ff0000));
      /*                              [mac destination] [mac source] [vlan] [type] [mpls header] */
      CLI_F_MplsFlowAggPrefixHeaderMpls(temp_buf);
      sprintf(temp_buf, "0 %d %d %d", 2, 28, 41); /* remark offsets for VLAN priority and PSN tunnel EXP bits */

      CLI_F_MplsFlowAggRemarkingOffsets(temp_buf);
      sprintf(temp_buf, "0 %d", i);
      CLI_F_MplsFlowAggCreate(temp_buf);
#else
#if WTI_CESOP_NATIVE_MPLS_IW
      /* create the l2 router MPLS flow aggregations */
      CLI_F_MplsFlowAggPrefixLength("0 0");
      sprintf(temp_buf,
              "0 %x",
              (((((WTI_MPLS_LABEL) >> 12) + WTI_MAX_PW + 1 + i) << 12) | 0xff));
      /*                              [mpls header] */
      CLI_F_MplsFlowAggPrefixHeaderMpls(temp_buf);
      sprintf(temp_buf, "0 %d %d", 1, 5); /* remark offsets for PSN tunnel EXP bits */

      CLI_F_MplsFlowAggRemarkingOffsets(temp_buf);
      sprintf(temp_buf, "0 %d", i);
      CLI_F_MplsFlowAggCreate(temp_buf);
#else
      /* create the l2 router MPLS flow aggregations */
      CLI_F_MplsFlowAggPrefixLength("0 4");
      sprintf(temp_buf,
              "0 %x %x",
              WTI_MPLSoPPP,
              (((((WTI_MPLS_LABEL) >> 12) + WTI_MAX_PW + 1 + i) << 12) | 0xff));
      /*                              [ppp] [mpls header] */
      CLI_F_MplsFlowAggPrefixHeaderMpls(temp_buf);
      sprintf(temp_buf, "0 %d %d", 1, 13); /* remark offsets for PSN tunnel EXP bits */

      CLI_F_MplsFlowAggRemarkingOffsets(temp_buf);
      sprintf(temp_buf, "0 %d", i);
      CLI_F_MplsFlowAggCreate(temp_buf);
#endif /* WTI_CESOP_NATIVE_MPLS_IW */
#endif /* WTI_CESOP_MPLS_OVER_ENET */
   }

   for (i=0;i<256;++i)
   {
      sprintf(temp_buf, "0 %d 1 1 %d", i/32, i%32);
      CLI_F_PwConfigureFramedTdi(temp_buf);

      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 8");
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 31");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/

      CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
      sprintf(temp_buf, "0 45000000 811e0000 40110000 1a1a1a1a %d", i+1);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 0 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
      CLI_F_Tdm2PsnFlowAggTsParams("0 1 0 0");
      sprintf(temp_buf, "0 %d %d %d", 2, (7-(i%7)), (i%7)); /* remark values for VLAN priority and PSN tunnel EXP bits */
      CLI_F_Tdm2PsnFlowAggRemarkingValues(temp_buf);

      /**************** PSN --> TDM IW *****************/

      CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

      /**************** PSN --> TDM Tx binding*****************/

      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

      sprintf(temp_buf, "0 %d %d %d %d %d", 0,0,0,(i%WTI_MAX_NUM_OF_MPLS_FA),i);
      CLI_F_PwCreateCascaded(temp_buf);

      sprintf(temp_buf, "0 %d 0", i);
      CLI_F_PwEnable(temp_buf);
   }
}
#endif /* WTI_CESOP_TO_MPLS_FA_CASCADING */
#endif

#if (!WTI_CESOP_TDI)

/*****************************************************************************/
/**********************************   SBI   **********************************/
/*****************************************************************************/

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_T1framed1DS0CasSbiOobc_2Boards(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR ip_hdr[WTI_MAX_STRING_SIZE];

#if (!WTI_CESOP_TDI)
   WP_status status;
#endif

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);
   memset(ip_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   CLI_F_UfeFpgaMode("0 2"); /* 1-octal, otherwise-SBI */

   CLI_F_UfeSbiSpeTransferMode("0 0 2"); /* spe_id  spe_transfer_mode */
   CLI_F_UfeSbiSpeTransferMode("0 1 0"); /* 0/1/2   0-IDLE, 1-E1, 2-T1 */
   CLI_F_UfeSbiSpeTransferMode("0 2 0");
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* UFE line configuration */
   for (i=0;i<WTI_T1_LINES_PER_SPE;++i)
   {
      /* e1t1_index  0-20
         val: 1-T1 Framed, 2-T1 UnFramed, 3-E1 Framed, 4-E1 UnFramed */
      sprintf(temp_buf,"0 %d 1 0", i);
      CLI_F_UfeTransferMode(temp_buf);

      /* e1t1_index  0-20
         val: 1-Cas Enable, otherwise-Cas Disable */
      sprintf(temp_buf,"0 %d 1", i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* 0-Normal, 1-Loopback */
   CLI_F_UfeSbiLoopbackMode("0 1");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   /* register event handler function */
   status = WP_ControlRegister(WP_EVENT_POLLED_RX_INDICATE, cesop_event_function);
   WTI_TerminateOnError(status, "WP_ControlRegister", __LINE__);

#ifdef WTI_BOARD_1
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 00 00 00 00 00 0800");
   strcpy(ip_hdr, "0 45000000 811e0000 40110000 0a00010a 0a00020a");
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 00 00 00 00 00 0800");
   strcpy(ip_hdr, "0 45000000 811e0000 40110000 0a00020a 0a00010a");
#endif

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
   strcat(enet_hdr, "0800");
#endif

   CLI_F_UfeChipInitLineSetup("");

   /* e1t1_index, rx_dataunit_size, tx_dataunit_size, num_slots, slots_array */
   /* CLI_F_PwConfigureFramed("0 0 24 24 1 0"); */
   CLI_F_PwConfigureFramed("0 0 24 24 24 0-23");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   /* CLI_F_Pwe3ChannelRxBufferSize("0 24"); */
   CLI_F_Pwe3ChannelRxBufferSize("0 96");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 23");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
   CLI_F_Tdm2PsnFlowAggIpHeader(ip_hdr);
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 78 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 1 0 0");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   /* oobc mode(0,1) , Clock Master Flag: 0-Normal, (1-Clock Recovery According to RX) */
   CLI_F_PwCreate("0 1 0 0");

   /* pw_index, Clock Master Flag */
   CLI_F_PwEnable("0 0 0");

} /* CLI_F_T1framed1DS0CasSbiOobc_2Boards() */

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_E1framed1DS0CasSbiOobc_2Boards(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR ip_hdr[WTI_MAX_STRING_SIZE];

#if (!WTI_CESOP_TDI)
   WP_status status;
#endif

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);
   memset(ip_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   CLI_F_UfeFpgaMode("0 2"); /* 1-octal, otherwise-SBI */

   CLI_F_UfeSbiSpeTransferMode("0 0 1"); /* spe_id  spe_transfer_mode */
   CLI_F_UfeSbiSpeTransferMode("0 1 0"); /* 0/1/2   0-IDLE, 1-E1, 2-T1 */
   CLI_F_UfeSbiSpeTransferMode("0 2 0");
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* UFE line configuration */
   for (i=0;i<WTI_E1_LINES_PER_SPE;++i)
   {
      /* e1t1_index  0-20
         val: 1-T1 Framed, 2-T1 UnFramed, 3-E1 Framed, 4-E1 UnFramed */
      sprintf(temp_buf,"0 %d 3 0", i);
      CLI_F_UfeTransferMode(temp_buf);

      /* e1t1_index  0-20
         val: 1-Cas Enable, otherwise-Cas DIisable */
      sprintf(temp_buf,"0 %d 1", i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* 0-Normal, 1-Loopback */
   CLI_F_UfeSbiLoopbackMode("0 1");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   /* register event handler function */
   status = WP_ControlRegister(WP_EVENT_POLLED_RX_INDICATE, cesop_event_function);
   WTI_TerminateOnError(status, "WP_ControlRegister", __LINE__);

#ifdef WTI_BOARD_1
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 00 00 00 00 00 0800");
   strcpy(ip_hdr, "0 45000000 811e0000 40110000 0a00010a 0a00020a");
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 00 00 00 00 00 0800");
   strcpy(ip_hdr, "0 45000000 811e0000 40110000 0a00020a 0a00010a");
#endif

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
   strcat(enet_hdr, "0800");
#endif

   CLI_F_UfeChipInitLineSetup("");

   /* e1t1_index, rx_dataunit_size, tx_dataunit_size, num_slots, slots_array */
   /* CLI_F_PwConfigureFramed("0 0 16 16 1 1"); */
   CLI_F_PwConfigureFramed("0 0 30 30 30 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   /* CLI_F_Pwe3ChannelRxBufferSize("0 16"); */
   CLI_F_Pwe3ChannelRxBufferSize("0 240");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
   CLI_F_Tdm2PsnFlowAggIpHeader(ip_hdr);
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 108 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 1 0 0");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   /* oobc mode(0,1) , Clock Master Flag: 0-Normal, (1-Clock Recovery According to RX) */
   CLI_F_PwCreate("0 0 0 0");

   /* pw_index, Clock Master Flag */
   CLI_F_PwEnable("0 0 0");

} /* CLI_F_E1framed1DS0CasSbiOobc_2Boards() */

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_SbiDifferentLinesInSpeE1E1E1(char *StrPrm)
{
   WP_U32 i, line_index, spe_index;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   for (i=0;i<63;++i)
   {
      if (i<21) /* first SPE E1 */
      {
         line_index = i;
         if (i<9) /* lines 0-8 are configured to E1 unframed */
         {
            sprintf(temp_buf,"0 %d 4 0", line_index);
            CLI_F_UfeTransferMode(temp_buf);
            sprintf(temp_buf,"0 %d 0 0", line_index);
            CLI_F_UfeCasMode(temp_buf);
         }
         else if (i<18) /* lines 9-17  are configured to E1 Framed without CAS */
         {
            sprintf(temp_buf,"0 %d 3 0", line_index);
            CLI_F_UfeTransferMode(temp_buf);
            sprintf(temp_buf,"0 %d 0 0", line_index);
            CLI_F_UfeCasMode(temp_buf);
         }
         else /* lines 18-20  are configured to E1 Framed with CAS */
         {
            sprintf(temp_buf,"0 %d 3 0", line_index);
            CLI_F_UfeTransferMode(temp_buf);
            sprintf(temp_buf,"0 %d 1 0", line_index);
            CLI_F_UfeCasMode(temp_buf);
         }
      }
      else if (i<42) /* second SPE E1 */
      {
         line_index = 28 + (i-21);
         if (i<28) /* lines 21-27 are configured to E1 unframed */
         {
            sprintf(temp_buf,"0 %d 4 0", line_index);
            CLI_F_UfeTransferMode(temp_buf);
            sprintf(temp_buf,"0 %d 0 0", line_index);
            CLI_F_UfeCasMode(temp_buf);
         }
         else if (i<33) /* lines 28-32 are configured to E1 Framed without CAS */
         {
            sprintf(temp_buf,"0 %d 3 0", line_index);
            CLI_F_UfeTransferMode(temp_buf);
            sprintf(temp_buf,"0 %d 0 0", line_index);
            CLI_F_UfeCasMode(temp_buf);
         }
         else /* lines 32-41 are configured to E1 Framed with CAS */
         {
            sprintf(temp_buf,"0 %d 3 0", line_index);
            CLI_F_UfeTransferMode(temp_buf);
            sprintf(temp_buf,"0 %d 1 0", line_index);
            CLI_F_UfeCasMode(temp_buf);
         }
      }
      else
      {
         line_index = 56 + (i-42);
         if (i<48) /* lines 42-47 are configured to E1 unframed */
         {
            sprintf(temp_buf,"0 %d 4 0", line_index);
            CLI_F_UfeTransferMode(temp_buf);
            sprintf(temp_buf,"0 %d 0 0", line_index);
            CLI_F_UfeCasMode(temp_buf);
         }
         else if (i<55) /* lines 48-54  are configured to E1 Framed without CAS */
         {
            sprintf(temp_buf,"0 %d 3 0", line_index);
            CLI_F_UfeTransferMode(temp_buf);
            sprintf(temp_buf,"0 %d 0 0", line_index);
            CLI_F_UfeCasMode(temp_buf);
         }
         else /* lines 55-62 are configured to E1 Framed with CAS */
         {
            sprintf(temp_buf,"0 %d 3 0", line_index);
            CLI_F_UfeTransferMode(temp_buf);
            sprintf(temp_buf,"0 %d 1 0", line_index);
            CLI_F_UfeCasMode(temp_buf);
         }
      }
   }

   CLI_F_UfeSbiLoopbackMode("0 1");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 2");
   CLI_F_UfeChipInitLineSetup("");

   for (i=0;i<21;++i)
   {
      line_index = i;
      if (i<9) /* lines 0-8 are configured to E1 unframed */
      {
         sprintf(temp_buf,"0 %d 32 32", line_index);
         CLI_F_PwConfigureUnframed(temp_buf);
      }
      else if (i<18) /* lines 9-17  are configured to E1 Framed without CAS */
      {
         sprintf(temp_buf,"0 %d 32 32 32 0-31", line_index);
         CLI_F_PwConfigureFramed(temp_buf);
      }
      else /* lines 18-27  are configured to E1 Framed with CAS */
      {
         sprintf(temp_buf,"0 %d 32 32 32 0-31", line_index);
         CLI_F_PwConfigureFramed(temp_buf);
      }

      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 256");
      CLI_F_Pwe3ChannelRxBufferSize("0 32");
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,0,1,2,3,4,5,6,7");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,0,1,2,3,4,5,6,7");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/

      CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");

      sprintf(temp_buf,"0 45000000 811e0000 40110000 1a1a1a1a %x", i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 38 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
      CLI_F_Tdm2PsnFlowAggTsParams("0 1 0 0");

      /**************** PSN --> TDM IW *****************/

      CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

      /**************** PSN --> TDM Tx binding*****************/

      CLI_F_Psn2TdmTxBinWindowThreshold("0 128");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 64");

      CLI_F_PwCreate("0 0 0 0");

      sprintf(temp_buf,"0 %d 0", i);
      CLI_F_PwEnable(temp_buf);
   }

   for (i=21;i<42;++i)
   {
      line_index = 28 + (i - 21);
      if (i<28) /* lines 21-27 are configured to E1 unframed */
      {
         sprintf(temp_buf,"0 %d 32 32", line_index);
         CLI_F_PwConfigureUnframed(temp_buf);
      }
      else if (i<33) /* lines 28-32 are configured to E1 Framed without CAS */
      {
         sprintf(temp_buf,"0 %d 32 32 32 0-31", line_index);
         CLI_F_PwConfigureFramed(temp_buf);
      }
      else /* lines 33-41 are configured to E1 Framed with CAS */
      {
         sprintf(temp_buf,"0 %d 32 32 32 0-31", line_index);
         CLI_F_PwConfigureFramed(temp_buf);
      }

      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 256");
      CLI_F_Pwe3ChannelRxBufferSize("0 32");
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/

      CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");

      sprintf(temp_buf,"0 45000000 811e0000 40110000 1a1a1a1a %x", i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 38 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
      CLI_F_Tdm2PsnFlowAggTsParams("0 1 0 0");

      /**************** PSN --> TDM IW *****************/

      CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

      /**************** PSN --> TDM Tx binding*****************/

      CLI_F_Psn2TdmTxBinWindowThreshold("0 128");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 64");

      CLI_F_PwCreate("0 0 0 0");

      sprintf(temp_buf,"0 %d 0", i);
      CLI_F_PwEnable(temp_buf);
   }

   for (i=42;i<63;++i)
   {
      line_index = 56 + (i-42);
      if (i<48) /* lines 42-47 are configured to E1 unframed */
      {
         sprintf(temp_buf,"0 %d 32 32", line_index);
         CLI_F_PwConfigureUnframed(temp_buf);
      }
      else if (i<55) /* lines 48-54  are configured to E1 Framed without CAS */
      {
         sprintf(temp_buf,"0 %d 32 32 32 0-31", line_index);
         CLI_F_PwConfigureFramed(temp_buf);
      }
      else /* lines 55-62 are configured to E1 Framed with CAS */
      {
         sprintf(temp_buf,"0 %d 32 32 32 0-31", line_index);
         CLI_F_PwConfigureFramed(temp_buf);
      }

      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 256");
      CLI_F_Pwe3ChannelRxBufferSize("0 32");
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,15,16,17,18,19,20,21,22");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,15,16,17,18,19,20,21,22");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/

      CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");

      sprintf(temp_buf,"0 45000000 811e0000 40110000 1a1a1a1a %x", i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 38 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
      CLI_F_Tdm2PsnFlowAggTsParams("0 1 0 0");

      /**************** PSN --> TDM IW *****************/

      CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

      /**************** PSN --> TDM Tx binding*****************/

      CLI_F_Psn2TdmTxBinWindowThreshold("0 128");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 64");

      CLI_F_PwCreate("0 0 0 0");

      sprintf(temp_buf,"0 %d 0", i);
      CLI_F_PwEnable(temp_buf);
   }
}

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_SbiDifferentLinesInSpeT1T1T1(char *StrPrm)
{
   WP_U32 i, line_index, spe_index, pw_index = 0;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   for (i=0;i<84;++i)
   {
      line_index = i;

      if (i<28) /* first SPE T1 unframed */
      {
         sprintf(temp_buf,"0 %d 1 0", line_index);
         CLI_F_UfeTransferMode(temp_buf);
         sprintf(temp_buf,"0 %d 1", line_index);
         CLI_F_UfeCasMode(temp_buf);

      }

      else if (i<56) /* second SPE T1 Framed with CAS*/
      {
         sprintf(temp_buf,"0 %d 2 0", line_index);
         CLI_F_UfeTransferMode(temp_buf);
         sprintf(temp_buf,"0 %d 0", line_index);
         CLI_F_UfeCasMode(temp_buf);

      }
      else/* third SPE T1 unframed */
      {
         sprintf(temp_buf,"0 %d 2 0", line_index);
         CLI_F_UfeTransferMode(temp_buf);
         sprintf(temp_buf,"0 %d 0", line_index);
         CLI_F_UfeCasMode(temp_buf);
      }

   }

   CLI_F_UfeSbiLoopbackMode("0 1");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 1");

   CLI_F_UfeChipInitLineSetup("");


   for (i=0;i<84;++i)
   {
      line_index = i;

      if (i<28) /* lines 0-8 are configured to T1 unframed */
      {
         sprintf(temp_buf,"0 %d 24 24 24 0-23", line_index);
         CLI_F_PwConfigureFramed(temp_buf);
      }
      else if (i<56) /* lines 9-17  are configured to E1 Framed without CAS */
      {
         sprintf(temp_buf,"0 %d 24 24", line_index);
         CLI_F_PwConfigureUnframed(temp_buf);
      }
      else /* lines 18-27  are configured to E1 Framed with CAS */
      {
         sprintf(temp_buf,"0 %d 24 24", line_index);
         CLI_F_PwConfigureUnframed(temp_buf);
      }
      /* PWE3 channel configuration */

      CLI_F_Pwe3ChannelJitterBufferSize("0 256");
      CLI_F_Pwe3ChannelRxBufferSize("0 192");

      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
      CLI_F_Pwe3ChannelUdpDummyMode("0 a");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/

      CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");

      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);

      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 d8 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
      CLI_F_Tdm2PsnFlowAggTsParams("0 0 0 0");

      /**************** PSN --> TDM IW *****************/

      CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

      /**************** PSN --> TDM Tx binding*****************/

      CLI_F_Psn2TdmTxBinWindowThreshold("0 128");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 64");

      sprintf(temp_buf,"0 0 0 0");
      CLI_F_PwCreate(temp_buf);

      sprintf(temp_buf,"0 %d 0", pw_index);
      CLI_F_PwEnable(temp_buf);
      pw_index++;
   }

}
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_E1UnframedNoCasSbi(char *StrPrm)
{
   WP_U32 i, spe_index;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* UFE line configuration */
   for (i=0;i<WTI_E1_LINES_PER_SPE;++i)
   {
      sprintf(temp_buf,"0 %d 4 0", i);
      CLI_F_UfeTransferMode(temp_buf);
      sprintf(temp_buf,"0 %d 0", i);
      CLI_F_UfeCasMode(temp_buf);
   }

   CLI_F_UfeSbiLoopbackMode("0 0");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 2");
   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureUnframed("0 1 64 32");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 130");/*256*/
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 11111111 1a1a1a1a");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 9a 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
#if WTI_ACTIVE_ABSOLUTE_MODE
   sprintf(temp_buf, "0 1 0 0");
#else
   sprintf(temp_buf, "0 0 0 0");
#endif
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
   CLI_F_Tdm2PsnFlowAggTsConstSet("0 4");/*3*/

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");
   CLI_F_Psn2TdmTxBinLOPSDetection("0 1 6 4");             /* LOPS parameters */

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");

   CLI_F_PwConfigureUnframed("0 2 64 32");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 256");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 22222222 1b1b1b1b");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 118 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
#if WTI_ACTIVE_ABSOLUTE_MODE
   sprintf(temp_buf, "0 1 0 0");
#else
   sprintf(temp_buf, "0 0 1 1");
#endif
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
   CLI_F_Tdm2PsnFlowAggTsConstSet("0 256");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");
   CLI_F_Psn2TdmTxBinLOPSDetection("0 1 6 4");             /* LOPS parameters */

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 1 0");

}
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_E1Framed1DS0NoCasSbi(char *StrPrm)
{
   WP_U32 i, spe_index;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* UFE line configuration */
   for (i=0;i<WTI_E1_LINES_PER_SPE;++i)
   {
      sprintf(temp_buf,"0 %d 3 0", i);
      CLI_F_UfeTransferMode(temp_buf);
      sprintf(temp_buf,"0 %d 0", i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* SBI Loopback mode */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 3");
   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureFramed("0 1 20 10 1 31");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 40");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 31");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 11111111 1a1a1a1a");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 40 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
#if WTI_ACTIVE_ABSOLUTE_MODE
   sprintf(temp_buf, "0 1 0 0");
#else
   sprintf(temp_buf, "0 0 1 1");
#endif
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
   CLI_F_Tdm2PsnFlowAggTsConstSet("0 1");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");

   CLI_F_PwConfigureFramed("0 2 20 10 1 31");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 40");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 32");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 22222222 1b1b1b1b");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 40 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
#if WTI_ACTIVE_ABSOLUTE_MODE
   sprintf(temp_buf, "0 1 0 0");
#else
   sprintf(temp_buf, "0 0 1 1");
#endif
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
   CLI_F_Tdm2PsnFlowAggTsConstSet("0 256");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 1 0");

}
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_E1Framed32DS0NoCasSbi(char *StrPrm)
{
   WP_U32 i, spe_index;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* UFE line configuration */
   for (i=0;i<WTI_E1_LINES_PER_SPE;++i)
   {
      sprintf(temp_buf,"0 %d 3 0", i);
      CLI_F_UfeTransferMode(temp_buf);
      sprintf(temp_buf,"0 %d 0", i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* SBI Loopback mode */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 3");
   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureFramed("0 1 32 32 32 0-31");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 32");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 11111111 1a1a1a1a");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 38 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
#if WTI_ACTIVE_ABSOLUTE_MODE
   sprintf(temp_buf, "0 1 0 0");
#else
   sprintf(temp_buf, "0 0 0 0");
#endif
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
   CLI_F_Tdm2PsnFlowAggTsConstSet("0 1");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");

   CLI_F_PwConfigureFramed("0 2 32 32 32 0-31");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 32");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 22222222 1b1b1b1b");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 38 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
#if WTI_ACTIVE_ABSOLUTE_MODE
   sprintf(temp_buf, "0 1 0 0");
#else
   sprintf(temp_buf, "0 0 1 1");
#endif
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
   CLI_F_Tdm2PsnFlowAggTsConstSet("0 256");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 1 0");

}

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_E1Framed2DS0256PwNoCasSbi(char *StrPrm)
{
   WP_U32 i, j, line_index, spe_index, pw_index;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 2");

   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* UFE line configuration */
   for (i=0;i<WTI_E1_LINES_PER_SPE;++i)
   {
      sprintf(temp_buf,"0 %d 3 0", i);
      CLI_F_UfeTransferMode(temp_buf);
      sprintf(temp_buf,"0 %d 0", i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* SBI Loopback mode */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 3");

   CLI_F_UfeChipInitLineSetup("");

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE*16; j++)
      {
         line_index = i*28 + j/16;
         pw_index = i*WTI_E1_LINES_PER_SPE*16 + j;

         if (pw_index >= WTI_MAX_PW)
         {
            printf("\n ** Warning: pw_index exceed maximum PW allowed **\n");
            break;
         }


         sprintf(temp_buf, "0 %d 32 32 2 %d-%d", line_index, 2*(pw_index%16), 2*(pw_index%16)+1);
         CLI_F_PwConfigureFramed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 2");
         CLI_F_Pwe3ChannelRxBufferSize("0 32");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

         CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x11111111+pw_index,0x1a1a1a1a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 38 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
         sprintf(temp_buf, "0 0 0 %d",pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);

         /**************** PSN --> TDM IW *****************/

         CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

         /**************** PSN --> TDM Tx binding*****************/

         CLI_F_Psn2TdmTxBinWindowThreshold("0 1");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 1");

         CLI_F_PwCreate("0 0 0 0");
         sprintf(temp_buf, "0 %d 0",pw_index);
         CLI_F_PwEnable(temp_buf);
      }
   }

}

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_E1Framed1DS0CasUnFrgSbi(char *StrPrm)
{
   WP_U32 i, spe_index;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 2");

   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* UFE line configuration */
   for (i=0;i<WTI_E1_LINES_PER_SPE;++i)
   {
      sprintf(temp_buf,"0 %d 3 0", i);
      CLI_F_UfeTransferMode(temp_buf);
      sprintf(temp_buf,"0 %d 1", i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* SBI Loopback mode */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 9");

   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureFramed("0 1 16 16 1 1");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 16");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 31");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 11111111 1a1a1a1a");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 29 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 1 0 0");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");

   CLI_F_PwConfigureFramed("0 2 16 16 1 1");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 16");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 32");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 22222222 1b1b1b1b");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 29 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 1");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 1 0");

}
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_E1Framed30DS0CasUnFrgSbi(char *StrPrm)
{
   WP_U32 i, spe_index;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 2");

   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* UFE line configuration */
   for (i=0;i<WTI_E1_LINES_PER_SPE;++i)
   {
      sprintf(temp_buf,"0 %d 3 0", i);
      CLI_F_UfeTransferMode(temp_buf);
      sprintf(temp_buf,"0 %d 1", i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* SBI Loopback mode */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 9");

   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureFramed("0 1 30 30 30 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 480"); /*16*30*/
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 d");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 11111111 1a1a1a1a");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 207 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 0 0");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");

   CLI_F_PwConfigureFramed("0 2 30 30 30 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 480");
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 22222222 1b1b1b1b");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 207 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 1");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 1 0");

}
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_E1Framed1DS0CasFrgSbi(char *StrPrm)
{
   WP_U32 i, spe_index;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 2");

   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* UFE line configuration */
   for (i=0;i<WTI_E1_LINES_PER_SPE;++i)
   {
      sprintf(temp_buf,"0 %d 3 0", i);
      CLI_F_UfeTransferMode(temp_buf);
      sprintf(temp_buf,"0 %d 1", i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* SBI Loopback mode */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 9");

   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureFramed("0 1 8 8 1 1");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 8");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 31");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 11111111 1a1a1a1a");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 20 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 1 0 0");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");

   CLI_F_PwConfigureFramed("0 2 8 8 1 1");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 8");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 31");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 22222222 1b1b1b1b");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 20 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 1");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 1 0");

}
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_E1Framed30DS0CasFrgSbi(char *StrPrm)
{
   WP_U32 i, spe_index;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 2");

   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* UFE line configuration */
   for (i=0;i<WTI_E1_LINES_PER_SPE;++i)
   {
      sprintf(temp_buf,"0 %d 3 0", i);
      CLI_F_UfeTransferMode(temp_buf);
      sprintf(temp_buf,"0 %d 1", i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* SBI Loopback mode */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 9");

   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureFramed("0 1 30 30 30 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 240");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 11111111 1a1a1a1a");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 108 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 1 0 0");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");

   CLI_F_PwConfigureFramed("0 2 30 30 30 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 240");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 22222222 1b1b1b1b");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 108 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 1");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 1 0");

}
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_T1UnframedNoCasSbi(char *StrPrm)
{
   WP_U32 i, spe_index;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* UFE line configuration */
   for (i=0;i<WTI_T1_LINES_PER_SPE;++i)
   {
      sprintf(temp_buf,"0 %d 2 0", i);
      CLI_F_UfeTransferMode(temp_buf);
      sprintf(temp_buf,"0 %d 0", i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* SBI Loopback mode */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 0");
   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureUnframed("0 1 48 24");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 192");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 11111111 1a1a1a1a");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 d8 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
#if WTI_ACTIVE_ABSOLUTE_MODE
   sprintf(temp_buf, "0 1 0 0");
#else
   sprintf(temp_buf, "0 0 0 0");
#endif
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
   CLI_F_Tdm2PsnFlowAggTsConstSet("0 193");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");

   CLI_F_PwConfigureUnframed("0 2 48 24");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 192");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 22222222 1b1b1b1b");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 d8 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
#if WTI_ACTIVE_ABSOLUTE_MODE
   sprintf(temp_buf, "0 1 0 0");
#else
   sprintf(temp_buf, "0 0 1 1");
#endif
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
   CLI_F_Tdm2PsnFlowAggTsConstSet("0 1");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 1 0");

}

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_T1Framed1DS0NoCasSbi(char *StrPrm)
{
   WP_U32 i, spe_index;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* UFE line configuration */
   for (i=0;i<WTI_T1_LINES_PER_SPE;++i)
   {
      sprintf(temp_buf,"0 %d 1 0", i);
      CLI_F_UfeTransferMode(temp_buf);
      sprintf(temp_buf,"0 %d 0", i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* SBI Loopback mode */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 1");

   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureFramed("0 1 20 10 1 23");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 40");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 24");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 11111111 1a1a1a1a");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 40 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
#if WTI_ACTIVE_ABSOLUTE_MODE
   sprintf(temp_buf, "0 1 0 0");
#else
   sprintf(temp_buf, "0 0 1 0");
#endif
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
   CLI_F_Tdm2PsnFlowAggTsConstSet("0 1");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");

   CLI_F_PwConfigureFramed("0 2 20 10 1 23");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 40");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 24");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 22222222 1b1b1b1b");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 40 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
#if WTI_ACTIVE_ABSOLUTE_MODE
   sprintf(temp_buf, "0 1 0 0");
#else
   sprintf(temp_buf, "0 0 1 1");
#endif
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
   CLI_F_Tdm2PsnFlowAggTsConstSet("0 193");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 1 0");

}
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_T1Framed24DS0NoCasSbi(char *StrPrm)
{
   WP_U32 i, spe_index;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* UFE line configuration */
   for (i=0;i<WTI_T1_LINES_PER_SPE;++i)
   {
      sprintf(temp_buf,"0 %d 1 0", i);
      CLI_F_UfeTransferMode(temp_buf);
      sprintf(temp_buf,"0 %d 0", i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* SBI Loopback mode */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 1");

   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureFramed("0 1 48 24 24 0-23");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 192");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 11111111 1a1a1a1a");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 d8 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
#if WTI_ACTIVE_ABSOLUTE_MODE
   sprintf(temp_buf, "0 1 0 0");
#else
   sprintf(temp_buf, "0 0 1 0");
#endif
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
   CLI_F_Tdm2PsnFlowAggTsConstSet("0 1");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");

   CLI_F_PwConfigureFramed("0 2 48 24 24 0-23");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 192");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 22222222 1b1b1b1b");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 d8 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
#if WTI_ACTIVE_ABSOLUTE_MODE
   sprintf(temp_buf, "0 1 0 0");
#else
   sprintf(temp_buf, "0 0 1 1");
#endif
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
   CLI_F_Tdm2PsnFlowAggTsConstSet("0 193");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 1 0");

}
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_T1Framed1DS0CasUnFrgSbi(char *StrPrm)
{
   WP_U32 i, spe_index;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* UFE line configuration */
   for (i=0;i<WTI_T1_LINES_PER_SPE;++i)
   {
      sprintf(temp_buf,"0 %d 1 0", i);
      CLI_F_UfeTransferMode(temp_buf);
      sprintf(temp_buf,"0 %d 1", i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* SBI Loopback mode */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 8");  /* T1 ESF (for CAS) */

   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureFramed("0 1 24 24 1 1");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 24");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 23");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
#ifdef WTI_BOARD_1
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 11111111 1a1a1a1a");
#else /* Board 2 */
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 1a1a1a1a 11111111");
#endif
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 31 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 0");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");

   CLI_F_PwConfigureFramed("0 2 24 24 1 1");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 24");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 32");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
#ifdef WTI_BOARD_1
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 22222222 1b1b1b1b");
#else /* Board 2 */
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 1b1b1b1b 22222222");
#endif
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 31 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 1");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 1 0");

}
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_T1Framed24DS0CasUnFrgSbi(char *StrPrm)
{
   WP_U32 i, spe_index;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* UFE line configuration */
   for (i=0;i<WTI_T1_LINES_PER_SPE;++i)
   {
      sprintf(temp_buf,"0 %d 1 0", i);
      CLI_F_UfeTransferMode(temp_buf);
      sprintf(temp_buf,"0 %d 1", i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* SBI Loopback mode */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf, 9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 8");   /* T1 ESF (for T1 CAS) */

   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureFramed("0 1 24 24 24 0-23");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 576"); /* 24*24 */
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 d");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 11111111 1a1a1a1a");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 264 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 0 0");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");

   CLI_F_PwConfigureFramed("0 2 24 24 24 0-23");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 576");   /* 24 bytes * 24 frames/multiframe */
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 22222222 1b1b1b1b");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 264 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 1");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 1 0");

}
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_T1Framed1DS0CasFrgSbi(char *StrPrm)
{
   WP_U32 i, spe_index;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* UFE line configuration */
   for (i=0;i<WTI_T1_LINES_PER_SPE;++i)
   {
      sprintf(temp_buf,"0 %d 1 0", i);
      CLI_F_UfeTransferMode(temp_buf);
      sprintf(temp_buf,"0 %d 1", i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* SBI Loopback mode */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf, 9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 8");   /* T1-ESF (for T1 CAS) */

   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureFramed("0 1 8 8 1 1");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 8");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 23");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 11111111 1a1a1a1a");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 20 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 0");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");

   CLI_F_PwConfigureFramed("0 2 8 8 1 1");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 8");
   CLI_F_Pwe3ChannelTxUdpattern("0 0");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 23");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 22222222 1b1b1b1b");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 32 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 1");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 1 0");

}
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_T1Framed24DS0CasFrgSbi(char *StrPrm)
{
   WP_U32 i, spe_index;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* UFE line configuration */
   for (i=0;i<WTI_T1_LINES_PER_SPE;++i)
   {
      sprintf(temp_buf,"0 %d 1 0", i);
      CLI_F_UfeTransferMode(temp_buf);
      sprintf(temp_buf,"0 %d 1", i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* SBI Loopback mode */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf, 9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 8");   /* T1-ESF (for T1 CAS) */

   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureFramed("0 1 24 24 24 0-23");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 192");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 11111111 1a1a1a1a");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 d8 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 0");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");

   CLI_F_PwConfigureFramed("0 2 24 24 24 0-23");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 192");
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 22222222 1b1b1b1b");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 d8 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 1");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 1 0");

}
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_T1FramedNoCasSbiStress2016Pw(char *StrPrm)
{
   WP_U32 i, spe_index, line, slot;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* UFE line configuration */
   for (i=0;i<(3*WTI_T1_LINES_PER_SPE);++i)
   {
      sprintf(temp_buf,"0 %d 1 0", i);
      CLI_F_UfeTransferMode(temp_buf);
      sprintf(temp_buf,"0 %d 0", i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* SBI Loopback mode */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 1");

   CLI_F_UfeChipInitLineSetup("");
   CLI_F_StatShowMem("");

   line = 0;
   slot = 0;

   for (i=0;i<WTI_MAX_PW;i++)
   {
      /*printf("PW %d configure: line %d slot %d\n", i, line, slot);*/
      sprintf(temp_buf,"0 %d 64 32 1 %d", line, slot);
      slot++;
      if (slot % 24 == 0)
      {
         line++;
         slot = 0;
      }

      CLI_F_PwConfigureFramed(temp_buf);

      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 256");
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 25");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 55");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/

      CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
      sprintf(temp_buf,"0 45000000 811e0000 40110000 %x %x", 0x11111111+i ,0x1a1a1a1a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
      CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 0");

      /**************** PSN --> TDM IW *****************/

      CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

      /**************** PSN --> TDM Tx binding*****************/

      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

      CLI_F_PwCreate("0 0 0 0");
      sprintf(temp_buf,"0 %d 0",i);
      CLI_F_PwEnable(temp_buf);

   }
}

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_E1UnframedNoCasSbiAddDelete(char *StrPrm)
{
   WP_U32 i, spe_index;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* UFE line configuration */
   for (i=0;i<WTI_E1_LINES_PER_SPE;++i)
   {
      sprintf(temp_buf,"0 %d 4 0", i);
      CLI_F_UfeTransferMode(temp_buf);
      sprintf(temp_buf,"0 %d 0", i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* SBI Loopback mode */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 2");

   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureUnframed("0 1 64 32");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 130");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 32");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 24");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 11111111 1a1a1a1a");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 9a 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 0");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   for (i=0;i<100;++i)
   {
      WTI_PwCreate(0,0,0,0);
      WTI_PwEnable(0);
      WTI_PwDisable(0);
      WTI_PwDelete(0);
   }

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");

   CLI_F_PwConfigureUnframed("0 2 64 32");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 256");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 32");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 24");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 bb bb bb bb bb bb 00 bb 00 bb 00 bb 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811f0000 40110000 22222222 1b1b1b1b");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 2020 0002 118 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 1");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 1 0");

}


/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_252xDS1E1UnframedNoCasSbi(char *StrPrm)
{
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 i, j, line_index, spe_index;

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         sprintf(temp_buf,"0 %d 4 0", line_index);
         CLI_F_UfeTransferMode(temp_buf);
         sprintf(temp_buf,"0 %d 0", line_index);
         CLI_F_UfeCasMode(temp_buf);
      }
   }

   CLI_F_UfeSbiLoopbackMode("0 0");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 2");

   CLI_F_UfeChipInitLineSetup("");

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         sprintf(temp_buf, "0 %d 32 32",line_index);
         CLI_F_PwConfigureUnframed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 256");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 32");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

         CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
         sprintf(temp_buf, "0 45000000 811e0000 40110000 1a1a1a1a %x", (i*WTI_E1_LINES_PER_SPE + j));
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
         CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 0");

         /**************** PSN --> TDM IW *****************/

         CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

         /**************** PSN --> TDM Tx binding*****************/

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         CLI_F_PwCreate("0 0 0 0");
         sprintf(temp_buf, "0 %d 0", (i*WTI_E1_LINES_PER_SPE + j));
         CLI_F_PwEnable(temp_buf);
      }
   }
}

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_192PwE1FramedNoCasSbi(char *StrPrm)
{
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 i, spe_index;

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* UFE line configuration */
   for (i=0;i<24;++i)
   {
      sprintf(temp_buf,"0 %d 3 0", i);
      CLI_F_UfeTransferMode(temp_buf);
      sprintf(temp_buf,"0 %d 0", i);
      CLI_F_UfeCasMode(temp_buf);
   }

   CLI_F_UfeSbiLoopbackMode("0 1");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 3");

   CLI_F_UfeChipInitLineSetup("");

   for (i=1;i<192;i++)
   {
      sprintf(temp_buf, "0 %d 4 4 4 %d-%d",(i/8),((i%8)*4), (((i%8)*4)+3));
      CLI_F_PwConfigureFramed(temp_buf);

      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 64");
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 4,5,6,7");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 b");

      /**************** TDM --> PSN IW *****************/

      CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
      sprintf(temp_buf, "0 45000000 811e0000 40110000 1a1a1a1a %x", i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 58 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
      CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 0");

      /**************** PSN --> TDM IW *****************/

      CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

      /**************** PSN --> TDM Tx binding*****************/

      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

      CLI_F_PwCreate("0 0 0 0");
      sprintf(temp_buf, "0 %d 0", i-1);
      CLI_F_PwEnable(temp_buf);
   }
}

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_DS3UnframedNoCasSbi(char *StrPrm)
{
   WP_U32 spe_index;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   printf("--------DS3 unframed-------\n");

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 3",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* UFE line configuration */
   for (spe_index=0; spe_index<WTI_NUMBER_OF_SPE_DS3_E3; spe_index++)
   {
      WP_U32 line_index = WTI_LineIndexGet(spe_index, 0/*sub_spe*/);

      sprintf(temp_buf,"0 %d 2 0", line_index);
      CLI_F_UfeTransferMode(temp_buf);
      sprintf(temp_buf,"0 %d 0", line_index);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* SBI Loopback mode */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 4");

   CLI_F_UfeChipInitLineSetup("");

   sprintf(temp_buf, "0 %d 24 48", 0);
   CLI_F_PwConfigureUnframed(temp_buf);

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 192");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 1");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 2");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 11111111 1a1a1a1a");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 d8 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 0");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");
}

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_E3UnframedNoCasSbi(char *StrPrm)
{
   WP_U32 spe;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   printf("--------E3 unframed-------\n");

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 2");
   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe = 0; spe < N_ACTIVE_UFE_SBI_SPE; spe++)
   {
      sprintf(temp_buf, "0 %d 4",spe);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* UFE line configuration */

   for (spe=0; spe<WTI_NUMBER_OF_SPE_DS3_E3; spe++)
   {
      WP_U32 line_index = WTI_LineIndexGet(spe, 0);

      sprintf(temp_buf,"0 %d 4 0", line_index);
      CLI_F_UfeTransferMode(temp_buf);
      sprintf(temp_buf,"0 %d 0", line_index);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* SBI Loopback mode */
   CLI_F_UfeSbiLoopbackMode("0 0");    /* system loopback mode */

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 6");
   CLI_F_UfeChipInitLineSetup("");
   CLI_F_PwConfigureUnframed("0 0 32 64");

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 256");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 3");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 4");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 11111111 1a1a1a1a");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 0");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");
}

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_DS3FramedNoCasSbi(char *StrPrm)
{
   WP_U32 spe;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   printf("--------DS3 framed-------\n");

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe = 0; spe < N_ACTIVE_UFE_SBI_SPE; spe++)
   {
      sprintf(temp_buf, "0 %d 3",spe);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* UFE line configuration */
   for (spe=0; spe<WTI_NUMBER_OF_SPE_DS3_E3; spe++)
   {
      WP_U32 line_index = WTI_LineIndexGet(spe, 0/*sub_spe*/);

      sprintf(temp_buf,"0 %d 1 0", line_index);
      CLI_F_UfeTransferMode(temp_buf);
      sprintf(temp_buf,"0 %d 0", line_index);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* SBI Loopback mode */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 5");

   CLI_F_UfeChipInitLineSetup("");

   sprintf(temp_buf, "0 %d 24 24 1 0",0);
   CLI_F_PwConfigureFramed(temp_buf);

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 192");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 1");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 2");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 11111111 1a1a1a1a");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 d8 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 0");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");
}

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_E3FramedNoCasSbi(char *StrPrm)
{
   WP_U32 spe;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   printf("--------E3 framed-------\n");

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe = 0; spe < N_ACTIVE_UFE_SBI_SPE; spe++)
   {
      sprintf(temp_buf, "0 %d 4",spe);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* UFE line configuration */
   for (spe=0; spe<WTI_NUMBER_OF_SPE_DS3_E3; spe++)
   {
      WP_U32 line_index = WTI_LineIndexGet(spe, 0);

      sprintf(temp_buf,"0 %d 3 0", line_index);
      CLI_F_UfeTransferMode(temp_buf);
      sprintf(temp_buf,"0 %d 0", line_index);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* SBI Loopback mode */
   CLI_F_UfeSbiLoopbackMode("0 0");    /* system loopback mode */

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 7");

   CLI_F_UfeChipInitLineSetup("");

   sprintf(temp_buf, "0 %d 32 32 1 0",0);
   CLI_F_PwConfigureFramed(temp_buf);

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 256");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 3");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 4");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 11111111 1a1a1a1a");
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggTsParams("0 0 1 0");

   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");
}

/*

All UFE3 tests require the following configurations:
37900:
#define WTI_MAX_PW                                  4034
#define WTI_2_ENET_DEVICES                          1
#define WTI_FIRST_ENET_MAX_PW                       (WTI_MAX_PW / 2)
#define N_TRANS_TX_QUEUE_RING_LENGTH                8
#define N_TRANS_TX_QUEUE_RINGS                      (WTI_MAX_PW + 256)
wti_ufe_util.h:
define N_MAX_EMPHY_PHYS   4034
 */
/********************************************************************************************
 * Description:
 *            The test configures 6048 X (4DS0) PW's on 756 lines in E1 framed mode
 *            (required SBI-OC12 synthesis)
 *
 *******************************************************************************************/
void CLI_F_SBI_E1_F_NoCas_252_Line_2016_4xDS0_PWS(char *StrPrm)
{
   WP_U32 i, j, k, line_index, spe_index, timing_index, pw_index;
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U8   clock_rec_lines[84] = {0}; /* list of master lines */

   /* Set the CR lines (both for RX and TX direction */
#if (WTI_CESOP_RX_TIMING_ENABLE || WTI_CESOP_CLOCK_RECOVERY_ENABLE)
   for (i=0; i< global_active_cr_async_mode; i++)
   {/* Set lines to be CR master */
      clock_rec_lines[CLI_F_AttacheLineToPwNumber(i)] = 1;
   }
#endif

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }


   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE||WTI_CESOP_RX_TIMING_ENABLE)
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE || WTI_CESOP_RX_TIMING_ENABLE */

   /* UFE line configuration */
   for (i=0; i<12; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         timing_index = i*WTI_E1_LINES_PER_SPE + j;

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 3 3",line_index);
#else
            /* set ufe Tx direction only */
            sprintf(temp_buf, "0 %d 3 1",line_index);
#endif

#else /* Not WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Rx direction only */
            sprintf(temp_buf, "0 %d 3 2",line_index);
#endif

#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */
         }
         else
         {
#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Rx direction only - for all lines */
            sprintf(temp_buf, "0 %d 3 2",line_index);
#else
            sprintf(temp_buf, "0 %d 3 0",line_index); /* line doesn't use CR on any direction */
#endif
         }
         CLI_F_UfeTransferMode(temp_buf);

         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, timing_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */
#endif /* end of WTI_CESOP_CLOCK_RECOVERY_ENABLE*/
#if WTI_CESOP_RX_TIMING_ENABLE
         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, timing_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
#endif

      }
   }


   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 3");

   CLI_F_UfeChipInitLineSetup("");

   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }
#endif

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   pw_index=0;

   for (i=0; i<12; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;

         for (k=0; k<8; k++)
         {
            switch(k)
            {
            case 0:
            {
               sprintf(temp_buf, "0 %d 64 64 4 0-3", line_index);
               break;
            }
            case 1:
            {
               sprintf(temp_buf, "0 %d 64 64 4 4-7", line_index);
               break;
            }
            case 2:
            {
               sprintf(temp_buf, "0 %d 64 64 4 8-11", line_index);
               break;
            }
            case 3:
            {
               sprintf(temp_buf, "0 %d 64 64 4 12-15", line_index);
               break;
            }
            case 4:
            {
               sprintf(temp_buf, "0 %d 64 64 4 16-19", line_index);
               break;
            }
            case 5:
            {
               sprintf(temp_buf, "0 %d 64 64 4 20-23", line_index);
               break;
            }
            case 6:
            {
               sprintf(temp_buf, "0 %d 64 64 4 24-27", line_index);
               break;
            }
            case 7:
            {
               sprintf(temp_buf, "0 %d 64 64 4 28-31", line_index);
               break;
            }
            }

            CLI_F_PwConfigureFramed(temp_buf);

            /* PWE3 channel configuration */
            CLI_F_Pwe3ChannelJitterBufferSize("0 8");
            CLI_F_Pwe3ChannelRxBufferSize("0 128");
            CLI_F_Pwe3ChannelStatmode("0 1");
            CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3");
            CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27");
            CLI_F_Pwe3ChannelUdpDummyMode("0 1");
            CLI_F_Pwe3ChannelTxUdcas("0 f");

            /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
            CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
            CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
            sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
            CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
            sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
            CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
            CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 0 0");
            CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
            CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
            /* Rx timing is used in differential mode */
            /* first global_active_cr_async_mode related to different CDs */
            if (pw_index < global_active_cr_async_mode)
            {
               sprintf(temp_buf, "0 1 1 %d",pw_index);
            }
            else
            {
               /* In differential mode all other pw (not first ones) uses CD#0 */
               sprintf(temp_buf, "0 1 1 0");
            }

            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
            /* Rx timing is not used */
            sprintf(temp_buf, "0 0 1 %d",pw_index);
            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

            /**************** PSN --> TDM IW *****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
            /* if clock recovery is set -> Tx timing is used */
            if (pw_index < global_active_cr_async_mode)  /* PW 0-7 use CR, all other don't */
               CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
            else
               CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#else
            /* if clock recovery is disable -> Tx timing is not used */
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#endif
            CLI_F_Psn2TdmTxBinWindowThreshold("0 4");
            CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 2");

            /**************** PSN --> TDM Tx binding*****************/
            /* ------------------------------- Create and Enable all PWs  --------------------------------------- */
            /* The First global_active_cr_async_mode PWs use CR, all other don't */

            if (pw_index < global_active_cr_async_mode)
            {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE

#if WTI_CESOP_RX_TIMING_ENABLE
               /* CR master Rx and Tx direction */
               CLI_F_PwCreate("0 0 1 1"); /* CR master */
#else
               /* CR master Tx direction */
               CLI_F_PwCreate("0 0 0 1"); /* CR master */
#endif

#else /* not  WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
               /* CR master Rx  direction only */
               CLI_F_PwCreate("0 0 1 0"); /* CR master */
#endif
#endif
               sprintf(temp_buf, "0 %d 1",pw_index);
            }
            else
            {  /* Not TX CR PW */
#if WTI_CESOP_RX_TIMING_ENABLE
               /* Set all PW IN rx to work in shapping mode */
               CLI_F_PwCreate("0 0 1 0"); /* CR master */
#else
               CLI_F_PwCreate("0 0 0 0");
#endif

               sprintf(temp_buf, "0 %d 0",pw_index);
            }
            CLI_F_PwEnable(temp_buf);

            ++pw_index;
         }

      } /* end for (configure each line) */
   }
}

/********************************************************************************************
 * Description:
 *            The test configures 336 PW's on 336 lines in T1 unframed mode
 *            (required SBI-OC12 synthesis)
 *
 *******************************************************************************************/
void CLI_F_SBI_T1_U_NoCas_336_Line_336_PWS(char *StrPrm)

{
   WP_U32 i, j, line_index, spe_index, pw_index;
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U8   clock_rec_lines[84] = {0}; /* list of master lines */

   /* Set the CR lines (both for RX and TX direction */
#if (WTI_CESOP_RX_TIMING_ENABLE || WTI_CESOP_CLOCK_RECOVERY_ENABLE)
   for (i=0; i< global_active_cr_async_mode; i++)
   {
      clock_rec_lines[i] = 1;         /* Set lines to be CR master */
   }
#endif

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE||WTI_CESOP_RX_TIMING_ENABLE)
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE || WTI_CESOP_RX_TIMING_ENABLE */


   /* UFE line configuration */
   for (i=0; i<12; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 2 3",line_index);
#else
            /* set ufe Tx direction only */
            sprintf(temp_buf, "0 %d 2 1",line_index);
#endif

#else /* Not WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Rx direction only */
            sprintf(temp_buf, "0 %d 2 2",line_index);
#endif

#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */
         }
         else
         {
#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Rx direction only - for all lines */
            sprintf(temp_buf, "0 %d 2 2",line_index);
#else
            sprintf(temp_buf, "0 %d 2 0",line_index); /* line doesn't use CR on any direction */
#endif
         }

         CLI_F_UfeTransferMode(temp_buf);

         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, line_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */
#endif /* end of WTI_CESOP_CLOCK_RECOVERY_ENABLE*/
#if WTI_CESOP_RX_TIMING_ENABLE
         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, line_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
#endif

      }

   }

   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 0");

   CLI_F_UfeChipInitLineSetup("");

   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }
#endif

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif

#endif
   for (i=0; i<12; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_T1_LINES_PER_SPE + j;

         sprintf(temp_buf, "0 %d 24 24", line_index);/* The line index of this PW */
         CLI_F_PwConfigureUnframed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 16");
         CLI_F_Pwe3ChannelRxBufferSize("0 192");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 98 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
         /* Rx timing is used in differential mode */
         /* first global_active_cr_async_mode related to different CDs */
         if (pw_index < global_active_cr_async_mode)
         {
            sprintf(temp_buf, "0 1 1 %d",pw_index);
         }
         else
         {
            /* In differential mode all other pw (not first ones) uses CD#0 */
            sprintf(temp_buf, "0 1 1 0");
         }

         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
         /* Rx timing is not used */
         sprintf(temp_buf, "0 0 1 %d",pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif
         /**************** PSN --> TDM IW *****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* if clock recovery is set -> Tx timing is used */
         if (pw_index < global_active_cr_async_mode)  /* PW 0-7 use CR, all other don't */
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#else
         /* if clock recovery is disable -> Tx timing is not used */
         CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#endif
         CLI_F_Psn2TdmTxBinWindowThreshold("0 8");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 4");

         /**************** PSN --> TDM Tx binding*****************/

         /* ------------------------------- Create and Enable all PWs  --------------------------------------- */
         /* The First global_active_cr_async_mode PWs use CR, all other don't */

         if (pw_index < global_active_cr_async_mode)
         {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE

#if WTI_CESOP_RX_TIMING_ENABLE
            /* CR master Rx and Tx direction */
            CLI_F_PwCreate("0 0 1 1"); /* CR master */
#else
            /* CR master Tx direction */
            CLI_F_PwCreate("0 0 0 1"); /* CR master */
#endif

#else /* not  WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
            /* CR master Rx  direction only */
            CLI_F_PwCreate("0 0 1 0"); /* CR master */
#endif
#endif
            sprintf(temp_buf, "0 %d 1",pw_index);
         }
         else
         {  /* Not TX CR PW */
#if WTI_CESOP_RX_TIMING_ENABLE
            /* Set all PW IN rx to work in shapping mode */
            CLI_F_PwCreate("0 0 1 0"); /* CR master */
#else
            CLI_F_PwCreate("0 0 0 0");
#endif

            sprintf(temp_buf, "0 %d 0",pw_index);
         }
         CLI_F_PwEnable(temp_buf);
      } /* end for (configure each line) */
   }
}

#if WTI_CESOP_TO_MPLS_FA_CASCADING
/********************************************************************************************
 * Description:
 *            The test configures 336 PW's on 336 lines in T1 unframed mode
 *            (required SBI-OC12 synthesis)
 *
 *******************************************************************************************/
void CLI_F_SBI_T1_U_NoCas_336_Line_336_PWS_Cascaded(char *StrPrm)
{
   WP_U32 i, j, line_index, spe_index, pw_index;
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U8   clock_rec_lines[84] = {0}; /* list of master lines */

   /* Set the CR lines (both for RX and TX direction */
#if (WTI_CESOP_RX_TIMING_ENABLE || WTI_CESOP_CLOCK_RECOVERY_ENABLE)
   for (i=0; i< global_active_cr_async_mode; i++)
   {
      clock_rec_lines[i] = 1;         /* Set lines to be CR master */
   }
#endif

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE||WTI_CESOP_RX_TIMING_ENABLE)
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE || WTI_CESOP_RX_TIMING_ENABLE */


   /* UFE line configuration */
   for (i=0; i<12; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 2 3",line_index);
#else
            /* set ufe Tx direction only */
            sprintf(temp_buf, "0 %d 2 1",line_index);
#endif

#else /* Not WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Rx direction only */
            sprintf(temp_buf, "0 %d 2 2",line_index);
#endif

#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */
         }
         else
         {
#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Rx direction only - for all lines */
            sprintf(temp_buf, "0 %d 2 2",line_index);
#else
            sprintf(temp_buf, "0 %d 2 0",line_index); /* line doesn't use CR on any direction */
#endif
         }

         CLI_F_UfeTransferMode(temp_buf);

         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, line_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */
#endif /* end of WTI_CESOP_CLOCK_RECOVERY_ENABLE*/
#if WTI_CESOP_RX_TIMING_ENABLE
         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, line_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
#endif

      }

   }

   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 0");

   CLI_F_UfeChipInitLineSetup("");

   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }
#endif

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif

#endif

   for (i=0;i<WTI_MAX_NUM_OF_MPLS_FA;++i)
   {
#if WTI_CESOP_MPLS_OVER_ENET
      /* create the l2 router MPLS flow aggregations */
      CLI_F_Tdm2PsnFlowAggEnetHeaderMpls("0 aa aa aa aa aa aa bb bb bb bb bb bb 8847");
      CLI_F_MplsFlowAggPrefixLength("0 18");
      sprintf(temp_buf,
              "0 %x %x %x %x %x %x",
              3*i,
              3*i+1,
              3*i+2,
              0x81000005,
              (0x88470000 | ((((WTI_MPLS_LABEL) >> 12) + WTI_MAX_PW + 1 + i) >> 4)),
              ((((((WTI_MPLS_LABEL) >> 12)  + WTI_MAX_PW + 1 + i) & 0xff) << 28) | 0x00ff0000));
      /*                              [mac destination] [mac source] [vlan] [type] [mpls header] */
      CLI_F_MplsFlowAggPrefixHeaderMpls(temp_buf);
      sprintf(temp_buf, "0 %d %d %d", 2, 28, 41); /* remark offsets for VLAN priority and PSN tunnel EXP bits */

      CLI_F_MplsFlowAggRemarkingOffsets(temp_buf);
      sprintf(temp_buf, "0 %d", i);
      CLI_F_MplsFlowAggCreate(temp_buf);
#else
#if WTI_CESOP_NATIVE_MPLS_IW
      /* create the l2 router MPLS flow aggregations */
      CLI_F_MplsFlowAggPrefixLength("0 0");
      sprintf(temp_buf,
              "0 %x",
              (((((WTI_MPLS_LABEL) >> 12) + WTI_MAX_PW + 1 + i) << 12) | 0xff));
      /*                              [mpls header] */
      CLI_F_MplsFlowAggPrefixHeaderMpls(temp_buf);
      sprintf(temp_buf, "0 %d %d", 1, 5); /* remark offsets for PSN tunnel EXP bits */

      CLI_F_MplsFlowAggRemarkingOffsets(temp_buf);
      sprintf(temp_buf, "0 %d", i);
      CLI_F_MplsFlowAggCreate(temp_buf);
#else
      /* create the l2 router MPLS flow aggregations */
      CLI_F_MplsFlowAggPrefixLength("0 4");
      sprintf(temp_buf,
              "0 %x %x",
              WTI_MPLSoPPP,
              (((((WTI_MPLS_LABEL) >> 12) + WTI_MAX_PW + 1 + i) << 12) | 0xff));
      /*                              [ppp] [mpls header] */
      CLI_F_MplsFlowAggPrefixHeaderMpls(temp_buf);
      sprintf(temp_buf, "0 %d %d", 1, 13); /* remark offsets for PSN tunnel EXP bits */

      CLI_F_MplsFlowAggRemarkingOffsets(temp_buf);
      sprintf(temp_buf, "0 %d", i);
      CLI_F_MplsFlowAggCreate(temp_buf);
#endif /* WTI_CESOP_NATIVE_MPLS_IW */
#endif /* WTI_CESOP_MPLS_OVER_ENET */
   }

   for (i=0; i<12; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_T1_LINES_PER_SPE + j;

         sprintf(temp_buf, "0 %d 24 24", line_index);/* The line index of this PW */
         CLI_F_PwConfigureUnframed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 16");
         CLI_F_Pwe3ChannelRxBufferSize("0 192");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 d8 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
         /* Rx timing is used in differential mode */
         /* first global_active_cr_async_mode related to different CDs */
         if (pw_index < global_active_cr_async_mode)
         {
            sprintf(temp_buf, "0 1 1 %d",pw_index);
         }
         else
         {
            /* In differential mode all other pw (not first ones) uses CD#0 */
            sprintf(temp_buf, "0 1 1 0");
         }

         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
         /* Rx timing is not used */
         sprintf(temp_buf, "0 0 1 %d",pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

         sprintf(temp_buf, "0 %d %d %d", 2, (7-(i%7)), (i%7)); /* remark values for VLAN priority and PSN tunnel EXP bits */
         CLI_F_Tdm2PsnFlowAggRemarkingValues(temp_buf);

         /**************** PSN --> TDM IW *****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* if clock recovery is set -> Tx timing is used */
         if (pw_index < global_active_cr_async_mode)  /* PW 0-7 use CR, all other don't */
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#else
         /* if clock recovery is disable -> Tx timing is not used */
         CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#endif
         CLI_F_Psn2TdmTxBinWindowThreshold("0 8");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 4");

         /**************** PSN --> TDM Tx binding*****************/

         /* ------------------------------- Create and Enable all PWs  --------------------------------------- */
         /* The First global_active_cr_async_mode PWs use CR, all other don't */

         if (pw_index < global_active_cr_async_mode)
         {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE

#if WTI_CESOP_RX_TIMING_ENABLE
            /* CR master Rx and Tx direction */
            sprintf(temp_buf, "0 %d %d %d %d %d", 0,1,1,(pw_index%WTI_MAX_NUM_OF_MPLS_FA),pw_index);
            CLI_F_PwCreateCascaded(temp_buf);

#else
            /* CR master Tx direction */
            sprintf(temp_buf, "0 %d %d %d %d %d", 0,0,1,(pw_index%WTI_MAX_NUM_OF_MPLS_FA),pw_index);
            CLI_F_PwCreateCascaded(temp_buf);

#endif

#else /* not  WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
            /* CR master Rx  direction only */
            sprintf(temp_buf, "0 %d %d %d %d %d", 0,1,0,(pw_index%WTI_MAX_NUM_OF_MPLS_FA),pw_index);
            CLI_F_PwCreateCascaded(temp_buf);

#endif
#endif
            sprintf(temp_buf, "0 %d 1",pw_index);
         }
         else
         {  /* Not TX CR PW */
#if WTI_CESOP_RX_TIMING_ENABLE
            sprintf(temp_buf, "0 %d %d %d %d %d", 0,1,0,(pw_index%WTI_MAX_NUM_OF_MPLS_FA),pw_index);
            CLI_F_PwCreateCascaded(temp_buf);

#else
            sprintf(temp_buf, "0 %d %d %d %d %d", 0,0,0,(pw_index%WTI_MAX_NUM_OF_MPLS_FA),pw_index);
            CLI_F_PwCreateCascaded(temp_buf);
#endif

            sprintf(temp_buf, "0 %d 0",pw_index);
         }
         CLI_F_PwEnable(temp_buf);
      } /* end for (configure each line) */
   }
}
#endif /* WTI_CESOP_TO_MPLS_FA_CASCADING */

/********************************************************************************************
 * Description:
 *            The test configures 8064 X (1DS0) PW's on 252 lines in E1 framed mode
 *            (required SBI-OC12 synthesis)
 *
 *******************************************************************************************/
void CLI_F_SBI_E1_F_NoCas_252_Line_8064_1xDS0_PWS(char *StrPrm)
{
   WP_U32 i, j, k, line_index, spe_index, timing_index, pw_index;
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U8   clock_rec_lines[336] = {0}; /* list of master lines */

   /* Set the CR lines (both for RX and TX direction */
#if (WTI_CESOP_RX_TIMING_ENABLE || WTI_CESOP_CLOCK_RECOVERY_ENABLE)
   for (i=0; i< global_active_cr_async_mode; i++)
   {/* Set lines to be CR master */
      clock_rec_lines[CLI_F_AttacheLineToPwNumber(i)] = 1;
   }
#endif

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE||WTI_CESOP_RX_TIMING_ENABLE)
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE || WTI_CESOP_RX_TIMING_ENABLE */

   /* UFE line configuration */
   for (i=0; i<12; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {

         line_index = i*28 + j;
         timing_index = i*WTI_E1_LINES_PER_SPE + j;

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 3 3",line_index);
#else
            /* set ufe Tx direction only */
            sprintf(temp_buf, "0 %d 3 1",line_index);
#endif

#else /* Not WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Rx direction only */
            sprintf(temp_buf, "0 %d 3 2",line_index);
#endif

#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */
         }
         else
         {
#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Rx direction only - for all lines */
            sprintf(temp_buf, "0 %d 3 2",line_index);
#else
            sprintf(temp_buf, "0 %d 3 0",line_index); /* line doesn't use CR on any direction */
#endif
         }

         CLI_F_UfeTransferMode(temp_buf);

         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, timing_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */
#endif /* end of WTI_CESOP_CLOCK_RECOVERY_ENABLE*/
#if WTI_CESOP_RX_TIMING_ENABLE
         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, timing_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
#endif
      }
   }

   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 3");

   CLI_F_UfeChipInitLineSetup("");

   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }
#endif

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   pw_index=0;

   for (i=0; i<12; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;

         for (k=0; k<32; k++)
         {
            sprintf(temp_buf, "0 %d 64 64 1 %d", line_index, k);
            CLI_F_PwConfigureFramed(temp_buf);

            /* PWE3 channel configuration */
            CLI_F_Pwe3ChannelJitterBufferSize("0 4");
            CLI_F_Pwe3ChannelRxBufferSize("0 512");
            CLI_F_Pwe3ChannelStatmode("0 1");
            CLI_F_Pwe3ChannelTxUdpattern("0 0");
            CLI_F_Pwe3ChannelTxDummyUdpattern("0 24");
            CLI_F_Pwe3ChannelUdpDummyMode("0 1");
            CLI_F_Pwe3ChannelTxUdcas("0 f");

            /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
            CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
            CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
            sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
            CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
            sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
            CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
            CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 218 0");
            CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
            CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
            /* Rx timing is used in differential mode */
            /* first global_active_cr_async_mode related to different CDs */
            if (pw_index < global_active_cr_async_mode)
            {
               sprintf(temp_buf, "0 1 1 %d",pw_index);
            }
            else
            {
               /* In differential mode all other pw (not first ones) uses CD#0 */
               sprintf(temp_buf, "0 1 1 0");
            }

            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
            /* Rx timing is not used */
            sprintf(temp_buf, "0 0 1 %d",pw_index);
            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

            /**************** PSN --> TDM IW *****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
            /* if clock recovery is set -> Tx timing is used */
            if (pw_index < global_active_cr_async_mode)  /* PW 0-7 use CR, all other don't */
               CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
            else
               CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#else
            /* if clock recovery is disable -> Tx timing is not used */
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#endif
            CLI_F_Psn2TdmTxBinWindowThreshold("0 2");
            CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 1");

            /**************** PSN --> TDM Tx binding*****************/
            /* ------------------------------- Create and Enable all PWs  --------------------------------------- */
            /* The First global_active_cr_async_mode PWs use CR, all other don't */

            if (pw_index < global_active_cr_async_mode)
            {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE

#if WTI_CESOP_RX_TIMING_ENABLE
               /* CR master Rx and Tx direction */
               CLI_F_PwCreate("0 0 1 1"); /* CR master */
#else
               /* CR master Tx direction */
               CLI_F_PwCreate("0 0 0 1"); /* CR master */
#endif

#else /* not  WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
               /* CR master Rx  direction only */
               CLI_F_PwCreate("0 0 1 0"); /* CR master */
#endif
#endif
               sprintf(temp_buf, "0 %d 1",pw_index);
            }
            else
            {  /* Not TX CR PW */
#if WTI_CESOP_RX_TIMING_ENABLE
               /* Set all PW IN rx to work in shapping mode */
               CLI_F_PwCreate("0 0 1 0"); /* CR master */
#else
               CLI_F_PwCreate("0 0 0 0");
#endif

               sprintf(temp_buf, "0 %d 0",pw_index);
            }
            CLI_F_PwEnable(temp_buf);

            ++pw_index;
         }
      } /* end for (configure each line) */
   }
}

#endif /* #if (!WTI_CESOP_TDI) - #if is after CLI_F_E1Framed256DS0CasFrgOctal (line 6142) */

/*-----------------------------------------------------------------------------------------------*/
/*-----------------------------  Clock recovery tests section 1 ---------------------------------*/
/* All following Clock Recovery TDI tests can work with RX,TX,BOTH,NON Timing options            */
/*-----------------------------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------------------------*/

#if (WTI_CESOP_TDI)
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/

void CLI_F_301_TDI_E1_U_CR_NoCas_Two_Boards_N_Line_N_PW(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to E1 UNFRAMED no CAS */
   for (i=0;i<WTI_ACTIVE_TDI_PORTS ;i++)
   {
      sprintf(temp_buf, "0 %d 1",i);

      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<WTI_ACTIVE_TDI_PORTS; i++)
   {
      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      /* Overwrite defult paramters if needed */
#if WTI_CLOCK_REC_MODE && WTI_CESOP_DIFF_DOCSIS_MODE
      /* Set DCR-DOCSIS operation mode */
      the_system->clock_rec[i].operation_mode = WP_IW_CLOCK_REC_DOCSIS;
      /* DOCSIS E1-1061 T1-800 */
      the_system->clock_rec[i].ts_clock_divider = WP_CLOCK_REC_TS_CLOCK_DIV_DOCSIS_E1;
#endif  /* WTI_CLOCK_REC_MODE && WTI_CESOP_DIFF_DOCSIS_MODE */
   }
#endif  /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */

   for (i=0;i<WTI_ACTIVE_TDI_PORTS ;i++)
   {
      sprintf(temp_buf, "0 %d 1",i);/* T1 :0 , E1 :1 */
      CLI_F_PwConfigureUnframedTdi(temp_buf);/* T1 :0 , E1 :1 */
      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 256");
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/
#ifdef WTI_BOARD_1
      CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 08 74 AC 53 1E 00 00 00 00 00 00 0800");
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
      CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 50 FC E2 0A D9 00 00 00 00 00 00 0800");
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE
      /* Rx timing is used */
      sprintf(temp_buf, "0 1 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
#else
      /* Rx timing is not used */
      sprintf(temp_buf, "0 0 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
#endif

      /**************** PSN --> TDM Tx binding*****************/

      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");




#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* create clock by using the ufe*/
      /*write the HW clock recovery registers */
#if WTI_CLOCK_REC_MODE
      /* initial the clock counters thresholds for TDI diff mode */
      /* Init Timestamp  HW in FPGA 0 - E1 1- T1, line index  */
      /* (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM) , line index */
      sprintf(temp_buf, "0 4 %x",i);

#ifdef WP_HW_WINPATH2
      CLI_F_TdiCrTSInt(temp_buf);
#endif  /* WP_HW_WINPATH2 */
#endif

      CLI_F_PwCreate("0 0 0 1");
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_PwEnable(temp_buf);
#else /* Not WTI_CESOP_CLOCK_RECOVERY_ENABLE */

      CLI_F_PwCreate("0 0 0 0");
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_PwEnable(temp_buf);
#endif
   }

}
#endif /*(WTI_CESOP_TDI)*/


#if (WTI_CESOP_TDI)
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/

void CLI_F_301_TDI_T1_U_CR_NoCas_Two_Boards_N_Line_N_PW(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* init all active TDM interfaces to the default configuration:
      T1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to T1 UNFRAMED no CAS */
   for (i=0;i<WTI_ACTIVE_TDI_PORTS ;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);/* T1 :0 , E1 :1 */
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();


#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<WTI_ACTIVE_TDI_PORTS; i++)
   {
      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      /* Overwrite defult paramters if needed */
#if WTI_CLOCK_REC_MODE && WTI_CESOP_DIFF_DOCSIS_MODE
      /* Set DCR-DOCSIS operation mode */
      the_system->clock_rec[i].operation_mode = WP_IW_CLOCK_REC_DOCSIS;
      /* DOCSIS E1-1061 T1-800 */
      the_system->clock_rec[i].ts_clock_divider = WP_CLOCK_REC_TS_CLOCK_DIV_DOCSIS_T1;
#endif  /* WTI_CLOCK_REC_MODE && WTI_CESOP_DIFF_DOCSIS_MODE */
   }
#endif  /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */

   for (i=0;i<WTI_ACTIVE_TDI_PORTS ;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);/* T1 :0 , E1 :1 */
      CLI_F_PwConfigureUnframedTdi(temp_buf);/* T1 :0 , E1 :1 */

      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 192"); /*in tdi unframed RxBufferSize must be N*32 */
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/
#ifdef WTI_BOARD_1
      CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 08 74 AC 53 1E 00 00 00 00 00 00 0800");
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
      CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 50 FC E2 0A D9 00 00 00 00 00 00 0800");
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE
      /* Rx timing is used */
      sprintf(temp_buf, "0 1 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
#else
      /* Rx timing is not used */
      sprintf(temp_buf, "0 0 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
#endif

      /**************** PSN --> TDM Tx binding*****************/

      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* create clock by using the ufe*/

#if WTI_CLOCK_REC_MODE
      /* initial the clock counters thresholds for TDI diff mode */
      /* Init Timestamp  HW in FPGA 0 - E1 1- T1, line index  */
      /* (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM) , line index */
      sprintf(temp_buf, "0 2 %x",i);

#ifdef WP_HW_WINPATH2
      CLI_F_TdiCrTSInt(temp_buf);
#endif  /* WP_HW_WINPATH2 */
#endif

      CLI_F_PwCreate("0 0 0 1");
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_PwEnable(temp_buf);
#else
      CLI_F_PwCreate("0 0 0 0");
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_PwEnable(temp_buf);
#endif
   }

}
#endif /*(WTI_CESOP_TDI)*/

#if (WTI_CESOP_TDI)
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/

void CLI_F_301_TDI_E1_F_CR_NoCas_Two_Boards_N_Line_N_PW(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to E1 UNFRAMED no CAS */
   for (i=0;i<WTI_ACTIVE_TDI_PORTS ;i++)
   {
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<WTI_ACTIVE_TDI_PORTS; i++)
   {
      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      /* Overwrite defult paramters if needed */
#if WTI_CLOCK_REC_MODE && WTI_CESOP_DIFF_DOCSIS_MODE
      /* Set DCR-DOCSIS operation mode */
      the_system->clock_rec[i].operation_mode = WP_IW_CLOCK_REC_DOCSIS;
      /* DOCSIS E1-1061 T1-800 */
      the_system->clock_rec[i].ts_clock_divider = WP_CLOCK_REC_TS_CLOCK_DIV_DOCSIS_E1;
#endif  /* WTI_CLOCK_REC_MODE && WTI_CESOP_DIFF_DOCSIS_MODE */
   }
#endif  /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */

   for (i=0;i<WTI_ACTIVE_TDI_PORTS ;i++)
   {
      sprintf(temp_buf, "0 %d 1 32 0-31",i);
      CLI_F_PwConfigureFramedTdi(temp_buf);
      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 256");
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/
#ifdef WTI_BOARD_1
      CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 08 74 AC 53 1E 00 00 00 00 00 00 0800");
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
      CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 50 FC E2 0A D9 00 00 00 00 00 00 0800");
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE
      /* Rx timing is used */
      sprintf(temp_buf, "0 1 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
#else
      /* Rx timing is not used */
      sprintf(temp_buf, "0 0 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
#endif

      /**************** PSN --> TDM Tx binding*****************/

      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* create clock by using the ufe*/
#if WTI_CLOCK_REC_MODE
      /* initial the clock counters thresholds for TDI diff mode */
      /* Init Timestamp  HW in FPGA 0 - E1 1- T1, line index  */
      /* (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM) , line index */
      sprintf(temp_buf, "0 3 %x",i);

#ifdef WP_HW_WINPATH2
      CLI_F_TdiCrTSInt(temp_buf);
#endif  /* WP_HW_WINPATH2 */
#endif

      CLI_F_PwCreate("0 0 0 1");
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_PwEnable(temp_buf);
#else
      CLI_F_PwCreate("0 0 0 0");
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_PwEnable(temp_buf);
#endif
   }

}

#endif /*(WTI_CESOP_TDI)*/

#if (WTI_CESOP_TDI)
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/

void CLI_F_301_TDI_T1_F_CR_NoCas_Two_Boards_N_Line_N_PW(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* init all active TDM interfaces to the default configuration:
      T1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to T1 UNFRAMED no CAS */
   for (i=0;i<WTI_ACTIVE_TDI_PORTS ;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);/* T1 :0 , E1 :1 */
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i); /* Fr :1 , Unfr :0 */
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<WTI_ACTIVE_TDI_PORTS; i++)
   {
      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      /* Overwrite defult paramters if needed */
#if WTI_CLOCK_REC_MODE && WTI_CESOP_DIFF_DOCSIS_MODE
      /* Set DCR-DOCSIS operation mode */
      the_system->clock_rec[i].operation_mode = WP_IW_CLOCK_REC_DOCSIS;
      /* DOCSIS E1-1061 T1-800 */
      the_system->clock_rec[i].ts_clock_divider = WP_CLOCK_REC_TS_CLOCK_DIV_DOCSIS_T1;
#endif  /* WTI_CLOCK_REC_MODE && WTI_CESOP_DIFF_DOCSIS_MODE */
   }
#endif  /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */

   for (i=0;i<WTI_ACTIVE_TDI_PORTS ;i++)
   {
      sprintf(temp_buf, "0 %d 0 24 0-23",i);
      CLI_F_PwConfigureFramedTdi(temp_buf);
      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 192");
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/
#ifdef WTI_BOARD_1
      CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 08 74 AC 53 1E 00 00 00 00 00 00 0800");
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
      CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 50 FC E2 0A D9 00 00 00 00 00 00 0800");
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 d8 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE
      /* Rx timing is used */
      sprintf(temp_buf, "0 1 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
#else
      /* Rx timing is not used */
      sprintf(temp_buf, "0 0 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
#endif

      /**************** PSN --> TDM Tx binding*****************/

      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* create clock by using the ufe*/

#if WTI_CLOCK_REC_MODE
      /* initial the clock counters thresholds for TDI diff mode */
      /* Init Timestamp  HW in FPGA 0 - E1 1- T1, line index  */
      /* (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM) , line index */
      sprintf(temp_buf, "0 1 %x",i);
#ifdef WP_HW_WINPATH2
      CLI_F_TdiCrTSInt(temp_buf);
#endif  /* WP_HW_WINPATH2 */
#endif

      CLI_F_PwCreate("0 0 0 1");
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_PwEnable(temp_buf);
#else /*WTI_CESOP_CLOCK_RECOVERY_ENABLE*/
      CLI_F_PwCreate("0 0 0 0");
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_PwEnable(temp_buf);
#endif
   }

}
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_302_TDI_E1_U_CR_NoCas_Two_Boards_1_Line_1_PW_for_Specific_TDM_Port(char *StrPrm)
{

   int line_number = 7;
   int pw_index = 0;
   int cr_index = 0;
   int ts_index = 0;

   /* Set the CR and TS index as the line index (1:1 mapping) */
   cr_index = line_number;
   ts_index = line_number;

   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to E1 UNFRAMED no CAS */
   sprintf(temp_buf, "0 %d 1",line_number);
   CLI_F_TdiOperationMode(temp_buf);
   sprintf(temp_buf, "0 %d 0",line_number);
   CLI_F_TdiFramingMode(temp_buf);
   sprintf(temp_buf, "0 %d 0",line_number);
   CLI_F_TdiCasMode(temp_buf);

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   /* Set the defult PSN2TDM clock recoevry paramters */
   WTI_ClockRecoveryPSN2TDMDefultParamesConfig(line_number);
   /* Overwrite defult paramters if needed */

   the_system->clock_rec[line_number].clock_rec_if_id = cr_index;

#if WTI_CLOCK_REC_MODE && WTI_CESOP_DIFF_DOCSIS_MODE
   /* Set DCR-DOCSIS operation mode */
   the_system->clock_rec[line_number].operation_mode = WP_IW_CLOCK_REC_DOCSIS;
   /* DOCSIS E1-1061 T1-800 */
   the_system->clock_rec[line_number].ts_clock_divider = WP_CLOCK_REC_TS_CLOCK_DIV_DOCSIS_E1;
#endif  /* WTI_CLOCK_REC_MODE && WTI_CESOP_DIFF_DOCSIS_MODE */
#endif  /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */


   sprintf(temp_buf, "0 %d 1",line_number);/* T1 :0 , E1 :1 */
   CLI_F_PwConfigureUnframedTdi(temp_buf);/* T1 :0 , E1 :1 */
   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 256");
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/
#ifdef WTI_BOARD_1
   CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 08 74 AC 53 1E 00 00 00 00 00 00 0800");
   sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
   CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
   CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 50 FC E2 0A D9 00 00 00 00 00 00 0800");
   sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
   CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
   CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE
   /* Rx timing is used */
   sprintf(temp_buf, "0 1 1 %d",ts_index);
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
#else
   /* Rx timing is not used */
   sprintf(temp_buf, "0 0 1 %d",ts_index);
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
#endif

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* create clock by using the ufe*/

#if WTI_CLOCK_REC_MODE
   /* initial the clock counters thresholds for TDI diff mode */
   /* Init Timestamp  HW in FPGA 0 - E1 1- T1, line index  */
   /* (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM) , line index */
   sprintf(temp_buf, "0 4 %x",ts_index);
#ifdef WP_HW_WINPATH2
   CLI_F_TdiCrTSInt(temp_buf);
#endif  /* WP_HW_WINPATH2 */
#endif

   printf("Test run on line_number %d\n", line_number);
   sprintf(temp_buf, "0 0 0 1 %d",pw_index);
   CLI_F_PwCreate(temp_buf);
   sprintf(temp_buf, "0 %d 1",pw_index);
   CLI_F_PwEnable(temp_buf);
#else
   CLI_F_PwCreate("0 0 0 0");
   sprintf(temp_buf, "0 %d 0",pw_index);
   CLI_F_PwEnable(temp_buf);
#endif
   the_system->pw[pw_index].line_index = line_number;
}
#endif /*(WTI_CESOP_TDI)*/

#if (WTI_CESOP_TDI)
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_303_TDI_E1_F_CR_NoCas_Two_Boards_N_Line_N_PW_1DS0(char *StrPrm)
{
   WP_U32 i, ds0_num = 2;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to E1 UNFRAMED no CAS */
   for (i=0;i<WTI_ACTIVE_TDI_PORTS ;i++)
   {
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();


#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<WTI_ACTIVE_TDI_PORTS; i++)
   {
      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      /* Overwrite defult paramters if needed */
#if WTI_CLOCK_REC_MODE && WTI_CESOP_DIFF_DOCSIS_MODE
      /* Set DCR-DOCSIS operation mode */
      the_system->clock_rec[i].operation_mode = WP_IW_CLOCK_REC_DOCSIS;
      /* DOCSIS E1-1061 T1-800 */
      the_system->clock_rec[i].ts_clock_divider = WP_CLOCK_REC_TS_CLOCK_DIV_DOCSIS_E1;
#endif  /* WTI_CLOCK_REC_MODE && WTI_CESOP_DIFF_DOCSIS_MODE */
   }
#endif  /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */

   printf(" The DS0 used in the test is %d \n", ds0_num);

   for (i=0;i<WTI_ACTIVE_TDI_PORTS ;i++)
   {
      sprintf(temp_buf, "0 %d 1 1 %d",i,ds0_num); /* The number of slots of this channel and there location*/
      CLI_F_PwConfigureFramedTdi(temp_buf);
      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 40");/*The size of the packet in bytes*/
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 31");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 55");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/
#ifdef WTI_BOARD_1
      CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 08 74 AC 53 1E 00 00 00 00 00 00 0800");
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
      CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 50 FC E2 0A D9 00 00 00 00 00 00 0800");
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 40 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE
      /* Rx timing is used */
      sprintf(temp_buf, "0 1 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
#else
      /* Rx timing is not used */
      sprintf(temp_buf, "0 0 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
#endif

      /**************** PSN --> TDM Tx binding*****************/

      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* create clock by using the ufe*/
#if WTI_CLOCK_REC_MODE
      /* initial the clock counters thresholds for TDI diff mode */
      /* Init Timestamp  HW in FPGA 0 - E1 1- T1, line index  */
      /* (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM) , line index */
      sprintf(temp_buf, "0 3 %x",i);
#ifdef WP_HW_WINPATH2
      CLI_F_TdiCrTSInt(temp_buf);
#endif  /* WP_HW_WINPATH2 */
#endif

      CLI_F_PwCreate("0 0 0 1");
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_PwEnable(temp_buf);
#else
      CLI_F_PwCreate("0 0 0 0");
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_PwEnable(temp_buf);
#endif
   }

}

#endif /*(WTI_CESOP_TDI)*/

#if (WTI_CESOP_TDI)
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/

void CLI_F_303_TDI_T1_F_CR_NoCas_Two_Boards_N_Line_N_PW_1DS0(char *StrPrm)
{
   WP_U32 i,ds0_num = 22;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* init all active TDM interfaces to the default configuration:
      T1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to T1 UNFRAMED no CAS */
   for (i=0;i<WTI_ACTIVE_TDI_PORTS ;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);/* T1 :0 , E1 :1 */
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i); /* Fr :1 , Unfr :0 */
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<WTI_ACTIVE_TDI_PORTS; i++)
   {
      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      /* Overwrite defult paramters if needed */
#if WTI_CLOCK_REC_MODE && WTI_CESOP_DIFF_DOCSIS_MODE
      /* Set DCR-DOCSIS operation mode */
      the_system->clock_rec[i].operation_mode = WP_IW_CLOCK_REC_DOCSIS;
      /* DOCSIS E1-1061 T1-800 */
      the_system->clock_rec[i].ts_clock_divider = WP_CLOCK_REC_TS_CLOCK_DIV_DOCSIS_T1;
#endif  /* WTI_CLOCK_REC_MODE && WTI_CESOP_DIFF_DOCSIS_MODE */
   }
#endif  /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */

   printf(" The DS0 used in the test is %d \n", ds0_num);

   for (i=0;i<WTI_ACTIVE_TDI_PORTS ;i++)
   {
      sprintf(temp_buf, "0 %d 0 1 %d",i,ds0_num);/* The number of slots of this channel and there location*/
      CLI_F_PwConfigureFramedTdi(temp_buf);
      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 40"); /*The size of the packet in bytes*/
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 31");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 47");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/
#ifdef WTI_BOARD_1
      CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 08 74 AC 53 1E 00 00 00 00 00 00 0800");
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
      CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 50 FC E2 0A D9 00 00 00 00 00 00 0800");
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 40 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE
      /* Rx timing is used */
      sprintf(temp_buf, "0 1 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
#else
      /* Rx timing is not used */
      sprintf(temp_buf, "0 0 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
#endif

      /**************** PSN --> TDM Tx binding*****************/

      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* create clock by using the ufe*/

#if WTI_CLOCK_REC_MODE
      /* initial the clock counters thresholds for TDI diff mode */
      /* Init Timestamp  HW in FPGA 0 - E1 1- T1, line index  */
      /* (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM) , line index */
      sprintf(temp_buf, "0 1 %x",i);
#ifdef WP_HW_WINPATH2
      CLI_F_TdiCrTSInt(temp_buf);
#endif  /* WP_HW_WINPATH2 */
#endif


      CLI_F_PwCreate("0 0 0 1");
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_PwEnable(temp_buf);
#else /*WTI_CESOP_CLOCK_RECOVERY_ENABLE*/
      CLI_F_PwCreate("0 0 0 0");
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_PwEnable(temp_buf);
#endif
   }

}
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_304_TDI_E1_U_CR_NoCas_Two_Boards_N_Line_N_PW_Remove_Device_Recreate_Without_CR(char *StrPrm)
{
   WP_status status;
   WP_U32 i, pw_index, line_index,iterations, result;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   int Active_Rx_Timing_Enable=0, Active_Clock_Recovery_Enable=0;

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to E1 UNFRAMED no CAS */
   for (i=0;i<WTI_ACTIVE_TDI_PORTS ;i++)
   {
      sprintf(temp_buf, "0 %d 1",i);

      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<WTI_ACTIVE_TDI_PORTS; i++)
   {
      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      /* Overwrite defult paramters if needed */
#if WTI_CLOCK_REC_MODE && WTI_CESOP_DIFF_DOCSIS_MODE
      /* Set DCR-DOCSIS operation mode */
      the_system->clock_rec[i].operation_mode = WP_IW_CLOCK_REC_DOCSIS;
      /* DOCSIS E1-1061 T1-800 */
      the_system->clock_rec[i].ts_clock_divider = WP_CLOCK_REC_TS_CLOCK_DIV_DOCSIS_E1;
#endif  /* WTI_CLOCK_REC_MODE && WTI_CESOP_DIFF_DOCSIS_MODE */
   }
#endif  /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */

   for (i=0;i<WTI_ACTIVE_TDI_PORTS ;i++)
   {
      sprintf(temp_buf, "0 %d 1",i);/* T1 :0 , E1 :1 */
      CLI_F_PwConfigureUnframedTdi(temp_buf);/* T1 :0 , E1 :1 */
      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 256");
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/
#ifdef WTI_BOARD_1
      CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 08 74 AC 53 1E 00 00 00 00 00 00 0800");
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
      CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 50 FC E2 0A D9 00 00 00 00 00 00 0800");
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE
      /* Rx timing is used */
      sprintf(temp_buf, "0 1 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
#else
      /* Rx timing is not used */
      sprintf(temp_buf, "0 0 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
#endif

      /**************** PSN --> TDM Tx binding*****************/

      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* create clock by using the ufe*/
      /*write the HW clock recovery registers */
#if WTI_CLOCK_REC_MODE
      /* initial the clock counters thresholds for TDI diff mode */
      /* Init Timestamp  HW in FPGA 0 - E1 1- T1, line index  */
      /* (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM) , line index */
      sprintf(temp_buf, "0 4 %x",i);
#ifdef WP_HW_WINPATH2
      CLI_F_TdiCrTSInt(temp_buf);
#endif  /* WP_HW_WINPATH2 */
#endif

      CLI_F_PwCreate("0 0 0 1");
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_PwEnable(temp_buf);
#else /* Not WTI_CESOP_CLOCK_RECOVERY_ENABLE */
      CLI_F_PwCreate("0 0 0 0");
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_PwEnable(temp_buf);
#endif
   }

   printf("Waiting a minute to let the traffic flow\n");
   WP_Delay(60*1000*1000);

   result = CLI_F_GlobalStatisticsCheck("0");
   if (result == WT_FAIL)
   {
      /* retry */
      WP_Delay(60 * 1000000);
      result = CLI_F_GlobalStatisticsCheck("0");
      if (result == WT_FAIL)
      {
         WTI_PRINT_ERROR(("\n Test Failed before remove PW/lines.\n"));
         return;
      }
   }

   for (iterations=1; iterations<WTI_ITERATIONS_NUM+1; iterations++)
   {
      printf("################ start of iteration %d   ###############\n", iterations);
      WP_U32 start_pw = 0;
      WP_U32 end_pw   = WTI_ACTIVE_TDI_PORTS;
#ifdef WP_HW_WINPATH2
#if WTI_CLOCK_REC_MODE
#if WTI_CLOCK_REC_TDI_LINES_4_7
      start_pw = 4;
      end_pw   = 8;
#else
      start_pw = 0;
      end_pw   = 4;
#endif
#endif
#endif

      /*remove pw*/
      for (i=end_pw; i>start_pw; i--)
      {
         pw_index = i-1;
         sprintf(temp_buf, "0 %d", pw_index);
         printf("removing PW %d...\n", pw_index);
         CLI_F_PwRemove(temp_buf);
      }
      /*remove device*/
      for (i=end_pw; i>start_pw; i--)
      {
         line_index = i-1;
         printf("remove device (include clear the DCO registers %d\n", line_index);
         WTI_TdiTransDeviceDelete(line_index);
      }

      WP_Delay(60000);

      /*disable CR - recreate as non-CR at all.*/
#if WTI_CESOP_RX_TIMING_ENABLE
#undef WTI_CESOP_RX_TIMING_ENABLE
#define WTI_CESOP_RX_TIMING_ENABLE 1
      Active_Rx_Timing_Enable = 1;
#endif                         /* don't forget the CPLD and val (in DeviceModify) !!!!!!! */
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
#undef WTI_CESOP_CLOCK_RECOVERY_ENABLE
#define WTI_CESOP_CLOCK_RECOVERY_ENABLE 1
      Active_Clock_Recovery_Enable = 1;
#endif

      /*change COMET configuration from CR to non-CR*/
      status = WPU_TdmCometCardInit(WP_PORT_TDM1, WPU_INIT_COMET_CPLD_CR_E1);/*CR_E1*/
      WTI_TerminateOnError(status, "WPU_TdmCometCardInit()", __LINE__);
      if (WTI_ACTIVE_TDI_PORTS > 8)
      {
         status = WPU_TdmCometCardInit(WP_PORT_TDM9, WPU_INIT_COMET_CPLD_CR_E1);
         WTI_TerminateOnError(status, "WPU_TdmCometCardInit()", __LINE__);
      }

      /*recreate lines*/
      for (i=start_pw; i<end_pw; ++i)
      {
         /* create transparent CES device over TDM port */
         WTI_TdiTransDeviceCreate(i);
         /* modify device to work without CR */

         /* tdm_index, cmd [1-TRANS_CES_CLOCK_REC], val [enable/disable] */
         sprintf(temp_buf, "0 %d 1 1", i);
         CLI_F_TdiTransDeviceModify(temp_buf);
         /* enable transparent device */
         status = WP_DeviceEnable(the_system->tdm_trans_dev[i], WP_DIRECTION_DUPLEX);
         WTI_TerminateOnError(status , "WP_DeviceEnable() trans device",__LINE__);
      }

      /*recreate all PW*/
      for (i=start_pw; i<end_pw; i++)
      {
         printf("recreate PW %d\n", i);

         sprintf(temp_buf, "0 %d 1",i);/* T1 :0 , E1 :1 */
         CLI_F_PwConfigureUnframedTdi(temp_buf);/* T1 :0 , E1 :1 */
         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 256");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/
#ifdef WTI_BOARD_1
         CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 08 74 AC 53 1E 00 00 00 00 00 00 0800");
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 50 FC E2 0A D9 00 00 00 00 00 00 0800");
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

         if (Active_Rx_Timing_Enable)
         {

            /* Rx timing is used */
            sprintf(temp_buf, "0 1 1 %d",i);
            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
         }
         else
         {

            /* Rx timing is not used */
            sprintf(temp_buf, "0 0 1 %d",i);
            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
         }

         /**************** PSN --> TDM Tx binding*****************/

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");
         if (Active_Clock_Recovery_Enable)
         {

            /* create clock by using the ufe*/
            /*write the HW clock recovery registers */
#if WTI_CLOCK_REC_MODE
            /* initial the clock counters thresholds for TDI diff mode */
            /* Init Timestamp  HW in FPGA 0 - E1 1- T1, line index  */
            /* (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM) , line index */
            sprintf(temp_buf, "0 4 %x",i);
#ifdef WP_HW_WINPATH2
            CLI_F_TdiCrTSInt(temp_buf);
#endif  /* WP_HW_WINPATH2 */
#endif

            sprintf(temp_buf, "0 0 0 1 %d", i);
            CLI_F_PwCreate(temp_buf);
            sprintf(temp_buf, "0 %d 1",i);
            CLI_F_PwEnable(temp_buf);
         }
         else
         {

            sprintf(temp_buf, "0 0 0 0 %d", i);
            CLI_F_PwCreate(temp_buf);
            sprintf(temp_buf, "0 %d 0",i);
            CLI_F_PwEnable(temp_buf);
         }

      }

      printf("Wait few seconds to let the system become stable...\n");
      WP_Delay(DELAY_DURATION_IN_SECONDS * 1000*1000);
      /* Global statistics check, including reset. */
      result = CLI_F_GlobalStatisticsCheck("0");
      if (result == WT_FAIL)
      {
         WTI_PRINT_ERROR(("\n Test Failed. Iteration number: %d\n", iterations));
         return;
      }
      printf(">>>>>>>>>>>>>>>> end of iteration %d   <<<<<<<<<<<<<<<\n", iterations);

   }
}

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_304_TDI_T1_U_CR_NoCas_Two_Boards_N_Line_N_PW_Remove_Device_Recreate_Without_CR(char *StrPrm)
{
   WP_status status;
   WP_U32 i, pw_index, line_index,iterations, result;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   int Active_Rx_Timing_Enable=0, Active_Clock_Recovery_Enable=0;

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* init all active TDM interfaces to the default configuration:
      T1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to T1 UNFRAMED no CAS */
   for (i=0;i<WTI_ACTIVE_TDI_PORTS ;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);/* T1 :0 , E1 :1 */
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<WTI_ACTIVE_TDI_PORTS; i++)
   {
      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      /* Overwrite defult paramters if needed */
#if WTI_CLOCK_REC_MODE && WTI_CESOP_DIFF_DOCSIS_MODE
      /* Set DCR-DOCSIS operation mode */
      the_system->clock_rec[i].operation_mode = WP_IW_CLOCK_REC_DOCSIS;
      /* DOCSIS E1-1061 T1-800 */
      the_system->clock_rec[i].ts_clock_divider = WP_CLOCK_REC_TS_CLOCK_DIV_DOCSIS_T1;
#endif  /* WTI_CLOCK_REC_MODE && WTI_CESOP_DIFF_DOCSIS_MODE */
   }
#endif  /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */

   for (i=0;i<WTI_ACTIVE_TDI_PORTS ;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);/* T1 :0 , E1 :1 */
      CLI_F_PwConfigureUnframedTdi(temp_buf);/* T1 :0 , E1 :1 */

      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 256"); /*in tdi unframed RxBufferSize must be N*32 */
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/
#ifdef WTI_BOARD_1
      CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 08 74 AC 53 1E 00 00 00 00 00 00 0800");
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
      CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 50 FC E2 0A D9 00 00 00 00 00 00 0800");
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE
      /* Rx timing is used */
      sprintf(temp_buf, "0 1 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
#else
      /* Rx timing is not used */
      sprintf(temp_buf, "0 0 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
#endif

      /**************** PSN --> TDM Tx binding*****************/

      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* create clock by using the ufe*/

#if WTI_CLOCK_REC_MODE
      /* initial the clock counters thresholds for TDI diff mode */
      /* Init Timestamp  HW in FPGA 0 - E1 1- T1, line index  */
      /* (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM) , line index */
      sprintf(temp_buf, "0 2 %x",i);
#ifdef WP_HW_WINPATH2
      CLI_F_TdiCrTSInt(temp_buf);
#endif  /* WP_HW_WINPATH2 */
#endif

      CLI_F_PwCreate("0 0 0 1");
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_PwEnable(temp_buf);
#else
      CLI_F_PwCreate("0 0 0 0");
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_PwEnable(temp_buf);
#endif
   }

   printf("Waiting a minute to let the traffic flow\n");
   WP_Delay(60*1000*1000);

   result = CLI_F_GlobalStatisticsCheck("0");
   if (result == WT_FAIL)
   {
      /* retry */
      WP_Delay(60 * 1000000);
      result = CLI_F_GlobalStatisticsCheck("0");
      if (result == WT_FAIL)
      {
         WTI_PRINT_ERROR(("\n Test Failed before remove PW/lines.\n"));
         return;
      }
   }

   for (iterations=1; iterations<WTI_ITERATIONS_NUM+1; iterations++)
   {
      printf("################ start of iteration %d   ###############\n", iterations);
      /*remove pw*/
      for (i=WTI_ACTIVE_TDI_PORTS; i>0; i--)
      {
         pw_index = i-1;
         sprintf(temp_buf, "0 %d", pw_index);
         CLI_F_PwRemove(temp_buf);
      }
      /*remove device*/
      for (i=WTI_ACTIVE_TDI_PORTS; i>0; i--)
      {
         line_index = i-1;
         printf("remove device (include clear the DCO registers %d\n", line_index);
         WTI_TdiTransDeviceDelete(line_index);
      }

      WP_Delay(60000);

      /*disable CR - recreate as non-CR at all.*/
#if WTI_CESOP_RX_TIMING_ENABLE
#undef WTI_CESOP_RX_TIMING_ENABLE
#define WTI_CESOP_RX_TIMING_ENABLE 1
      Active_Rx_Timing_Enable = 1;
#endif                              /* don't forget the CPLD and val (in DeviceModify) !!!!!!! */
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
#undef WTI_CESOP_CLOCK_RECOVERY_ENABLE
#define WTI_CESOP_CLOCK_RECOVERY_ENABLE 1
      Active_Clock_Recovery_Enable = 1;
#endif

      /*change COMET configuration from CR to non-CR*/
      status = WPU_TdmCometCardInit(WP_PORT_TDM1, WPU_INIT_COMET_CPLD_CR_T1);/*CR_T1*/
      WTI_TerminateOnError(status, "WPU_TdmCometCardInit()", __LINE__);
      if (WTI_ACTIVE_TDI_PORTS > 8)
      {
         status = WPU_TdmCometCardInit(WP_PORT_TDM9, WPU_INIT_COMET_CPLD_CR_T1);/*CR_T1*/
         WTI_TerminateOnError(status, "WPU_TdmCometCardInit()", __LINE__);
      }
      /*recreate lines*/
      for (i=0;i<WTI_ACTIVE_TDI_PORTS;++i)
      {
         /* create transparent CES device over TDM port */
         WTI_TdiTransDeviceCreate(i);
         /* modify device to work without CR */

         /* tdm_index, cmd [1-TRANS_CES_CLOCK_REC], val [enable/disable] */
         sprintf(temp_buf, "0 %d 1 1", i);
         CLI_F_TdiTransDeviceModify(temp_buf);
         /* enable transparent device */
         status = WP_DeviceEnable(the_system->tdm_trans_dev[i], WP_DIRECTION_DUPLEX);
         WTI_TerminateOnError(status , "WP_DeviceEnable() trans device",__LINE__);
      }

      /*recreate all PW*/
      for (i=0;i<WTI_ACTIVE_TDI_PORTS ;i++)
      {
         printf("recreate PW %d\n", i);

         sprintf(temp_buf, "0 %d 0",i);/* T1 :0 , E1 :1 */
         CLI_F_PwConfigureUnframedTdi(temp_buf);/* T1 :0 , E1 :1 */
         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 256");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/
#ifdef WTI_BOARD_1
         CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 08 74 AC 53 1E 00 00 00 00 00 00 0800");
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 50 FC E2 0A D9 00 00 00 00 00 00 0800");
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

         if (Active_Rx_Timing_Enable)
         {

            /* Rx timing is used */
            sprintf(temp_buf, "0 1 1 %d",i);
            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
         }
         else
         {

            /* Rx timing is not used */
            sprintf(temp_buf, "0 0 1 %d",i);
            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
         }

         /**************** PSN --> TDM Tx binding*****************/

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");
         if (Active_Clock_Recovery_Enable)
         {

            /* create clock by using the ufe*/
            /*write the HW clock recovery registers */
#if WTI_CLOCK_REC_MODE
            /* initial the clock counters thresholds for TDI diff mode */
            /* Init Timestamp  HW in FPGA 0 - E1 1- T1, line index  */
            /* (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM) , line index */
            sprintf(temp_buf, "0 2 %x",i);
#ifdef WP_HW_WINPATH2
            CLI_F_TdiCrTSInt(temp_buf);
#endif  /* WP_HW_WINPATH2 */
#endif

            sprintf(temp_buf, "0 0 0 1 %d", i);
            CLI_F_PwCreate(temp_buf);
            sprintf(temp_buf, "0 %d 1",i);
            CLI_F_PwEnable(temp_buf);
         }
         else
         {

            sprintf(temp_buf, "0 0 0 0 %d", i);
            CLI_F_PwCreate(temp_buf);
            sprintf(temp_buf, "0 %d 0",i);
            CLI_F_PwEnable(temp_buf);
         }

      }

      printf("Wait few seconds to let the system become stable...\n");
      WP_Delay(DELAY_DURATION_IN_SECONDS * 1000*1000);
      /* Global statistics check, including reset. */
      result = CLI_F_GlobalStatisticsCheck("0");
      if (result == WT_FAIL)
      {
         WTI_PRINT_ERROR(("\n Test Failed. Iteration number: %d\n", iterations));
         return;
      }
      printf(">>>>>>>>>>>>>>>> end of iteration %d   <<<<<<<<<<<<<<<\n", iterations);
   }
}

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_304_TDI_E1_F_CR_NoCas_Two_Boards_N_Line_N_PW_Remove_Device_Recreate_Without_CR(char *StrPrm)
{
   WP_status status;
   WP_U32 i, pw_index, line_index,iterations, result;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   int Active_Rx_Timing_Enable=0, Active_Clock_Recovery_Enable=0;

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to E1 UNFRAMED no CAS */
   for (i=0;i<WTI_ACTIVE_TDI_PORTS ;i++)
   {
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<WTI_ACTIVE_TDI_PORTS; i++)
   {
      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      /* Overwrite defult paramters if needed */
#if WTI_CLOCK_REC_MODE && WTI_CESOP_DIFF_DOCSIS_MODE
      /* Set DCR-DOCSIS operation mode */
      the_system->clock_rec[i].operation_mode = WP_IW_CLOCK_REC_DOCSIS;
      /* DOCSIS E1-1061 T1-800 */
      the_system->clock_rec[i].ts_clock_divider = WP_CLOCK_REC_TS_CLOCK_DIV_DOCSIS_E1;
#endif  /* WTI_CLOCK_REC_MODE && WTI_CESOP_DIFF_DOCSIS_MODE */
   }
#endif  /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */

   for (i=0;i<WTI_ACTIVE_TDI_PORTS ;i++)
   {
      sprintf(temp_buf, "0 %d 1 32 0-31",i);
      CLI_F_PwConfigureFramedTdi(temp_buf);
      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 256");
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/
#ifdef WTI_BOARD_1
      CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 08 74 AC 53 1E 00 00 00 00 00 00 0800");
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
      CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 50 FC E2 0A D9 00 00 00 00 00 00 0800");
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE
      /* Rx timing is used */
      sprintf(temp_buf, "0 1 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
#else
      /* Rx timing is not used */
      sprintf(temp_buf, "0 0 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
#endif

      /**************** PSN --> TDM Tx binding*****************/

      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* create clock by using the ufe*/
#if WTI_CLOCK_REC_MODE
      /* initial the clock counters thresholds for TDI diff mode */
      /* Init Timestamp  HW in FPGA 0 - E1 1- T1, line index  */
      /* (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM) , line index */
      sprintf(temp_buf, "0 3 %x",i);
#ifdef WP_HW_WINPATH2
      CLI_F_TdiCrTSInt(temp_buf);
#endif  /* WP_HW_WINPATH2 */
#endif

      CLI_F_PwCreate("0 0 0 1");
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_PwEnable(temp_buf);
#else
      CLI_F_PwCreate("0 0 0 0");
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_PwEnable(temp_buf);
#endif
   }

   printf("Waiting %d seconds to let the traffic flow\n", DELAY_DURATION_IN_SECONDS);
   WP_Delay(DELAY_DURATION_IN_SECONDS*1000*1000);

   result = CLI_F_GlobalStatisticsCheck("0");
   if (result == WT_FAIL)
   {
      /* retry */
      WP_Delay(60 * 1000000);
      result = CLI_F_GlobalStatisticsCheck("0");
      if (result == WT_FAIL)
      {
         WTI_PRINT_ERROR(("\n Test Failed before remove PW/lines.\n"));
         return;
      }
   }

   for (iterations=1; iterations<WTI_ITERATIONS_NUM+1; iterations++)
   {
      printf("################ start of iteration %d   ###############\n", iterations);

      /*remove pw*/
      for (i=WTI_ACTIVE_TDI_PORTS; i>0; i--)
      {
         pw_index = i-1;
         sprintf(temp_buf, "0 %d", pw_index);
         printf("removing PW %d...\n", pw_index);
         CLI_F_PwRemove(temp_buf);
         printf("PW %d removed!\n", pw_index);
      }
      /*remove device*/
      for (i=WTI_ACTIVE_TDI_PORTS; i>0; i--)
      {
         line_index = i-1;
         printf("remove device (include clear the DCO registers %d\n", line_index);
         WTI_TdiTransDeviceDelete(line_index);
      }

      WP_Delay(60000);

      /*disable CR - recreate as non-CR at all.*/
#if WTI_CESOP_RX_TIMING_ENABLE
#undef WTI_CESOP_RX_TIMING_ENABLE
#define WTI_CESOP_RX_TIMING_ENABLE 1
      Active_Rx_Timing_Enable = 1;
#endif                               /* don't forget the CPLD and val (in DeviceModify) !!!!!!! */
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
#undef WTI_CESOP_CLOCK_RECOVERY_ENABLE
#define WTI_CESOP_CLOCK_RECOVERY_ENABLE 1
      Active_Clock_Recovery_Enable = 1;
#endif

      /*change COMET configuration from CR to non-CR*/
      status = WPU_TdmCometCardInit(WP_PORT_TDM1, WPU_INIT_COMET_CPLD_CR_E1);/*CR_E1*/
      WTI_TerminateOnError(status, "WPU_TdmCometCardInit()", __LINE__);
      if (WTI_ACTIVE_TDI_PORTS > 8)
      {
         status = WPU_TdmCometCardInit(WP_PORT_TDM9, WPU_INIT_COMET_CPLD_CR_E1);
         WTI_TerminateOnError(status, "WPU_TdmCometCardInit()", __LINE__);
      }

      /*recreate lines*/
      for (i=0;i<WTI_ACTIVE_TDI_PORTS;++i)
      {
         /* create transparent CES device over TDM port */
         WTI_TdiTransDeviceCreate(i);
         /* modify device to work without CR */

         /* tdm_index, cmd [1-TRANS_CES_CLOCK_REC], val [enable/disable] */
         sprintf(temp_buf, "0 %d 1 1", i);
         CLI_F_TdiTransDeviceModify(temp_buf);
         /* enable transparent device */
         status = WP_DeviceEnable(the_system->tdm_trans_dev[i], WP_DIRECTION_DUPLEX);
         WTI_TerminateOnError(status , "WP_DeviceEnable() trans device",__LINE__);
      }

      /*recreate all PW*/
      for (i=0;i<WTI_ACTIVE_TDI_PORTS ;i++)
      {
         printf("recreate PW %d\n", i);

         sprintf(temp_buf, "0 %d 1 32 0-31",i);/* T1 :0 , E1 :1 */
         CLI_F_PwConfigureFramedTdi(temp_buf);/* T1 :0 , E1 :1 */
         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 256");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/
#ifdef WTI_BOARD_1
         CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 08 74 AC 53 1E 00 00 00 00 00 00 0800");
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 50 FC E2 0A D9 00 00 00 00 00 00 0800");
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

         if (Active_Rx_Timing_Enable)
         {

            /* Rx timing is used */
            sprintf(temp_buf, "0 1 1 %d",i);
            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
         }
         else
         {

            /* Rx timing is not used */
            sprintf(temp_buf, "0 0 1 %d",i);
            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
         }

         /**************** PSN --> TDM Tx binding*****************/

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");
         if (Active_Clock_Recovery_Enable)
         {

            /* create clock by using the ufe*/
            /*write the HW clock recovery registers */
#if WTI_CLOCK_REC_MODE
            /* initial the clock counters thresholds for TDI diff mode */
            /* Init Timestamp  HW in FPGA 0 - E1 1- T1, line index  */
            /* (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM) , line index */
            sprintf(temp_buf, "0 3 %x",i);
#ifdef WP_HW_WINPATH2
            CLI_F_TdiCrTSInt(temp_buf);
#endif  /* WP_HW_WINPATH2 */
#endif

            sprintf(temp_buf, "0 0 0 1 %d", i);
            CLI_F_PwCreate(temp_buf);
            sprintf(temp_buf, "0 %d 1",i);
            CLI_F_PwEnable(temp_buf);
         }
         else
         {

            sprintf(temp_buf, "0 0 0 0 %d", i);
            CLI_F_PwCreate(temp_buf);
            sprintf(temp_buf, "0 %d 0",i);
            CLI_F_PwEnable(temp_buf);
         }

      }

      printf("Wait %d seconds to let the system become stable...\n", DELAY_DURATION_IN_SECONDS);
      WP_Delay(DELAY_DURATION_IN_SECONDS * 1000*1000);
      /* Global statistics check, including reset. */
      result = CLI_F_GlobalStatisticsCheck("0");
      if (result == WT_FAIL)
      {
         WTI_PRINT_ERROR(("\n Test Failed. Iteration number: %d\n", iterations));
         return;
      }
      printf(">>>>>>>>>>>>>>>> end of iteration %d   <<<<<<<<<<<<<<<\n", iterations);

   }
}

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_304_TDI_T1_F_CR_NoCas_Two_Boards_N_Line_N_PW_Remove_Device_Recreate_Without_CR(char *StrPrm)
{
   WP_status status;
   WP_U32 i, pw_index, line_index,iterations, result;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   int Active_Rx_Timing_Enable=0, Active_Clock_Recovery_Enable=0;

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* init all active TDM interfaces to the default configuration:
      T1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to T1 UNFRAMED no CAS */
   for (i=0;i<WTI_ACTIVE_TDI_PORTS ;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);/* T1 :0 , E1 :1 */
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();


#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<WTI_ACTIVE_TDI_PORTS; i++)
   {
      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      /* Overwrite defult paramters if needed */
#if WTI_CLOCK_REC_MODE && WTI_CESOP_DIFF_DOCSIS_MODE
      /* Set DCR-DOCSIS operation mode */
      the_system->clock_rec[i].operation_mode = WP_IW_CLOCK_REC_DOCSIS;
      /* DOCSIS E1-1061 T1-800 */
      the_system->clock_rec[i].ts_clock_divider = WP_CLOCK_REC_TS_CLOCK_DIV_DOCSIS_T1;
#endif  /* WTI_CLOCK_REC_MODE && WTI_CESOP_DIFF_DOCSIS_MODE */
   }
#endif  /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */

   for (i=0;i<WTI_ACTIVE_TDI_PORTS ;i++)
   {
      sprintf(temp_buf, "0 %d 0 24 0-23",i);/* T1 :0 , E1 :1 */
      CLI_F_PwConfigureFramedTdi(temp_buf);/* T1 :0 , E1 :1 */

      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 192"); /*in tdi unframed RxBufferSize must be N*32 */
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/
#ifdef WTI_BOARD_1
      CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 08 74 AC 53 1E 00 00 00 00 00 00 0800");
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
      CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 50 FC E2 0A D9 00 00 00 00 00 00 0800");
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 d8 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE
      /* Rx timing is used */
      sprintf(temp_buf, "0 1 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
#else
      /* Rx timing is not used */
      sprintf(temp_buf, "0 0 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
#endif

      /**************** PSN --> TDM Tx binding*****************/

      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* create clock by using the ufe*/

#if WTI_CLOCK_REC_MODE
      /* initial the clock counters thresholds for TDI diff mode */
      /* Init Timestamp  HW in FPGA 0 - E1 1- T1, line index  */
      /* (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM) , line index */
      sprintf(temp_buf, "0 1 %x",i);
#ifdef WP_HW_WINPATH2
      CLI_F_TdiCrTSInt(temp_buf);
#endif  /* WP_HW_WINPATH2 */
#endif

      CLI_F_PwCreate("0 0 0 1");
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_PwEnable(temp_buf);
#else
      CLI_F_PwCreate("0 0 0 0");
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_PwEnable(temp_buf);
#endif
   }

   printf("Waiting a minute to let the traffic flow\n");
   WP_Delay(60*1000*1000);

   result = CLI_F_GlobalStatisticsCheck("0");
   if (result == WT_FAIL)
   {
      /* retry */
      WP_Delay(60 * 1000000);
      result = CLI_F_GlobalStatisticsCheck("0");
      if (result == WT_FAIL)
      {
         WTI_PRINT_ERROR(("\n Test Failed before remove PW/lines.\n"));
         return;
      }
   }

   for (iterations=1; iterations<WTI_ITERATIONS_NUM+1; iterations++)
   {
      printf("################ start of iteration %d   ###############\n", iterations);

      /*remove pw*/
      for (i=WTI_ACTIVE_TDI_PORTS; i>0; i--)
      {
         pw_index = i-1;
         sprintf(temp_buf, "0 %d", pw_index);
         CLI_F_PwRemove(temp_buf);
      }
      /*remove device*/
      for (i=WTI_ACTIVE_TDI_PORTS; i>0; i--)
      {
         line_index = i-1;
         printf("remove device (include clear the DCO registers %d\n", line_index);
         WTI_TdiTransDeviceDelete(line_index);
      }

      WP_Delay(60000);

      /*disable CR - recreate as non-CR at all.*/
#if WTI_CESOP_RX_TIMING_ENABLE
#undef WTI_CESOP_RX_TIMING_ENABLE
#define WTI_CESOP_RX_TIMING_ENABLE 1
      Active_Rx_Timing_Enable = 1;
#endif                              /* don't forget the CPLD and val (in DeviceModify) !!!!!!! */
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
#undef WTI_CESOP_CLOCK_RECOVERY_ENABLE
#define WTI_CESOP_CLOCK_RECOVERY_ENABLE 1
      Active_Clock_Recovery_Enable = 1;
#endif


      /*change COMET configuration from CR to non-CR*/
      status = WPU_TdmCometCardInit(WP_PORT_TDM1, WPU_INIT_COMET_CPLD_CR_T1);/*CR_T1*/
      WTI_TerminateOnError(status, "WPU_TdmCometCardInit()", __LINE__);
      if (WTI_ACTIVE_TDI_PORTS > 8)
      {
         status = WPU_TdmCometCardInit(WP_PORT_TDM9, WPU_INIT_COMET_CPLD_CR_T1);/*CR_T1*/
         WTI_TerminateOnError(status, "WPU_TdmCometCardInit()", __LINE__);
      }
      /*recreate lines*/
      for (i=0;i<WTI_ACTIVE_TDI_PORTS;++i)
      {
         /* create transparent CES device over TDM port */
         WTI_TdiTransDeviceCreate(i);
         /* modify device to work without CR */

         /* tdm_index, cmd [1-TRANS_CES_CLOCK_REC], val [enable/disable] */
         sprintf(temp_buf, "0 %d 1 1", i);
         CLI_F_TdiTransDeviceModify(temp_buf);
         /* enable transparent device */
         status = WP_DeviceEnable(the_system->tdm_trans_dev[i], WP_DIRECTION_DUPLEX);
         WTI_TerminateOnError(status , "WP_DeviceEnable() trans device",__LINE__);
      }

      /*recreate all PW*/
      for (i=0;i<WTI_ACTIVE_TDI_PORTS ;i++)
      {
         printf("recreate PW %d\n", i);

         sprintf(temp_buf, "0 %d 0 24 0-23",i);/* T1 :0 , E1 :1 */
         CLI_F_PwConfigureFramedTdi(temp_buf);/* T1 :0 , E1 :1 */
         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 192");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/
#ifdef WTI_BOARD_1
         CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 08 74 AC 53 1E 00 00 00 00 00 00 0800");
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 50 FC E2 0A D9 00 00 00 00 00 00 0800");
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 d8 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

         if (Active_Rx_Timing_Enable)
         {

            /* Rx timing is used */
            sprintf(temp_buf, "0 1 1 %d",i);
            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
         }
         else
         {

            /* Rx timing is not used */
            sprintf(temp_buf, "0 0 1 %d",i);
            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
         }

         /**************** PSN --> TDM Tx binding*****************/

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");
         if (Active_Clock_Recovery_Enable)
         {

            /* create clock by using the ufe*/
            /*write the HW clock recovery registers */
#if WTI_CLOCK_REC_MODE
            /* initial the clock counters thresholds for TDI diff mode */
            /* Init Timestamp  HW in FPGA 0 - E1 1- T1, line index  */
            /* (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM) , line index */
            sprintf(temp_buf, "0 1 %x",i);
#ifdef WP_HW_WINPATH2
            CLI_F_TdiCrTSInt(temp_buf);
#endif  /* WP_HW_WINPATH2 */
#endif

            sprintf(temp_buf, "0 0 0 1 %d", i);
            CLI_F_PwCreate(temp_buf);
            sprintf(temp_buf, "0 %d 1",i);
            CLI_F_PwEnable(temp_buf);
         }
         else
         {

            sprintf(temp_buf, "0 0 0 0 %d", i);
            CLI_F_PwCreate(temp_buf);
            sprintf(temp_buf, "0 %d 0",i);
            CLI_F_PwEnable(temp_buf);
         }

      }

      printf("Wait few seconds to let the system become stable...\n");
      WP_Delay(DELAY_DURATION_IN_SECONDS * 1000*1000);
      /* Global statistics check, including reset. */
      result = CLI_F_GlobalStatisticsCheck("0");
      if (result == WT_FAIL)
      {
         WTI_PRINT_ERROR(("\n Test Failed. Iteration number: %d\n", iterations));
         return;
      }
      printf(">>>>>>>>>>>>>>>> end of iteration %d   <<<<<<<<<<<<<<<\n", iterations);
   }
}

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_305_TDI_E1_F_30xDS0_CR_Cas_Frg_Two_Boards_N_Line_N_PW(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to E1 UNFRAMED no CAS */
   for (i=0;i<WTI_ACTIVE_TDI_PORTS ;i++)
   {
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();


#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<WTI_ACTIVE_TDI_PORTS; i++)
   {
      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      /* Overwrite defult paramters if needed */
#if WTI_CLOCK_REC_MODE && WTI_CESOP_DIFF_DOCSIS_MODE
      /* Set DCR-DOCSIS operation mode */
      the_system->clock_rec[i].operation_mode = WP_IW_CLOCK_REC_DOCSIS;
      /* DOCSIS E1-1061 T1-800 */
      the_system->clock_rec[i].ts_clock_divider = WP_CLOCK_REC_TS_CLOCK_DIV_DOCSIS_E1;
#endif  /* WTI_CLOCK_REC_MODE && WTI_CESOP_DIFF_DOCSIS_MODE */
   }
#endif  /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */

   for (i=0;i<WTI_ACTIVE_TDI_PORTS ;i++)
   {
      sprintf(temp_buf, "0 %d 1 30 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31",i);
      CLI_F_PwConfigureFramedTdi(temp_buf);
      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 240");
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/
#ifdef WTI_BOARD_1
      CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 08 74 AC 53 1E 00 00 00 00 00 00 0800");
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
      CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 50 FC E2 0A D9 00 00 00 00 00 00 0800");
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 108 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE
      /* Rx timing is used */
      sprintf(temp_buf, "0 1 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
#else
      /* Rx timing is not used */
      sprintf(temp_buf, "0 0 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
#endif

      /**************** PSN --> TDM Tx binding*****************/

      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* create clock by using the ufe*/
#if WTI_CLOCK_REC_MODE
      /* initial the clock counters thresholds for TDI diff mode */
      /* Init Timestamp  HW in FPGA 0 - E1 1- T1, line index  */
      /* (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM) , line index */
      sprintf(temp_buf, "0 3 %x",i);
#ifdef WP_HW_WINPATH2
      CLI_F_TdiCrTSInt(temp_buf);
#endif  /* WP_HW_WINPATH2 */
#endif

      CLI_F_PwCreate("0 0 0 1");
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_PwEnable(temp_buf);
#else
      CLI_F_PwCreate("0 0 0 0");
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_PwEnable(temp_buf);
#endif
   }

}

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_305_TDI_T1_F_24xDS0_CR_Cas_Frg_Two_Boards_N_Line_N_PW(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* init all active TDM interfaces to the default configuration:
      T1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to T1 UNFRAMED no CAS */
   for (i=0;i<WTI_ACTIVE_TDI_PORTS ;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);/* T1 :0 , E1 :1 */
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i); /* Fr :1 , Unfr :0 */
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();


#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<WTI_ACTIVE_TDI_PORTS; i++)
   {
      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      /* Overwrite defult paramters if needed */
#if WTI_CLOCK_REC_MODE && WTI_CESOP_DIFF_DOCSIS_MODE
      /* Set DCR-DOCSIS operation mode */
      the_system->clock_rec[i].operation_mode = WP_IW_CLOCK_REC_DOCSIS;
      /* DOCSIS E1-1061 T1-800 */
      the_system->clock_rec[i].ts_clock_divider = WP_CLOCK_REC_TS_CLOCK_DIV_DOCSIS_T1;
#endif  /* WTI_CLOCK_REC_MODE && WTI_CESOP_DIFF_DOCSIS_MODE */
   }
#endif  /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */

   for (i=0;i<WTI_ACTIVE_TDI_PORTS ;i++)
   {
      sprintf(temp_buf, "0 %d 0 24 0-23",i);
      CLI_F_PwConfigureFramedTdi(temp_buf);
      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 288"); /* 24*12 */
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/
#ifdef WTI_BOARD_1
      CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 08 74 AC 53 1E 00 00 00 00 00 00 0800");
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
      CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 50 FC E2 0A D9 00 00 00 00 00 00 0800");
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 258 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE
      /* Rx timing is used */
      sprintf(temp_buf, "0 1 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
#else
      /* Rx timing is not used */
      sprintf(temp_buf, "0 0 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
#endif

      /**************** PSN --> TDM Tx binding*****************/

      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* create clock by using the ufe*/

#if WTI_CLOCK_REC_MODE
      /* initial the clock counters thresholds for TDI diff mode */
      /* Init Timestamp  HW in FPGA 0 - E1 1- T1, line index  */
      /* (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM) , line index */
      sprintf(temp_buf, "0 1 %x",i);
#ifdef WP_HW_WINPATH2
      CLI_F_TdiCrTSInt(temp_buf);
#endif  /* WP_HW_WINPATH2 */
#endif

      CLI_F_PwCreate("0 0 0 1");
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_PwEnable(temp_buf);
#else /*WTI_CESOP_CLOCK_RECOVERY_ENABLE*/
      CLI_F_PwCreate("0 0 0 0");
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_PwEnable(temp_buf);
#endif
   }

}
#endif /*(WTI_CESOP_TDI)*/


#if (WTI_CESOP_TDI)
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_306_TDI_E1_F_CR_NoCas_Two_Boards_N_Line_2_pw_per_line(char *StrPrm)
{
   WP_U32 i,k,pw_index,pw_per_line,pw_master_for_cr;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to E1 UNFRAMED no CAS */
   for (i=0;i<WTI_ACTIVE_TDI_PORTS ;i++)
   {
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiCasMode(temp_buf);


#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* create clock by using the ufe*/
#if WTI_CLOCK_REC_MODE
      /* initial the clock counters thresholds for TDI diff mode */
      /* Init Timestamp  HW in FPGA 0 - E1 1- T1, line index  */
      /* (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM) , line index */
      sprintf(temp_buf, "0 3 %x",i);
#ifdef WP_HW_WINPATH2
      CLI_F_TdiCrTSInt(temp_buf);
#endif  /* WP_HW_WINPATH2 */
#endif
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<WTI_ACTIVE_TDI_PORTS; i++)
   {
      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      /* Overwrite defult paramters if needed */
      the_system->clock_rec[i].holdover_counter_limit = 0x00008000;

#if WTI_CLOCK_REC_MODE && WTI_CESOP_DIFF_DOCSIS_MODE
      /* Set DCR-DOCSIS operation mode */
      the_system->clock_rec[i].operation_mode = WP_IW_CLOCK_REC_DOCSIS;
      /* DOCSIS E1-1061 T1-800 */
      the_system->clock_rec[i].ts_clock_divider = WP_CLOCK_REC_TS_CLOCK_DIV_DOCSIS_E1;
#endif  /* WTI_CLOCK_REC_MODE && WTI_CESOP_DIFF_DOCSIS_MODE */
   }
#endif  /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */

   pw_index = 0;

   for (i=0;i<WTI_ACTIVE_TDI_PORTS ;i++)
   {
      pw_per_line = 2;
      /* The PW used as CR number , (one of pw_per_line) */
      pw_master_for_cr = 0;

      for (k=0; k<pw_per_line; k++)
      {
         switch(k)
         {
         case 0:
         {
            sprintf(temp_buf, "0 %d 1 16 0-15",i);
         }
         break;
         case 1:
         {
            sprintf(temp_buf, "0 %d 1 16 16-31",i);
         }
         break;

         default:
            printf("ERROR");
         }

         CLI_F_PwConfigureFramedTdi(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 32");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/
#ifdef WTI_BOARD_1
         CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 08 74 AC 53 1E 00 00 00 00 00 00 0800");
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 50 FC E2 0A D9 00 00 00 00 00 00 0800");
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 48 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE

         if(k==pw_master_for_cr)
         {
            /* Rx timing is used in first PW of each line */
            sprintf(temp_buf, "0 1 1 %d",i);
            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
         }
         else
         {
            /* Rx timing is not used */
            sprintf(temp_buf, "0 0 1 %d",pw_index);
            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
         }
#else
         /* Rx timing is not used */
         sprintf(temp_buf, "0 0 1 %d",pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
#endif

         /**************** PSN --> TDM Tx binding*****************/

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE

         if(k==pw_master_for_cr)
         {
            CLI_F_PwCreate("0 0 0 1");
            sprintf(temp_buf, "0 %d 1",pw_index);
         }
         else
         {
            CLI_F_PwCreate("0 0 0 0");
            sprintf(temp_buf, "0 %d 0",pw_index);
         }

#else
         CLI_F_PwCreate("0 0 0 0");
         sprintf(temp_buf, "0 %d 0",pw_index);
#endif
         CLI_F_PwEnable(temp_buf);

         ++pw_index;
      }
   }

}

#endif /*(WTI_CESOP_TDI)*/

#if (WTI_CESOP_TDI)
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_307_TDI_T1_F_CR_NoCas_Two_Boards_N_Line_11_plus_1_pw_per_line(char *StrPrm)
{
   WP_U32 i,k,pw_index,pw_per_line,pw_master_for_cr;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to E1 UNFRAMED no CAS */
   for (i=0;i<WTI_ACTIVE_TDI_PORTS ;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiCasMode(temp_buf);


#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* create clock by using the ufe*/
#if WTI_CLOCK_REC_MODE
      /* initial the clock counters thresholds for TDI diff mode */
      /* Init Timestamp  HW in FPGA 0 - E1 1- T1, line index  */
      /* (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM) , line index */
      sprintf(temp_buf, "0 1 %x",i);
#ifdef WP_HW_WINPATH2
      CLI_F_TdiCrTSInt(temp_buf);
#endif  /* WP_HW_WINPATH2 */
#endif
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<WTI_ACTIVE_TDI_PORTS; i++)
   {
      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      /* Overwrite defult paramters if needed */
#if WTI_CLOCK_REC_MODE && WTI_CESOP_DIFF_DOCSIS_MODE
      /* Set DCR-DOCSIS operation mode */
      the_system->clock_rec[i].operation_mode = WP_IW_CLOCK_REC_DOCSIS;
      /* DOCSIS E1-1061 T1-800 */
      the_system->clock_rec[i].ts_clock_divider = WP_CLOCK_REC_TS_CLOCK_DIV_DOCSIS_T1;
#endif  /* WTI_CLOCK_REC_MODE && WTI_CESOP_DIFF_DOCSIS_MODE */
   }
#endif  /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */

   pw_index = 0;

   for (i=0;i<WTI_ACTIVE_TDI_PORTS ;i++)
   {
      pw_per_line = 12;
      /* The PW used as CR number , (one of pw_per_line) */
      pw_master_for_cr = 11;

      for (k=0; k<pw_per_line; k++)
      {
         switch(k)
         {
         case 0:
         {
            sprintf(temp_buf, "0 %d 0 2 0-1",i);
         }
         break;
         case 1:
         {
            sprintf(temp_buf, "0 %d 0 2 2-3",i);
         }
         break;
         case 2:
         {
            sprintf(temp_buf, "0 %d 0 2 4-5",i);
         }
         break;
         case 3:
         {
            sprintf(temp_buf, "0 %d 0 2 6-7",i);
         }
         break;

         case 4:
         {
            sprintf(temp_buf, "0 %d 0 2 8-9",i);
         }
         break;
         case 5:
         {
            sprintf(temp_buf, "0 %d 0 2 10-11",i);
         }
         break;
         case 6:
         {
            sprintf(temp_buf, "0 %d 0 2 12-13",i);
         }
         break;
         case 7:
         {
            sprintf(temp_buf, "0 %d 0 2 14-15",i);
         }
         break;
         case 8:
         {
            sprintf(temp_buf, "0 %d 0 2 16-17",i);
         }
         break;
         case 9:
         {
            sprintf(temp_buf, "0 %d 0 2 18-19",i);
         }
         break;
         case 10:
         {
            sprintf(temp_buf, "0 %d 0 2 20-21",i);
         }
         break;
         case 11:
         {
            sprintf(temp_buf, "0 %d 0 2 22-23",i);
         }
         break;

         default:
            printf("ERROR");
         }

         CLI_F_PwConfigureFramedTdi(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");

         if(k == pw_master_for_cr)
         {

            CLI_F_Pwe3ChannelRxBufferSize("0 8");
         }
         else
         {
            CLI_F_Pwe3ChannelRxBufferSize("0 64");
         }
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/
#ifdef WTI_BOARD_1
         CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 08 74 AC 53 1E 00 00 00 00 00 00 0800");
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader("0 00 50 FC E2 0A D9 00 00 00 00 00 00 0800");
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 48 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE

         if(k==pw_master_for_cr)
         {
            /* Rx timing is used in first PW of each line */
            sprintf(temp_buf, "0 1 1 %d",i);
            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
         }
         else
         {
            /* Rx timing is not used */
            sprintf(temp_buf, "0 0 1 %d",pw_index);
            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
         }
#else
         /* Rx timing is not used */
         sprintf(temp_buf, "0 0 1 %d",pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
#endif

         /**************** PSN --> TDM Tx binding*****************/

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE

         if(k==pw_master_for_cr)
         {
            CLI_F_PwCreate("0 0 0 1");
            sprintf(temp_buf, "0 %d 1",pw_index);
         }
         else
         {
            CLI_F_PwCreate("0 0 0 0");
            sprintf(temp_buf, "0 %d 0",pw_index);
         }

#else
         CLI_F_PwCreate("0 0 0 0");
         sprintf(temp_buf, "0 %d 0",pw_index);
#endif
         CLI_F_PwEnable(temp_buf);

         ++pw_index;
      }
   }

}


#if WTI_CESOP_TO_MPLS_FA_CASCADING
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_308_TDI_E1_U_CR_NoCas_Mpls_Cascading(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to E1 UNFRAMED */
   for (i=0;i<8;i++)
   {
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<WTI_ACTIVE_TDI_PORTS; i++)
   {
      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }
#endif  /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */


   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif


   /* ------------------- Creating the MPLS L2 router flow aggregations in both directions */
   for (i=0;i<WTI_MAX_NUM_OF_MPLS_FA;++i)
   {
#if WTI_CESOP_MPLS_OVER_ENET
      /* create the l2 router MPLS flow aggregations */
      CLI_F_Tdm2PsnFlowAggEnetHeaderMpls("0 aa aa aa aa aa aa bb bb bb bb bb bb 8847");
      CLI_F_MplsFlowAggPrefixLength("0 18");
      sprintf(temp_buf,
              "0 %x %x %x %x %x %x",
              3*i,
              3*i+1,
              3*i+2,
              0x81000005,
              (0x88470000 | ((((WTI_MPLS_LABEL) >> 12) + WTI_MAX_PW + 1 + i) >> 4)),
              ((((((WTI_MPLS_LABEL) >> 12)  + WTI_MAX_PW + 1 + i) & 0xff) << 28) | 0x00ff0000));
      /*                              [mac destination] [mac source] [vlan] [type] [mpls header] */
      CLI_F_MplsFlowAggPrefixHeaderMpls(temp_buf);

      mpls_layer2_agg_cfg.txfunc = the_system->tx_enet_channel;

      sprintf(temp_buf, "0 %d", 0); /* remark offsets for VLAN priority and PSN tunnel EXP bits */

      CLI_F_MplsFlowAggRemarkingOffsets(temp_buf);
      sprintf(temp_buf, "0 %d", i);
      CLI_F_MplsFlowAggCreate(temp_buf);
#else
#if WTI_CESOP_NATIVE_MPLS_IW
      /* create the l2 router MPLS flow aggregations */
      CLI_F_MplsFlowAggPrefixLength("0 0");
      sprintf(temp_buf,
              "0 %x",
              (((((WTI_MPLS_LABEL) >> 12) + WTI_MAX_PW + 1 + i) << 12) | 0xff));
      /*                              [mpls header] */
      CLI_F_MplsFlowAggPrefixHeaderMpls(temp_buf);
      sprintf(temp_buf, "0 %d %d", 1, 5); /* remark offsets for PSN tunnel EXP bits */

      CLI_F_MplsFlowAggRemarkingOffsets(temp_buf);
      sprintf(temp_buf, "0 %d", i);
      CLI_F_MplsFlowAggCreate(temp_buf);
#else
      /* create the l2 router MPLS flow aggregations */
      CLI_F_MplsFlowAggPrefixLength("0 4");
      sprintf(temp_buf,
              "0 %x %x",
              WTI_MPLSoPPP,
              (((((WTI_MPLS_LABEL) >> 12) + WTI_MAX_PW + 1 + i) << 12) | 0xff));
      /*                              [ppp] [mpls header] */
      CLI_F_MplsFlowAggPrefixHeaderMpls(temp_buf);
      sprintf(temp_buf, "0 %d %d", 1, 13); /* remark offsets for PSN tunnel EXP bits */

      CLI_F_MplsFlowAggRemarkingOffsets(temp_buf);
      sprintf(temp_buf, "0 %d", i);
      CLI_F_MplsFlowAggCreate(temp_buf);
#endif /* WTI_CESOP_NATIVE_MPLS_IW */
#endif /* WTI_CESOP_MPLS_OVER_ENET */
   }


   for (i=0;i<WTI_ACTIVE_TDI_PORTS/*256*/;++i)
   {
      sprintf(temp_buf, "0 %d 1", i);
      CLI_F_PwConfigureUnframedTdi(temp_buf);

      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 256");
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/
#if WTI_ENET_IEEE_802
      CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
      CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif

      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");


#if WTI_CESOP_RX_TIMING_ENABLE
      /* Rx timing is used */
      sprintf(temp_buf, "0 1 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
#else
      /* Rx timing is not used */
      sprintf(temp_buf, "0 0 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
#endif
      //      CLI_F_Tdm2PsnFlowAggTsParams("0 1 0 0");
      sprintf(temp_buf, "0 %d %d %d", 2, (7-(i%7)), (i%7)); /* remark values for VLAN priority and PSN tunnel EXP bits */
      CLI_F_Tdm2PsnFlowAggRemarkingValues(temp_buf);

      /**************** PSN --> TDM IW *****************/

      CLI_F_Psn2TdmFlowAggTsParams("0 1 3000");

      /**************** PSN --> TDM Tx binding*****************/

      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* create clock by using the ufe*/
      /*write the HW clock recovery registers */
#if WP_HW_WINPATH2
#if WTI_CLOCK_REC_MODE
      /* initial the clock counters thresholds for TDI diff mode */
      /* Init Timestamp  HW in FPGA 0 - E1 1- T1, line index  */
      /* (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM) , line index */
      sprintf(temp_buf, "0 4 %x",i);
      CLI_F_TdiCrTSInt(temp_buf);
#endif
#endif /* WP2 */
#endif /* CR */

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      if (i < WTI_FIRST_ENET_MAX_PW)
         sprintf(temp_buf, "0 %d %d %d %d %d", 0,1,1,0,i);
      else
         sprintf(temp_buf, "0 %d %d %d %d %d", 0,1,1,1,i);
      CLI_F_PwCreateCascaded(temp_buf);
#else
      sprintf(temp_buf, "0 %d %d %d %d %d", 0,0,0,(i%WTI_MAX_NUM_OF_MPLS_FA),i);
      CLI_F_PwCreateCascaded(temp_buf);
#endif

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      sprintf(temp_buf, "0 %d 1", i);
#else
      sprintf(temp_buf, "0 %d 0", i);
#endif
      CLI_F_PwEnable(temp_buf);
   }
}

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_308_TDI_T1_U_CR_NoCas_Mpls_Cascading(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* init all active TDM interfaces to the default configuration:
      T1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to T1 UNFRAMED */
   for (i=0;i<8;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<WTI_ACTIVE_TDI_PORTS; i++)
   {
      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }
#endif  /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */


   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif


   /* ------------------- Creating the MPLS L2 router flow aggregations in both directions */
   for (i=0;i<WTI_MAX_NUM_OF_MPLS_FA;++i)
   {
#if WTI_CESOP_MPLS_OVER_ENET
      /* create the l2 router MPLS flow aggregations */
      CLI_F_Tdm2PsnFlowAggEnetHeaderMpls("0 aa aa aa aa aa aa bb bb bb bb bb bb 8847");
      CLI_F_MplsFlowAggPrefixLength("0 18");
      sprintf(temp_buf,
              "0 %x %x %x %x %x %x",
              3*i,
              3*i+1,
              3*i+2,
              0x81000005,
              (0x88470000 | ((((WTI_MPLS_LABEL) >> 12) + WTI_MAX_PW + 1 + i) >> 4)),
              ((((((WTI_MPLS_LABEL) >> 12)  + WTI_MAX_PW + 1 + i) & 0xff) << 28) | 0x00ff0000));
      /*                              [mac destination] [mac source] [vlan] [type] [mpls header] */
      CLI_F_MplsFlowAggPrefixHeaderMpls(temp_buf);

      mpls_layer2_agg_cfg.txfunc = the_system->tx_enet_channel;

      sprintf(temp_buf, "0 %d", 0); /* remark offsets for VLAN priority and PSN tunnel EXP bits */

      CLI_F_MplsFlowAggRemarkingOffsets(temp_buf);
      sprintf(temp_buf, "0 %d", i);
      CLI_F_MplsFlowAggCreate(temp_buf);
#else
#if WTI_CESOP_NATIVE_MPLS_IW
      /* create the l2 router MPLS flow aggregations */
      CLI_F_MplsFlowAggPrefixLength("0 0");
      sprintf(temp_buf,
              "0 %x",
              (((((WTI_MPLS_LABEL) >> 12) + WTI_MAX_PW + 1 + i) << 12) | 0xff));
      /*                              [mpls header] */
      CLI_F_MplsFlowAggPrefixHeaderMpls(temp_buf);
      sprintf(temp_buf, "0 %d %d", 1, 5); /* remark offsets for PSN tunnel EXP bits */

      CLI_F_MplsFlowAggRemarkingOffsets(temp_buf);
      sprintf(temp_buf, "0 %d", i);
      CLI_F_MplsFlowAggCreate(temp_buf);
#else
      /* create the l2 router MPLS flow aggregations */
      CLI_F_MplsFlowAggPrefixLength("0 4");
      sprintf(temp_buf,
              "0 %x %x",
              WTI_MPLSoPPP,
              (((((WTI_MPLS_LABEL) >> 12) + WTI_MAX_PW + 1 + i) << 12) | 0xff));
      /*                              [ppp] [mpls header] */
      CLI_F_MplsFlowAggPrefixHeaderMpls(temp_buf);
      sprintf(temp_buf, "0 %d %d", 1, 13); /* remark offsets for PSN tunnel EXP bits */

      CLI_F_MplsFlowAggRemarkingOffsets(temp_buf);
      sprintf(temp_buf, "0 %d", i);
      CLI_F_MplsFlowAggCreate(temp_buf);
#endif /* WTI_CESOP_NATIVE_MPLS_IW */
#endif /* WTI_CESOP_MPLS_OVER_ENET */
   }


   for (i=0;i<WTI_ACTIVE_TDI_PORTS/*256*/;++i)
   {
      sprintf(temp_buf, "0 %d 0", i);
      CLI_F_PwConfigureUnframedTdi(temp_buf);

      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 192");
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/
#if WTI_ENET_IEEE_802
      CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
      CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif

      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
/* to match with ufe4 tests  */
/**************** TDM --> PSN IW *****************/
//  CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 0800");
//  sprintf(temp_buf, "0 45000000 811e0000 40110000 1a1a1a1a %d", i+1);
//  printf("%d: %s \n",__LINE__,temp_buf);
//  CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
//  CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 0 0");
//  CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
//  CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");



#if WTI_CESOP_RX_TIMING_ENABLE
      /* Rx timing is used */
      sprintf(temp_buf, "0 1 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
#else
      /* Rx timing is not used */
      sprintf(temp_buf, "0 0 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER,2-WP_IW_CESOP_DIFF_TS_SLAVE),ts_diff_if_id(0-31)] */
#endif
      //      CLI_F_Tdm2PsnFlowAggTsParams("0 1 0 0");
      sprintf(temp_buf, "0 %d %d %d", 2, (7-(i%7)), (i%7)); /* remark values for VLAN priority and PSN tunnel EXP bits */
      CLI_F_Tdm2PsnFlowAggRemarkingValues(temp_buf);

      /**************** PSN --> TDM IW *****************/

      CLI_F_Psn2TdmFlowAggTsParams("0 1 3000");

      /**************** PSN --> TDM Tx binding*****************/

      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* create clock by using the ufe*/
      /*write the HW clock recovery registers */
#if WP_HW_WINPATH2
#if WTI_CLOCK_REC_MODE
      /* initial the clock counters thresholds for TDI diff mode */
      /* Init Timestamp  HW in FPGA 0 - E1 1- T1, line index  */
      /* (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM) , line index */
      sprintf(temp_buf, "0 2 %x",i);
      CLI_F_TdiCrTSInt(temp_buf);
#endif
#endif /* WP2 */
#endif /* CR */

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      if (i < WTI_FIRST_ENET_MAX_PW)
         sprintf(temp_buf, "0 %d %d %d %d %d", 0,1,1,0,i);
      else
         sprintf(temp_buf, "0 %d %d %d %d %d", 0,1,1,1,i);
      CLI_F_PwCreateCascaded(temp_buf);
#else
      sprintf(temp_buf, "0 %d %d %d %d %d", 0,0,0,(i%WTI_MAX_NUM_OF_MPLS_FA),i);
      CLI_F_PwCreateCascaded(temp_buf);
#endif

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      sprintf(temp_buf, "0 %d 1", i);
#else
      sprintf(temp_buf, "0 %d 0", i);
#endif
      CLI_F_PwEnable(temp_buf);
   }
}
#endif /* #if WTI_CESOP_TO_MPLS_FA_CASCADING */

#endif /*(WTI_CESOP_TDI)*/

/*-----------------------------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------------------------*/
/*----------------------------- End of Clock recovery tests section 1 --------------------------*/
/*-----------------------------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------*/
/*-----------------------------  Clock recovery tests section 2 ---------------------------------------*/
/* All following Clock Recovery OCTAL Over UFE (CAD) tests can work with RX,TX,BOTH,NON Timing options */
/*-----------------------------------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------------------------------*/

#if (!WTI_CESOP_TDI)
/********************************************************************************************
 * Description:
 *            N = "N_ACTIVE_UFE_OCT_LINES"
 *            The test create N PWs (in this case PW = line) each line uses different CD.
 *            The test can run upto 8 lines (all use same PS and DUS).
 * TDM2PSN :  The test uses N CD for the N PWs.
 *            each CD uses different shaper.
 * PSN2TDM :  Each of PWs (lines) 0...N-1 are conected to CT#0..N-1
 ***************************************************************/
void CLI_F_201_CAD_E1_U_CR_NoCas_Two_Boards_N_Line_N_PW(char *StrPrm)
{
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR   ip_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 i;

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);
   memset(ip_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");

   /* clock recovery system config */

#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE||WTI_CESOP_RX_TIMING_ENABLE)
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE || WTI_CESOP_RX_TIMING_ENABLE */

   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex] */
#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* set ufe Tx and Rx direction */
      sprintf(temp_buf, "0 %d 4 3",i);
#else
      /* set ufe Tx direction only */
      sprintf(temp_buf, "0 %d 4 1",i);
#endif

#else

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* differential mode timing only set ufe  Rx direction */
      sprintf(temp_buf, "0 %d 4 2",i);
#else
      /* no timing or adaptive mode */
      sprintf(temp_buf, "0 %d 4 0",i);
#endif

#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */

      CLI_F_UfeTransferMode(temp_buf);

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* Use shaper only in diff mode */
      /* Conect each line to its shaper */
      sprintf(temp_buf, "0 %d %d",i,i);

      CLI_F_UfeLineOctalClkShaperSet(temp_buf); /* line_index, trans_id */
#endif /* WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE */

   }
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<84; i++)
   {
      if (i<N_ACTIVE_UFE_OCT_LINES)
      {
         /* Set the defult PSN2TDM clock recoevry paramters */
         WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      }
   }
#endif

#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   CLI_F_UfeChipInitLineSetup("");

   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 32 32",i);
      CLI_F_PwConfigureUnframed(temp_buf);

      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 256");
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/
#if WTI_ENET_IEEE_802
      CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
      CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* Rx timing is used */
      sprintf(temp_buf, "0 1 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS),ts_diff_if_id(0-31)] */
#else
      /* Rx timing is not used */
      sprintf(temp_buf, "0 0 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS),ts_diff_if_id(0-31)] */
#endif


      /**************** PSN --> TDM Tx binding*****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* if clock recovery is set -> Tx timing is used */
      CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#else
      /* if clock recovery is disable -> Tx timing is not used */
      CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#endif
      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* CR master Rx and Tx direction */
      CLI_F_PwCreate("0 0 1 1"); /* CR master */
#else
      /* CR master Tx direction */
      CLI_F_PwCreate("0 0 0 1"); /* CR master */
#endif

      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_PwEnable(temp_buf);
#else /* Not WTI_CESOP_CLOCK_RECOVERY_ENABLE */
#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* rx and differential timing */
      CLI_F_PwCreate("0 0 1 0"); /* slave mode */
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_PwEnable(temp_buf);
#else
      /* no timing */
      CLI_F_PwCreate("0 0 0 0"); /* slave mode */
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_PwEnable(temp_buf);
#endif
#endif
   }
}
#endif /*!(WTI_CESOP_TDI)*/

#if (!WTI_CESOP_TDI)
/***************************************************************
 * Func name  :
 * Description:
 *            N = "N_ACTIVE_UFE_OCT_LINES"
 *            The test create N PWs (in this case PW = line) each line uses different CD.
 *            The test can run upto 8 lines (all use same PS and DUS).
 * TDM2PSN :  The test uses N CD for the N PWs.
 *            each CD uses different shaper.
 * PSN2TDM :  Each of PWs (lines) 0...N-1 are conected to CT#0..N-1
 ***************************************************************/
void CLI_F_201_CAD_T1_U_CR_NoCas_Two_Boards_N_Line_N_PW(char *StrPrm)
{
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR   ip_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 i;
   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);
   memset(ip_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");

   /* clock recovery system config */

#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE||WTI_CESOP_RX_TIMING_ENABLE)
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE || WTI_CESOP_RX_TIMING_ENABLE */

   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex] */
#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* set ufe Tx and Rx direction */

      sprintf(temp_buf, "0 %d 2 3",i);
#else
      /* set ufe Tx direction only */
      sprintf(temp_buf, "0 %d 2 1",i);
#endif

#else

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* differential mode timing only set ufe  Rx direction */
      sprintf(temp_buf, "0 %d 2 2",i);
#else
      /* no timing or adaptive mode */
      sprintf(temp_buf, "0 %d 2 0",i);
#endif

#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */

      CLI_F_UfeTransferMode(temp_buf);

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* Use shaper only in diff mode */
      /* Conect each line to its shaper */
      sprintf(temp_buf, "0 %d %d",i,i);

      CLI_F_UfeLineOctalClkShaperSet(temp_buf); /* line_index, trans_id */
#endif /* WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE */
   }
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<84; i++)
   {
      if (i<N_ACTIVE_UFE_OCT_LINES)
      {
         /* Set the defult PSN2TDM clock recoevry paramters */
         WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      }
   }
#endif

#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");/* Priority 7 vlan 1 */
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   CLI_F_UfeChipInitLineSetup("");

   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 24 24",i);
      CLI_F_PwConfigureUnframed(temp_buf);

      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 192");
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/
#if WTI_ENET_IEEE_802
      CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
      CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 d8 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* Rx timing is used */
      sprintf(temp_buf, "0 1 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS),ts_diff_if_id(0-31)] */
#else
      /* Rx timing is not used */
      sprintf(temp_buf, "0 0 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS),ts_diff_if_id(0-31)] */
#endif

      /**************** PSN --> TDM Tx binding*****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* if clock recovery is set -> Tx timing is used */
      CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#else
      /* if clock recovery is disable -> Tx timing is not used */
      CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#endif
      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* CR master Rx and Tx direction */
      CLI_F_PwCreate("0 0 1 1"); /* CR master */
#else
      /* CR master Tx direction */
      CLI_F_PwCreate("0 0 0 1"); /* CR master */
#endif

      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_PwEnable(temp_buf);
#else /* Not WTI_CESOP_CLOCK_RECOVERY_ENABLE */
#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* rx and differential timing */
      CLI_F_PwCreate("0 0 1 0"); /* slave mode */
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_PwEnable(temp_buf);
#else
      /* no timing */
      CLI_F_PwCreate("0 0 0 0"); /* slave mode */
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_PwEnable(temp_buf);
#endif
#endif
   }
}
#endif/*!(WTI_CESOP_TDI)*/

#if (!WTI_CESOP_TDI)
/***************************************************************
 * Func name  :
 * Description:
 *            N = "N_ACTIVE_UFE_OCT_LINES"
 *            The test create N PWs using all the DS0 of the line (in this case PW = line)
 *            each line uses different CD.
 *            The test can run upto 8 lines (all use same PS and DUS).
 * TDM2PSN :  The test uses N CD for the N PWs.
 *            each CD uses different shaper.
 * PSN2TDM :  Each of PWs (lines) 0...N-1 are conected to CT#0..N-1
 ***************************************************************/
void CLI_F_201_CAD_E1_F_CR_NoCas_Two_Boards_N_Line_N_PW(char *StrPrm)
{
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR   ip_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 i;

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);
   memset(ip_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");

   /* clock recovery system config */

#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE||WTI_CESOP_RX_TIMING_ENABLE)
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE || WTI_CESOP_RX_TIMING_ENABLE */

   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex] */
#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* set ufe Tx and Rx direction */
      sprintf(temp_buf, "0 %d 3 3",i);
#else
      /* set ufe Tx direction only */
      sprintf(temp_buf, "0 %d 3 1",i);
#endif

#else

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* differential mode timing only set ufe  Rx direction */
      sprintf(temp_buf, "0 %d 3 2",i);
#else
      /* no timing or adaptive mode */
      sprintf(temp_buf, "0 %d 3 0",i);
#endif

#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */

      CLI_F_UfeTransferMode(temp_buf);

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* Use shaper only in diff mode */
      /* Conect each line to its shaper */
      sprintf(temp_buf, "0 %d %d",i,i);

      CLI_F_UfeLineOctalClkShaperSet(temp_buf); /* line_index, trans_id */

#endif /* WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE */
   }
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<84; i++)
   {
      if (i<N_ACTIVE_UFE_OCT_LINES)
      {
         /* Set the defult PSN2TDM clock recoevry paramters */
         WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      }
   }
#endif

#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");/* Priority 7 vlan 1 */
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   CLI_F_UfeChipInitLineSetup("");

   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 32 32 32 0-31",i);
      CLI_F_PwConfigureFramed(temp_buf);

      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 256");
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/
#if WTI_ENET_IEEE_802
      CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
      CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* Rx timing is used */
      sprintf(temp_buf, "0 1 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS),ts_diff_if_id(0-31)] */
#else
      /* Rx timing is not used */
      sprintf(temp_buf, "0 0 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS),ts_diff_if_id(0-31)] */
#endif




      /**************** PSN --> TDM Tx binding*****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* if clock recovery is set -> Tx timing is used */
      CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#else
      /* if clock recovery is disable -> Tx timing is not used */
      CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#endif
      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* CR master Rx and Tx direction */
      CLI_F_PwCreate("0 0 1 1"); /* CR master */
#else
      /* CR master Tx direction */
      CLI_F_PwCreate("0 0 0 1"); /* CR master */
#endif

      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_PwEnable(temp_buf);
#else /* Not WTI_CESOP_CLOCK_RECOVERY_ENABLE */
#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* rx and differential timing */
      CLI_F_PwCreate("0 0 1 0"); /* slave mode */
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_PwEnable(temp_buf);
#else
      /* no timing */
      CLI_F_PwCreate("0 0 0 0"); /* slave mode */
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_PwEnable(temp_buf);
#endif
#endif
   }
   /*************************** SECOND FLOW TO LOAD WINGINS ***********************/
   /* USED FOR THE SECOND BOARD WITH RECOVER THE CLOCK                       */
   /* TEST SETUP : ENET1 - CES , ENET2: GMII OV FIBER WITH DES IP 0.0.0.8    */
   /* WTI_2_ENET_DEVICES  = 1,                         */
   /***********************END OF SECOND FLOW TO LOAD WINGINS **********************/
}
#endif/*!(WTI_CESOP_TDI)*/

#if (!WTI_CESOP_TDI)
/***************************************************************
 * Description:
 *            N = "N_ACTIVE_UFE_OCT_LINES"
 *            The test create N PWs using all the DS0 of the line (in this case PW = line)
 *            each line uses different CD.
 *            The test can run upto 8 lines (all use same PS and DUS).
 * TDM2PSN :  The test uses N CD for the N PWs.
 *            each CD uses different shaper.
 * PSN2TDM :  Each of PWs (lines) 0...N-1 are conected to CT#0..N-1
 ***************************************************************/
void CLI_F_201_CAD_T1_F_CR_NoCas_Two_Boards_N_Line_N_PW(char *StrPrm)
{
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR   ip_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 i;

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);
   memset(ip_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");

   /* clock recovery system config */

#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE||WTI_CESOP_RX_TIMING_ENABLE)
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE || WTI_CESOP_RX_TIMING_ENABLE */

   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex] */
#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* set ufe Tx and Rx direction */
      sprintf(temp_buf, "0 %d 1 3",i);
#else
      /* set ufe Tx direction only */
      sprintf(temp_buf, "0 %d 1 1",i);
#endif

#else

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* differential mode timing only set ufe  Rx direction */
      sprintf(temp_buf, "0 %d 1 2",i);
#else
      /* no timing or adaptive mode */
      sprintf(temp_buf, "0 %d 1 0",i);
#endif

#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */

      CLI_F_UfeTransferMode(temp_buf);

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* Use shaper only in diff mode */
      /* Conect each line to its shaper */
      sprintf(temp_buf, "0 %d %d",i,i);

      CLI_F_UfeLineOctalClkShaperSet(temp_buf); /* line_index, trans_id */
#endif /* WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE */
   }
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<84; i++)
   {
      if (i<N_ACTIVE_UFE_OCT_LINES)
      {
         /* Set the defult PSN2TDM clock recoevry paramters */
         WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      }
   }
#endif

#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");/* Priority 7 vlan 1 */
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   CLI_F_UfeChipInitLineSetup("");

   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 24 24 24 0-23",i);
      CLI_F_PwConfigureFramed(temp_buf);
      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 192");
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/
#if WTI_ENET_IEEE_802
      CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
      CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 d8 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* Rx timing is used */
      sprintf(temp_buf, "0 1 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS),ts_diff_if_id(0-31)] */
#else
      /* Rx timing is not used */
      sprintf(temp_buf, "0 0 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS),ts_diff_if_id(0-31)] */
#endif

      /**************** PSN --> TDM Tx binding*****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* if clock recovery is set -> Tx timing is used */
      CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#else
      /* if clock recovery is disable -> Tx timing is not used */
      CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#endif
      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* CR master Rx and Tx direction */
      CLI_F_PwCreate("0 0 1 1"); /* CR master */
#else
      /* CR master Tx direction */
      CLI_F_PwCreate("0 0 0 1"); /* CR master */
#endif

      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_PwEnable(temp_buf);
#else /* Not WTI_CESOP_CLOCK_RECOVERY_ENABLE */
#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* rx and differential timing */
      CLI_F_PwCreate("0 0 1 0"); /* slave mode */
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_PwEnable(temp_buf);
#else
      /* no timing */
      CLI_F_PwCreate("0 0 0 0"); /* slave mode */
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_PwEnable(temp_buf);
#endif
#endif
   }
}
#endif/*!(WTI_CESOP_TDI)*/

#if (!WTI_CESOP_TDI)
/***************************************************************
 * Description:
 *            N = "N_ACTIVE_UFE_OCT_LINES"
 *            The test create N PWs using 1 DS0 of the line ,each line uses different CD.
 *
 *            The test can run upto 8 PWs (from different line (all use same PS and DUS).
 * TDM2PSN :  The test uses N CD for the N PWs.
 *            each CD uses different shaper.
 * PSN2TDM :  Each of PWs 0...N-1 are conected to CT#0..N-1
 ***************************************************************/
void CLI_F_202_CAD_E1_F_CR_NoCas_Two_Boards_N_Line_N_PW_1DS0(char *StrPrm)
{

   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR   ip_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 i;

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);
   memset(ip_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");

   /* clock recovery system config */
#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE||WTI_CESOP_RX_TIMING_ENABLE)
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE || WTI_CESOP_RX_TIMING_ENABLE */

   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex] */
#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* set ufe Tx and Rx direction */
      sprintf(temp_buf, "0 %d 3 3",i);
#else
      /* set ufe Tx direction only */
      sprintf(temp_buf, "0 %d 3 1",i);
#endif

#else

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* differential mode timing only set ufe  Rx direction */
      sprintf(temp_buf, "0 %d 3 2",i);
#else
      /* no timing or adaptive mode */
      sprintf(temp_buf, "0 %d 3 0",i);
#endif

#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */

      CLI_F_UfeTransferMode(temp_buf);

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* Use shaper only in diff mode */
      /* Conect each line to its shaper */
      sprintf(temp_buf, "0 %d %d",i,i);

      CLI_F_UfeLineOctalClkShaperSet(temp_buf); /* line_index, trans_id */
#endif /* WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE */
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<84; i++)
   {
      if (i<N_ACTIVE_UFE_OCT_LINES)
      {
         /* Set the defult PSN2TDM clock recoevry paramters */
         WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      }
   }
#endif

#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");/* Priority 7 vlan 1 */
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   CLI_F_UfeChipInitLineSetup("");

   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 40 40 1 30",i);/* RX DU size ,TX DU size ,The number of slots of this channel and there location*/
      CLI_F_PwConfigureFramed(temp_buf);

      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 40");/*The size of the packet in bytes*/
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 32");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/
#if WTI_ENET_IEEE_802
      CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
      CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif

#ifdef WTI_BOARD_1
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 40 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");


#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* Rx timing is used */
      sprintf(temp_buf, "0 1 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS),ts_diff_if_id(0-31)] */
#else
      /* Rx timing is not used */
      sprintf(temp_buf, "0 0 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS),ts_diff_if_id(0-31)] */
#endif




      /**************** PSN --> TDM Tx binding*****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* if clock recovery is set -> Tx timing is used */
      CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#else
      /* if clock recovery is disable -> Tx timing is not used */
      CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#endif
      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* CR master Rx and Tx direction */
      CLI_F_PwCreate("0 0 1 1"); /* CR master */
#else
      /* CR master Tx direction */
      CLI_F_PwCreate("0 0 0 1"); /* CR master */
#endif

      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_PwEnable(temp_buf);
#else /* Not WTI_CESOP_CLOCK_RECOVERY_ENABLE */
#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* rx and differential timing */
      CLI_F_PwCreate("0 0 1 0"); /* slave mode */
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_PwEnable(temp_buf);
#else
      /* no timing */
      CLI_F_PwCreate("0 0 0 0"); /* slave mode */
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_PwEnable(temp_buf);
#endif
#endif
   }
}
#endif/*!(WTI_CESOP_TDI)*/
#if (!WTI_CESOP_TDI)
/***************************************************************
 * Description:
 *            N = "N_ACTIVE_UFE_OCT_LINES"
 *            The test create N PWs using 1 DS0 of the line ,each line uses different CD.
 *
 *            The test can run upto 8 PWs (from different line (all use same PS and DUS).
 * TDM2PSN :  The test uses N CD for the N PWs.
 *            each CD uses different shaper.
 * PSN2TDM :  Each of PWs 0...N-1 are conected to CT#0..N-1
 ***************************************************************/
void CLI_F_202_CAD_T1_F_CR_NoCas_Two_Boards_N_Line_N_PW_1DS0(char *StrPrm)
{
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR   ip_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 i;

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);
   memset(ip_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");

   /* clock recovery system config */

#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE||WTI_CESOP_RX_TIMING_ENABLE)
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE || WTI_CESOP_RX_TIMING_ENABLE */

   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex] */
#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* set ufe Tx and Rx direction */
      sprintf(temp_buf, "0 %d 1 3",i);
#else
      /* set ufe Tx direction only */
      sprintf(temp_buf, "0 %d 1 1",i);
#endif

#else

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* differential mode timing only set ufe  Rx direction */
      sprintf(temp_buf, "0 %d 1 2",i);
#else
      /* no timing or adaptive mode */
      sprintf(temp_buf, "0 %d 1 0",i);
#endif

#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */

      CLI_F_UfeTransferMode(temp_buf);

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* Use shaper only in diff mode */
      /* Conect each line to its shaper */
      sprintf(temp_buf, "0 %d %d",i,i);

      CLI_F_UfeLineOctalClkShaperSet(temp_buf); /* line_index, trans_id */
#endif /* WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE */
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<84; i++)
   {
      if (i<N_ACTIVE_UFE_OCT_LINES)
      {
         /* Set the defult PSN2TDM clock recoevry paramters */
         WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      }
   }
#endif

#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */



#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");/* Priority 7 vlan 1 */
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   CLI_F_UfeChipInitLineSetup("");

   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 40 40 1 22",i);/* RX DU size ,TX DU size ,The number of slots of this channel and there location*/
      CLI_F_PwConfigureFramed(temp_buf);
      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 40");/*The size of the packet in bytes*/
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 24");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/
#if WTI_ENET_IEEE_802
      CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
      CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 40 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");


#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* Rx timing is used */
      sprintf(temp_buf, "0 1 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS),ts_diff_if_id(0-31)] */
#else
      /* Rx timing is not used */
      sprintf(temp_buf, "0 0 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS),ts_diff_if_id(0-31)] */
#endif

      /**************** PSN --> TDM Tx binding*****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* if clock recovery is set -> Tx timing is used */
      CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#else
      /* if clock recovery is disable -> Tx timing is not used */
      CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#endif
      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* CR master Rx and Tx direction */
      CLI_F_PwCreate("0 0 1 1"); /* CR master */
#else
      /* CR master Tx direction */
      CLI_F_PwCreate("0 0 0 1"); /* CR master */
#endif

      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_PwEnable(temp_buf);
#else /* Not WTI_CESOP_CLOCK_RECOVERY_ENABLE */
#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* rx and differential timing */
      CLI_F_PwCreate("0 0 1 0"); /* slave mode */
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_PwEnable(temp_buf);
#else
      /* no timing */
      CLI_F_PwCreate("0 0 0 0"); /* slave mode */
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_PwEnable(temp_buf);
#endif
#endif
   }
}
#endif/*!(WTI_CESOP_TDI)*/
/*-----------------------------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------------------------*/
/*----------------------------- End of Clock recovery tests section 2 ---------------------------*/
/*-----------------------------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------*/
/*-----------------------------  Clock recovery tests section 3 ------------------------------------------*/
/* All following Clock Recovery OCTAL Over UFE tests are define to work with TX & RX CR enable bitS only  */
/*--------------------------------------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------------------------------------*/

/* All following Clock Recovery OCTAL Over UFE tests (both one CR and 8 CR) are define to work with CR enable bit only*/
#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE || WTI_CESOP_RX_TIMING_ENABLE)
#if (!WTI_CESOP_TDI)

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_203_CAD_E1_U_CR_NoCas_Two_Boards_N_Line_N_PW_Addremove_PW(char *StrPrm)
{
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR   ip_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 i;
   WP_CHAR exit_factor = '0';

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);
   memset(ip_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");

   /* clock recovery system config */

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mod"0 0 4 3"e */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */
#endif /* WTI_CLOCK_REC_MODE */


   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex] */
#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* set ufe Tx and Rx direction */
      sprintf(temp_buf, "0 %d 4 3",i);
#else
      /* set ufe Tx direction only */
      sprintf(temp_buf, "0 %d 4 1",i);
#endif

#else

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* differential mode timing only set ufe  Rx direction */
      sprintf(temp_buf, "0 %d 4 2",i);
#else
      /* no timing or adaptive mode */
      sprintf(temp_buf, "0 %d 4 0",i);
#endif

#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */

      CLI_F_UfeTransferMode(temp_buf);

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* Use shaper only in diff mode */
      /* Conect each line to its shaper */
      sprintf(temp_buf, "0 %d %d",i,i);

      CLI_F_UfeLineOctalClkShaperSet(temp_buf); /* line_index, trans_id */
#endif /* WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE */

   }
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<84; i++)
   {
      if (i<N_ACTIVE_UFE_OCT_LINES)
      {
         /* Set the defult PSN2TDM clock recoevry paramters */
         WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      }
   }
#endif


#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   CLI_F_UfeChipInitLineSetup("");

   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 32 32",i);
      CLI_F_PwConfigureUnframed(temp_buf);

      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 256");
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/
#if WTI_ENET_IEEE_802
      CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
      CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* Rx timing is used */
      sprintf(temp_buf, "0 1 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS),ts_diff_if_id(0-31)] */
#else
      /* Rx timing is not used */
      sprintf(temp_buf, "0 0 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS),ts_diff_if_id(0-31)] */
#endif


      /**************** PSN --> TDM Tx binding*****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* if clock recovery is set -> Tx timing is used */
      CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#else
      /* if clock recovery is disable -> Tx timing is not used */
      CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#endif
      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* CR master Rx and Tx direction */
      CLI_F_PwCreate("0 0 1 1"); /* CR master */
#else
      /* CR master Tx direction */
      CLI_F_PwCreate("0 0 0 1"); /* CR master */
#endif

      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_PwEnable(temp_buf);
#else
      /* no timing */
      CLI_F_PwCreate("0 0 0 0"); /* slave mode */
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_PwEnable(temp_buf);
#endif
   }
   /* make remove and re-create in loop */
   while (exit_factor != '9')
   {

      /* print CR parameters */
      /*CLI_F_Psn2TdmFlowAggShowInfo("0 0");*/
      printf("Test running.\nType '9' to quit or any other key to remove all PW and change CR parameters.\n");
      exit_factor = getchar();
      if (exit_factor == '9')
      {
         printf("typed '9', exit test\n");
      }
      else
      {

         /*CLI_F_Psn2TdmFlowAggShowInfo("0 0");
           getchar();*/

         /* remove PWs */
         printf("..:: Removing PW.\n");
         WP_Delay(100000); /*time in usec */

         for (i=N_ACTIVE_UFE_OCT_LINES; i>0; i--)
         {
            sprintf(temp_buf, "0 %d", i-1);
            CLI_F_PwRemove(temp_buf);
         }

         /* change CR parameters */
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
#if (!WTI_CLOCK_REC_MODE) /* working in adaptive mode */

         i = 0;
         /* First filter factor */
         the_system->clock_rec[i].direct_factor = 26;
         /* Second  filter factor */
         the_system->clock_rec[i].integration_factor = 33;
         /* The time in seconds between divisor updates */
         the_system->clock_rec[i].divisor_update_period = 2;

         printf("CR parameters changed. ");
#else
         printf("No change in CR parameters. ");
#endif /*CR mode */
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */
         printf("\nTest will recreate all PWs. Press any key to continue...\n");
         getchar();

         /* recreate PW in "old fasion way": just repeat the lines above */
         for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
         {
            sprintf(temp_buf, "0 %d 32 32",i);
            CLI_F_PwConfigureUnframed(temp_buf);

            /* PWE3 channel configuration */
            CLI_F_Pwe3ChannelJitterBufferSize("0 32");
            CLI_F_Pwe3ChannelRxBufferSize("0 256");
            CLI_F_Pwe3ChannelStatmode("0 1");
            CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
            CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
            CLI_F_Pwe3ChannelUdpDummyMode("0 1");
            CLI_F_Pwe3ChannelTxUdcas("0 f");

            /**************** TDM --> PSN IW *****************/
#if WTI_ENET_IEEE_802
            CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
            CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
            sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
            CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
            sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
            CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
            CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
            CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
            CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
            /* Rx timing is used */
            sprintf(temp_buf, "0 1 1 %d",i);
            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS),ts_diff_if_id(0-31)] */
#else
            /* Rx timing is not used */
            sprintf(temp_buf, "0 0 1 %d",i);
            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS),ts_diff_if_id(0-31)] */
#endif


            /**************** PSN --> TDM Tx binding*****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
            /* if clock recovery is set -> Tx timing is used */
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#else
            /* if clock recovery is disable -> Tx timing is not used */
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#endif
            CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
            CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
            /* CR master Rx and Tx direction */
            CLI_F_PwCreate("0 0 1 1"); /* CR master */
#else
            /* CR master Tx direction */
            CLI_F_PwCreate("0 0 0 1"); /* CR master */
#endif

            sprintf(temp_buf, "0 %d 1",i);
            CLI_F_PwEnable(temp_buf);
#else
            /* no timing */
            CLI_F_PwCreate("0 0 0 0"); /* slave mode */
            sprintf(temp_buf, "0 %d 0",i);
            CLI_F_PwEnable(temp_buf);
#endif
         }

         /* print CR parameters */
         /*printf("CR parameters:\n");
           CLI_F_Psn2TdmFlowAggShowInfo("0 0");*/
      } /*if exit_factor == '9' */
   } /* while (1) */

}

/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_204_CAD_T1_F_CR_NoCas_Two_Boards_8_Line_8_PW_one_CR_Master_addremove_PW(char *StrPrm)
{
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR   ip_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 i;
   WP_CHAR exit_factor = '0';

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);
   memset(ip_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");

   /* clock recovery system config */

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode "0 0 4 3" */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */
#endif /* WTI_CLOCK_REC_MODE */



   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */
#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE

      /* set ufe Tx and Rx direction */
      if (i == 0) /* line 0 use CR, all other don't */
         sprintf(temp_buf, "0 %d 1 3",i);
      else
         sprintf(temp_buf, "0 %d 1 0",i); /* line number >1 => don't use CR  */

#else
      /* set ufe Tx direction only */
      if (i == 0) /* line 0 use CR, all other don't */
         sprintf(temp_buf, "0 %d 1 1",i);
      else
         sprintf(temp_buf, "0 %d 1 0",i); /* line number >1 => don't use CR  */
#endif

#else

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* differential mode timing only set ufe  Rx direction */
      sprintf(temp_buf, "0 %d 1 2",i);
#else
      /* no timing or adaptive mode */
      sprintf(temp_buf, "0 %d 1 0",i);
#endif

#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */

      CLI_F_UfeTransferMode(temp_buf);

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* Use shaper only in diff mode */
      /* Conect each line to its shaper */
      sprintf(temp_buf, "0 %d %d",i,i);

      CLI_F_UfeLineOctalClkShaperSet(temp_buf); /* line_index, trans_id */
#endif /* WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE */
   }
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<84; i++)
   {
      if (i<N_ACTIVE_UFE_OCT_LINES)
      {
         /* Set the defult PSN2TDM clock recoevry paramters */
         WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      }
   }
#endif

#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */




#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   CLI_F_UfeChipInitLineSetup("");

   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 24 24 24 0-23",i);
      CLI_F_PwConfigureFramed(temp_buf);

      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 192");
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/
#if WTI_ENET_IEEE_802
      CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
      CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 d8 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* Rx timing is used */
      if (i == 0)   /* line 1 use CR, all other don't */
         sprintf(temp_buf, "0 1 1 %d",i);
      else
         sprintf(temp_buf, "0 0 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS),ts_diff_if_id(0-31)] */
#else
      /* Rx timing is not used */
      sprintf(temp_buf, "0 0 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS),ts_diff_if_id(0-31)] */
#endif

      /**************** PSN --> TDM IW *****************/

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* if clock recovery is set -> Tx timing is used */
      if (i == 0)    /* line 1 use CR, all other don't */
         CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
      else
         CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#else
      /* if clock recovery is disable -> Tx timing is not used */
      CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#endif
      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

      /**************** PSN --> TDM Tx binding*****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* CR master Rx and Tx direction */
      if (i == 0)   /* line 1 use CR, all other don't */
         CLI_F_PwCreate("0 0 1 1"); /* CR master */
      else
         CLI_F_PwCreate("0 0 0 0"); /* CR slave */
#else
      /* CR master Tx direction */
      if (i == 0)   /* line 1 use CR, all other don't */
         CLI_F_PwCreate("0 0 0 1"); /* CR master */
      else
         CLI_F_PwCreate("0 0 0 0"); /* CR slave */
#endif
      if (i == 0)
         sprintf(temp_buf, "0 %d 1",i); /* line 1 is the master, all other slaves */
      else
         sprintf(temp_buf, "0 %d 0",i);
      CLI_F_PwEnable(temp_buf);
#else
      /* no timing */
      CLI_F_PwCreate("0 0 0 0"); /* slave mode */
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_PwEnable(temp_buf);
#endif
   }
   /* add and remove PW loop */
   while(exit_factor != '9')
   {

      /* print CR parameters */
      /*CLI_F_Psn2TdmFlowAggShowInfo("0 2");*/
      printf("Test running.\nType '9' to quit or any other key to remove all PW and change CR parameters.\n");
      exit_factor = getchar();
      if (exit_factor == '9')
      {
         printf("Exit test\n");
      }
      else
      {
         /*CLI_F_Psn2TdmFlowAggShowInfo("0 7");
        getchar();*/

         /* remove PWs */
         printf("..:: Removing PW.\n");
         WP_Delay(500000);

         for (i=N_ACTIVE_UFE_OCT_LINES; i>0; i--)
         {
            sprintf(temp_buf, "0 %d", i-1);
            CLI_F_PwRemove(temp_buf);
         }

         /* change CR parameters */
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
#if (!WTI_CLOCK_REC_MODE) /* working in adaptive mode */

         i = 0;
         /* First filter factor */
         the_system->clock_rec[i].direct_factor = 26;
         /* Second  filter factor */
         the_system->clock_rec[i].integration_factor = 33;
         /* The time in seconds between divisor updates */
         the_system->clock_rec[i].divisor_update_period = 2;

         printf("CR parameters changed. ");
#else
         printf("No change in CR parameters. ");
#endif /* clock rec mode */
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */
         printf("\nTest will recreate all PWs. Press any key to continue...\n");
         getchar();

         /* recreate PW in "old fasion way": just repeat the lines above */
         for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
         {
            printf("..:: recreating PW %d...\n", i);
            WP_Delay(100000);

            sprintf(temp_buf, "0 %d 24 24 24 0-23",i);
            CLI_F_PwConfigureFramed(temp_buf);

            /* PWE3 channel configuration */
            CLI_F_Pwe3ChannelJitterBufferSize("0 32");
            CLI_F_Pwe3ChannelRxBufferSize("0 192");
            CLI_F_Pwe3ChannelStatmode("0 1");
            CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
            CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
            CLI_F_Pwe3ChannelUdpDummyMode("0 1");
            CLI_F_Pwe3ChannelTxUdcas("0 f");

            /**************** TDM --> PSN IW *****************/
#if WTI_ENET_IEEE_802
            CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
            CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
            sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
            CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
            sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
            CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
            CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 d8 0");
            CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
            CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
            /* Rx timing is used */
            if (i == 0)   /* line 1 use CR, all other don't */
               sprintf(temp_buf, "0 1 1 %d",i);
            else
               sprintf(temp_buf, "0 0 1 %d",i);
            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS),ts_diff_if_id(0-31)] */
#else
            /* Rx timing is not used */
            sprintf(temp_buf, "0 0 1 %d",i);
            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS),ts_diff_if_id(0-31)] */
#endif

            /**************** PSN --> TDM IW *****************/

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
            /* if clock recovery is set -> Tx timing is used */
            if (i == 0)    /* line 1 use CR, all other don't */
               CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
            else
               CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#else
            /* if clock recovery is disable -> Tx timing is not used */
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#endif
            CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
            CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

            /**************** PSN --> TDM Tx binding*****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
            /* CR master Rx and Tx direction */
            if (i == 0)   /* line 1 use CR, all other don't */
               CLI_F_PwCreate("0 0 1 1"); /* CR master */
            else
               CLI_F_PwCreate("0 0 0 0"); /* CR slave */
#else
            /* CR master Tx direction */
            if (i == 0)   /* line 1 use CR, all other don't */
               CLI_F_PwCreate("0 0 0 1"); /* CR master */
            else
               CLI_F_PwCreate("0 0 0 0"); /* CR slave */
#endif
            if (i == 0)
               sprintf(temp_buf, "0 %d 1",i); /* line 1 is the master, all other slaves */
            else
               sprintf(temp_buf, "0 %d 0",i);
            CLI_F_PwEnable(temp_buf);
#else
            /* no timing */
            CLI_F_PwCreate("0 0 0 0"); /* slave mode */
            sprintf(temp_buf, "0 %d 0",i);
            CLI_F_PwEnable(temp_buf);
#endif
         }
         /* print CR parameters */
         printf("CR parameters:\n");
         CLI_F_Psn2TdmFlowAggShowInfo("0 2");

      } /*if exit_factor == '9' */
   } /* while */
}

#if WTI_CESOP_TO_MPLS_FA_CASCADING
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_205_CAD_E1_U_CR_NoCas_Mpls_Cascading(char *StrPrm)
{
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR   ip_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 i;

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);
   memset(ip_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");

   /* clock recovery system config */

   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");

   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex] */
#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* set ufe Tx and Rx direction */
      sprintf(temp_buf, "0 %d 4 3",i);
#else
      /* set ufe Tx direction only */
      sprintf(temp_buf, "0 %d 4 1",i);
#endif
      CLI_F_UfeTransferMode(temp_buf);


#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* Use shaper only in diff mode */
      /* Conect each line to its shaper */
      sprintf(temp_buf, "0 %d %d",i,i);

      CLI_F_UfeLineOctalClkShaperSet(temp_buf); /* line_index, trans_id */
#endif /* WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE */

   }
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   CLI_F_UfeChipInitLineSetup("");

   /* configure the clock recovery parameters */
   for (i=0; i<84; i++)
   {
      if (i<N_ACTIVE_UFE_OCT_LINES)
      {
         /* Set the defult PSN2TDM clock recoevry paramters */
         WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      }
   }

#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif



   /* ------------------- Creating the MPLS L2 router flow aggregations in both directions */
   for (i=0;i<WTI_MAX_NUM_OF_MPLS_FA;++i)
   {
#if WTI_CESOP_MPLS_OVER_ENET
      /* create the l2 router MPLS flow aggregations */
      CLI_F_Tdm2PsnFlowAggEnetHeaderMpls("0 aa aa aa aa aa aa bb bb bb bb bb bb 8847");
      CLI_F_MplsFlowAggPrefixLength("0 14");
      sprintf(temp_buf,
              "0 %x %x %x %x %x %x",
              3*i,
              3*i+1,
              3*i+2,
              (0x88470000 | ((((WTI_MPLS_LABEL) >> 12) + WTI_MAX_PW + 1 + i) >> 4)),
              ((((((WTI_MPLS_LABEL) >> 12)  + WTI_MAX_PW + 1 + i) & 0xff) << 28) | 0x00ff0000),
              0);
      /*                              [mac destination] [mac source] [vlan] [type] [mpls header] */
      CLI_F_MplsFlowAggPrefixHeaderMpls(temp_buf);

      mpls_layer2_agg_cfg.txfunc = the_system->tx_enet_channel;

      sprintf(temp_buf, "0 %d", 0); /* remark offsets for VLAN priority and PSN tunnel EXP bits */

      CLI_F_MplsFlowAggRemarkingOffsets(temp_buf);
      sprintf(temp_buf, "0 %d", i);
      CLI_F_MplsFlowAggCreate(temp_buf);
#else
#if WTI_CESOP_NATIVE_MPLS_IW
      /* create the l2 router MPLS flow aggregations */
      CLI_F_MplsFlowAggPrefixLength("0 0");
      sprintf(temp_buf,
              "0 %x",
              (((((WTI_MPLS_LABEL) >> 12) + WTI_MAX_PW + 1 + i) << 12) | 0xff));
      /*                              [mpls header] */
      CLI_F_MplsFlowAggPrefixHeaderMpls(temp_buf);
      sprintf(temp_buf, "0 %d %d", 1, 5); /* remark offsets for PSN tunnel EXP bits */

      CLI_F_MplsFlowAggRemarkingOffsets(temp_buf);
      sprintf(temp_buf, "0 %d", i);
      CLI_F_MplsFlowAggCreate(temp_buf);
#else
      /* create the l2 router MPLS flow aggregations */
      CLI_F_MplsFlowAggPrefixLength("0 4");
      sprintf(temp_buf,
              "0 %x %x",
              WTI_MPLSoPPP,
              (((((WTI_MPLS_LABEL) >> 12) + WTI_MAX_PW + 1 + i) << 12) | 0xff));
      /*                              [ppp] [mpls header] */
      CLI_F_MplsFlowAggPrefixHeaderMpls(temp_buf);
      sprintf(temp_buf, "0 %d %d", 1, 13); /* remark offsets for PSN tunnel EXP bits */

      CLI_F_MplsFlowAggRemarkingOffsets(temp_buf);
      sprintf(temp_buf, "0 %d", i);
      CLI_F_MplsFlowAggCreate(temp_buf);
#endif /* WTI_CESOP_NATIVE_MPLS_IW */
#endif /* WTI_CESOP_MPLS_OVER_ENET */
   }



   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 32 32",i);
      CLI_F_PwConfigureUnframed(temp_buf);

      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 256");
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/
#if WTI_ENET_IEEE_802
      CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
      CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* Rx timing is used */
      sprintf(temp_buf, "0 1 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS),ts_diff_if_id(0-31)] */
#else
      /* Rx timing is not used */
      sprintf(temp_buf, "0 0 1 %d",i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS),ts_diff_if_id(0-31)] */
#endif


      /**************** PSN --> TDM Tx binding*****************/
      /* if clock recovery is set -> Tx timing is used */
      CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");




#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* CR master Rx and Tx direction */
      sprintf(temp_buf, "0 %d %d %d %d %d", 0,1,1,0,i);
      CLI_F_PwCreateCascaded(temp_buf);
#else
      /* CR master Tx direction */
      sprintf(temp_buf, "0 %d %d %d %d %d", 0,0,1,0,i);
      CLI_F_PwCreateCascaded(temp_buf);

#endif

      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_PwEnable(temp_buf);
   }
}
#endif /* #if WTI_CESOP_TO_MPLS_FA_CASCADING */

#endif /*!(WTI_CESOP_TDI)*/
#endif /* end of WTI_CESOP_CLOCK_RECOVERY_ENABLE */

/*-----------------------------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------------------------*/
/*----------------------------- End of Clock recovery tests section 3 ---------------------------*/
/*-----------------------------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------------------------*/

#if (!WTI_CESOP_TDI) /* endif is at the end of the file */
/*-----------------------------------------------------------------------------------------------*/
/*-----------------------------  Clock recovery tests section 4 ---------------------------------*/
/* All following Clock Recovery SBI Over UFE tests can work with RX,TX,BOTH,NON Timing options   */
/*-----------------------------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------------------------*/

/********************************************************************************************
 * Description:
 *            N = "global_active_cr_async_mode"
 * TDM2PSN :  The test uses N CD for the first N PWs (in this case PW = line)
 *            each CD uses different shaper. All pws > N are using the first shaper.
 * PSN2TDM :  The first  lines -  0...N-1 are conected to CT#0..N-1
 *            Line N...63 are conected to CT#0
 *
 * The test can run upto 63 lines (all use same PS and DUS)
 *
 *******************************************************************************************/

void CLI_F_101_103_SBI_E1_U_CR_NoCas_Two_Boards_N_CD_N_CT_63_Line_63_PW(char *StrPrm)
{
   WP_U32 i, j, line_index, spe_index, timing_index, pw_index;
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   WP_U8   clock_rec_lines[336] = {0}; /* list of master lines */

   /* Set the CR lines (both for RX and TX direction */
#if (WTI_CESOP_RX_TIMING_ENABLE || WTI_CESOP_CLOCK_RECOVERY_ENABLE)
   for (i=0; i< global_active_cr_async_mode; i++)
   {/* Set lines to be CR master */
      clock_rec_lines[CLI_F_AttacheLineToPwNumber(i)] = 1;
   }
#endif

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE||WTI_CESOP_RX_TIMING_ENABLE)
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE || WTI_CESOP_RX_TIMING_ENABLE */

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)

      {
         line_index = i*28 + j;
         timing_index = i*WTI_E1_LINES_PER_SPE + j;

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 4 3",line_index);
#else
            /* set ufe Tx direction only */
            sprintf(temp_buf, "0 %d 4 1",line_index);
#endif

#else /* Not WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Rx direction only */
            sprintf(temp_buf, "0 %d 4 2",line_index);
#endif

#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */
         }
         else
         {
#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Rx direction only - for all lines */
            sprintf(temp_buf, "0 %d 4 2",line_index);
#else
            sprintf(temp_buf, "0 %d 4 0",line_index); /* line doesn't use CR on any direction */
#endif
         }

         CLI_F_UfeTransferMode(temp_buf);

         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, timing_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */
#endif /* end of WTI_CESOP_CLOCK_RECOVERY_ENABLE*/
#if WTI_CESOP_RX_TIMING_ENABLE
         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, timing_index);
         }
         else
         {
            /* conect all others to the first line */
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */

#endif
      }
   }
   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 2");

   CLI_F_UfeChipInitLineSetup("");
   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }
#endif

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_E1_LINES_PER_SPE + j;

         sprintf(temp_buf, "0 %d 64 64", line_index);/* The line index of this PW */
         CLI_F_PwConfigureUnframed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 256");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
         /* Rx timing is used in differential mode */
         /* first global_active_cr_async_mode related to different CDs */
         if (pw_index < global_active_cr_async_mode)
         {
            sprintf(temp_buf, "0 1 1 %d",pw_index);
         }
         else
         {
            /* In differential mode all other pw (not first ones) uses CD#0 */
            sprintf(temp_buf, "0 1 1 0");
         }

         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
         /* Rx timing is not used */
         sprintf(temp_buf, "0 0 1 %d",pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

         /**************** PSN --> TDM IW *****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* if clock recovery is set -> Tx timing is used */
         if (pw_index < global_active_cr_async_mode)  /* PW 0-7 use CR, all other don't */
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#else
         /* if clock recovery is disable -> Tx timing is not used */
         CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#endif
         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");
         CLI_F_Psn2TdmTxBinLOPSDetection("0 1 6 4");

         /**************** PSN --> TDM Tx binding*****************/

         /* The First global_active_cr_async_mode PWs use CR, all other don't */

         if (pw_index < global_active_cr_async_mode)
         {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE

#if WTI_CESOP_RX_TIMING_ENABLE
            /* CR master Rx and Tx direction */
            CLI_F_PwCreate("0 0 1 1"); /* CR master */
#else
            /* CR master Tx direction */
            CLI_F_PwCreate("0 0 0 1"); /* CR master */
#endif

#else /* not  WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
            /* CR master Rx  direction only */
            CLI_F_PwCreate("0 0 1 0"); /* CR master */
#endif
#endif
            sprintf(temp_buf, "0 %d 1",pw_index);
         }
         else
         {  /* Not TX CR PW */
#if WTI_CESOP_RX_TIMING_ENABLE
            /* Set all PW IN rx to work in shapping mode */
            CLI_F_PwCreate("0 0 1 0"); /* CR master */
#else
            CLI_F_PwCreate("0 0 0 0");
#endif

            sprintf(temp_buf, "0 %d 0",pw_index);
         }
         CLI_F_PwEnable(temp_buf);

      } /* end for (configure each line) */
   }
}

/********************************************************************************************
 * Description:
 *            N = "global_active_cr_async_mode"
 * TDM2PSN :  The test uses N CD for the first N PWs (in this case PW = line)
 *            each CD uses different shaper. All pws > N are using the first shaper.
 * PSN2TDM :  The first  lines -  0...N-1 are conected to CT#0..N-1
 *            Line N...84 are conected to CT#0
 *
 * The test can run upto 84 lines (all use same PS and DUS)
 *
 *******************************************************************************************/

void CLI_F_101_103_SBI_T1_U_CR_NoCas_Two_Boards_N_CD_N_CT_84_Line_84_PW(char *StrPrm)
{
   WP_U32 i, j, line_index, spe_index, pw_index;
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U8   clock_rec_lines[336] = {0}; /* list of master lines */

   /* Set the CR lines (both for RX and TX direction */
#if (WTI_CESOP_RX_TIMING_ENABLE || WTI_CESOP_CLOCK_RECOVERY_ENABLE)
   for (i=0; i< global_active_cr_async_mode; i++)
   {
      clock_rec_lines[i] = 1;         /* Set lines to be CR master */
   }
#endif

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE||WTI_CESOP_RX_TIMING_ENABLE)
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE || WTI_CESOP_RX_TIMING_ENABLE */


   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 2 3",line_index);
#else
            /* set ufe Tx direction only */
            sprintf(temp_buf, "0 %d 2 1",line_index);
#endif

#else /* Not WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Rx direction only */
            sprintf(temp_buf, "0 %d 2 2",line_index);
#endif

#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */
         }
         else
         {
#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Rx direction only - for all lines */
            sprintf(temp_buf, "0 %d 2 2",line_index);
#else
            sprintf(temp_buf, "0 %d 2 0",line_index); /* line doesn't use CR on any direction */
#endif
         }

         CLI_F_UfeTransferMode(temp_buf);

         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, line_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */
#endif /* end of WTI_CESOP_CLOCK_RECOVERY_ENABLE*/
#if WTI_CESOP_RX_TIMING_ENABLE
         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, line_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
#endif

      }

   }

   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 0");

   CLI_F_UfeChipInitLineSetup("");

   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }
#endif

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif

#endif
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_T1_LINES_PER_SPE + j;

         sprintf(temp_buf, "0 %d 48 48", line_index);/* The line index of this PW */
         CLI_F_PwConfigureUnframed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 384");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 198 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
         /* Rx timing is used in differential mode */
         /* first global_active_cr_async_mode related to different CDs */
         if (pw_index < global_active_cr_async_mode)
         {
            sprintf(temp_buf, "0 1 1 %d",pw_index);
         }
         else
         {
            /* In differential mode all other pw (not first ones) uses CD#0 */
            sprintf(temp_buf, "0 1 1 0");
         }

         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
         /* Rx timing is not used */
         sprintf(temp_buf, "0 0 1 %d",pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif
         /**************** PSN --> TDM IW *****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* if clock recovery is set -> Tx timing is used */
         if (pw_index < global_active_cr_async_mode)  /* PW 0-7 use CR, all other don't */
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#else
         /* if clock recovery is disable -> Tx timing is not used */
         CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#endif
         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/

         /* ------------------------------- Create and Enable all PWs  --------------------------------------- */
         /* The First global_active_cr_async_mode PWs use CR, all other don't */

         if (pw_index < global_active_cr_async_mode)
         {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE

#if WTI_CESOP_RX_TIMING_ENABLE
            /* CR master Rx and Tx direction */
            CLI_F_PwCreate("0 0 1 1"); /* CR master */
#else
            /* CR master Tx direction */
            CLI_F_PwCreate("0 0 0 1"); /* CR master */
#endif

#else /* not  WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
            /* CR master Rx  direction only */
            CLI_F_PwCreate("0 0 1 0"); /* CR master */
#endif
#endif
            sprintf(temp_buf, "0 %d 1",pw_index);
         }
         else
         {  /* Not TX CR PW */
#if WTI_CESOP_RX_TIMING_ENABLE
            /* Set all PW IN rx to work in shapping mode */
            CLI_F_PwCreate("0 0 1 0"); /* CR master */
#else
            CLI_F_PwCreate("0 0 0 0");
#endif

            sprintf(temp_buf, "0 %d 0",pw_index);
         }
         CLI_F_PwEnable(temp_buf);
      } /* end for (configure each line) */
   }
}
/********************************************************************************************
 * Description:
 *            N = "global_active_cr_async_mode"
 * TDM2PSN :  The test uses N CD for the first N PWs (in this case PW = line)
 *            each CD uses different shaper. All pws > N are using the first shaper.
 * PSN2TDM :  The first  lines -  0...N-1 are conected to CT#0..N-1
 *            Line N...63 are conected to CT#0
 *
 * The test can run upto 63 lines (all use same PS and DUS)
 *
 *******************************************************************************************/
void CLI_F_101_103_SBI_E1_F_CR_NoCas_Two_Boards_N_CD_N_CT_63_Line_63_PW(char *StrPrm)
{
   WP_U32 i, j, line_index, spe_index, timing_index, pw_index;
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U8   clock_rec_lines[336] = {0}; /* list of master lines */

   /* Set the CR lines (both for RX and TX direction */
#if (WTI_CESOP_RX_TIMING_ENABLE || WTI_CESOP_CLOCK_RECOVERY_ENABLE)
   for (i=0; i< global_active_cr_async_mode; i++)
   {/* Set lines to be CR master */
      clock_rec_lines[CLI_F_AttacheLineToPwNumber(i)] = 1;
   }
#endif

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }


   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE||WTI_CESOP_RX_TIMING_ENABLE)
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE || WTI_CESOP_RX_TIMING_ENABLE */

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         timing_index = i*WTI_E1_LINES_PER_SPE + j;

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 3 3",line_index);
#else
            /* set ufe Tx direction only */
            sprintf(temp_buf, "0 %d 3 1",line_index);
#endif

#else /* Not WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Rx direction only */
            sprintf(temp_buf, "0 %d 3 2",line_index);
#endif

#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */
         }
         else
         {
#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Rx direction only - for all lines */
            sprintf(temp_buf, "0 %d 3 2",line_index);
#else
            sprintf(temp_buf, "0 %d 3 0",line_index); /* line doesn't use CR on any direction */
#endif
         }
         CLI_F_UfeTransferMode(temp_buf);

         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, timing_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */
#endif /* end of WTI_CESOP_CLOCK_RECOVERY_ENABLE*/
#if WTI_CESOP_RX_TIMING_ENABLE
         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, timing_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
#endif

      }
   }


   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 3");

   CLI_F_UfeChipInitLineSetup("");

   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }
#endif

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_E1_LINES_PER_SPE + j;

         sprintf(temp_buf, "0 %d 64 64 32 0-31", line_index);/* The line index of this PW */
         CLI_F_PwConfigureFramed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 256");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
         /* Rx timing is used in differential mode */
         /* first global_active_cr_async_mode related to different CDs */
         if (pw_index < global_active_cr_async_mode)
         {
            sprintf(temp_buf, "0 1 1 %d",pw_index);
         }
         else
         {
            /* In differential mode all other pw (not first ones) uses CD#0 */
            sprintf(temp_buf, "0 1 1 0");
         }

         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
         /* Rx timing is not used */
         sprintf(temp_buf, "0 0 1 %d",pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

         /**************** PSN --> TDM IW *****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* if clock recovery is set -> Tx timing is used */
         if (pw_index < global_active_cr_async_mode)
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#else
         /* if clock recovery is disable -> Tx timing is not used */
         CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#endif
         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/
         /* ------------------------------- Create and Enable all PWs  --------------------------------------- */
         /* The First global_active_cr_async_mode PWs use CR, all other don't */

         if (pw_index < global_active_cr_async_mode)
         {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE

#if WTI_CESOP_RX_TIMING_ENABLE
            /* CR master Rx and Tx direction */
            CLI_F_PwCreate("0 0 1 1"); /* CR master */
#else
            /* CR master Tx direction */
            CLI_F_PwCreate("0 0 0 1"); /* CR master */
#endif

#else /* not  WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
            /* CR master Rx  direction only */
            CLI_F_PwCreate("0 0 1 0"); /* CR master */
#endif
#endif
            sprintf(temp_buf, "0 %d 1",pw_index);
         }
         else
         {  /* Not TX CR PW */
#if WTI_CESOP_RX_TIMING_ENABLE
            /* Set all PW IN rx to work in shapping mode */
            CLI_F_PwCreate("0 0 1 0"); /* CR master */
#else
            CLI_F_PwCreate("0 0 0 0");
#endif

            sprintf(temp_buf, "0 %d 0",pw_index);
         }
         CLI_F_PwEnable(temp_buf);
      } /* end for (configure each line) */
   }
}
/********************************************************************************************
 * Description:
 *            N = "global_active_cr_async_mode"
 * TDM2PSN :  The test uses N CD for the first N PWs (in this case PW = line)
 *            each CD uses different shaper. All pws > N are using the first shaper.
 * PSN2TDM :  The first  lines -  0...N-1 are conected to CT#0..N-1
 *            Line N...84 are conected to CT#0
 *
 * The test can run upto 84 lines (all use same PS and DUS)
 *
 *******************************************************************************************/
void CLI_F_101_103_SBI_T1_F_CR_NoCas_Two_Boards_N_CD_N_CT_84_Line_84_PW(char *StrPrm)
{
   WP_U32 i, j, line_index, spe_index, pw_index;
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U8   clock_rec_lines[336] = {0}; /* list of master lines */

   /* Set the CR lines (both for RX and TX direction */
#if (WTI_CESOP_RX_TIMING_ENABLE || WTI_CESOP_CLOCK_RECOVERY_ENABLE)
   for (i=0; i< global_active_cr_async_mode; i++)
   {
      clock_rec_lines[i] = 1;         /* Set lines to be CR master */
   }
#endif

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }


   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE||WTI_CESOP_RX_TIMING_ENABLE)
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE || WTI_CESOP_RX_TIMING_ENABLE */

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 1 3",line_index);
#else
            /* set ufe Tx direction only */
            sprintf(temp_buf, "0 %d 1 1",line_index);
#endif

#else /* Not WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Rx direction only */
            sprintf(temp_buf, "0 %d 1 2",line_index);
#endif

#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */
         }
         else
         {
#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Rx direction only - for all lines */
            sprintf(temp_buf, "0 %d 1 2",line_index);
#else
            sprintf(temp_buf, "0 %d 1 0",line_index); /* line doesn't use CR on any direction */
#endif
         }

         CLI_F_UfeTransferMode(temp_buf);

         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, line_index);
         }
         else
            /* conect all others to the first line */
         {
            if (line_index < 168)
               sprintf(temp_buf, "0 %d 0", line_index);
            else
               sprintf(temp_buf, "0 %d 1", line_index);
         }

         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */
#endif /* end of WTI_CESOP_CLOCK_RECOVERY_ENABLE*/
#if WTI_CESOP_RX_TIMING_ENABLE
         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, line_index);
         }
         else
            /* conect all others to the first line */
         {
            if (line_index < 168)
               sprintf(temp_buf, "0 %d 0", line_index);
            else
               sprintf(temp_buf, "0 %d 1", line_index);
         }

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
#endif

      }
   }


   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 1");

   CLI_F_UfeChipInitLineSetup("");
   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }
#endif

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_T1_LINES_PER_SPE + j;

         sprintf(temp_buf, "0 %d 48 48 24 0-23", line_index);/* The line index of this PW */
         CLI_F_PwConfigureFramed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 384");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 198 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
         /* Rx timing is used in differential mode */
         /* first global_active_cr_async_mode related to different CDs */
         if (pw_index < global_active_cr_async_mode)
         {
            sprintf(temp_buf, "0 1 1 %d",pw_index);
         }
         else
         {
            /* In differential mode all other pw (not first ones) uses CD#0 */
            sprintf(temp_buf, "0 1 1 0");
         }

         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
         /* Rx timing is not used */
         sprintf(temp_buf, "0 0 1 %d",pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

         /**************** PSN --> TDM IW *****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* if clock recovery is set -> Tx timing is used */
         if (pw_index < global_active_cr_async_mode)  /* PW 0-7 use CR, all other don't */
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#else
         /* if clock recovery is disable -> Tx timing is not used */
         CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#endif
         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/

         /* The First global_active_cr_async_mode PWs use CR, all other don't */

         if (pw_index < global_active_cr_async_mode)
         {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE

#if WTI_CESOP_RX_TIMING_ENABLE
            /* CR master Rx and Tx direction */
            CLI_F_PwCreate("0 0 1 1"); /* CR master */
#else
            /* CR master Tx direction */
            CLI_F_PwCreate("0 0 0 1"); /* CR master */
#endif

#else /* not  WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
            /* CR master Rx  direction only */
            CLI_F_PwCreate("0 0 1 0"); /* CR master */
#endif
#endif
            sprintf(temp_buf, "0 %d 1",pw_index);
         }
         else
         {  /* Not TX CR PW */
#if WTI_CESOP_RX_TIMING_ENABLE
            /* Set all PW IN rx to work in shapping mode */
            CLI_F_PwCreate("0 0 1 0"); /* CR master */
#else
            CLI_F_PwCreate("0 0 0 0");
#endif

            sprintf(temp_buf, "0 %d 0",pw_index);
         }
         CLI_F_PwEnable(temp_buf);

      } /* end for (configure each line) */
   }
}

/********************************************************************************************
 * Description:
 *            N = "global_active_cr_async_mode"
 * TDM2PSN :  The test uses N CD for the first N PWs (in this case PW = line)
 *            each CD uses different shaper. All pws > N are using the first shaper.
 * PSN2TDM :  The first  lines -  0...N-1 are conected to CT#0..N-1
 *            Line N...251 are conected to CT#0
 *
 * The test can run upto 63 lines (all use same PS and DUS)
 * The perpose of this test is to verify fix in UFE3 synthesis: tx_buffer_size is 14 bits
 *  and not 12 bits.
 *
 *******************************************************************************************/
void CLI_F_101_103_SBI_E1_F_1xDS0_CR_NoCas_Two_Boards_N_CD_N_CT_252_Line_252_PW(char *StrPrm)
{
   WP_U32 i, j, line_index, spe_index, timing_index, pw_index;
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U8   clock_rec_lines[336] = {0}; /* list of master lines */

   /* Set the CR lines (both for RX and TX direction */
#if (WTI_CESOP_RX_TIMING_ENABLE || WTI_CESOP_CLOCK_RECOVERY_ENABLE)
   for (i=0; i< global_active_cr_async_mode; i++)
   {/* Set lines to be CR master */
      clock_rec_lines[CLI_F_AttacheLineToPwNumber(i)] = 1;
   }
#endif

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }


   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE||WTI_CESOP_RX_TIMING_ENABLE)
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE || WTI_CESOP_RX_TIMING_ENABLE */

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         timing_index = i*WTI_E1_LINES_PER_SPE + j;

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 3 3",line_index);
#else
            /* set ufe Tx direction only */
            sprintf(temp_buf, "0 %d 3 1",line_index);
#endif

#else /* Not WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Rx direction only */
            sprintf(temp_buf, "0 %d 3 2",line_index);
#endif

#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */
         }
         else
         {
#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Rx direction only - for all lines */
            sprintf(temp_buf, "0 %d 3 2",line_index);
#else
            sprintf(temp_buf, "0 %d 3 0",line_index); /* line doesn't use CR on any direction */
#endif
         }
         CLI_F_UfeTransferMode(temp_buf);

         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, timing_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */
#endif /* end of WTI_CESOP_CLOCK_RECOVERY_ENABLE*/
#if WTI_CESOP_RX_TIMING_ENABLE
         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, timing_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
#endif

      }
   }


   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 3");

   CLI_F_UfeChipInitLineSetup("");

   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }
#endif

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_E1_LINES_PER_SPE + j;

         sprintf(temp_buf, "0 %d 32 32 1 31", line_index);/* The line index of this PW */
         CLI_F_PwConfigureFramed(temp_buf); /* tx_buffer_size=DU*256/#slots=32*256/1= 0x2000*/

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 256");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
         /* Rx timing is used in differential mode */
         /* first global_active_cr_async_mode related to different CDs */
         if (pw_index < global_active_cr_async_mode)
         {
            sprintf(temp_buf, "0 1 1 %d",pw_index);
         }
         else
         {
            /* In differential mode all other pw (not first ones) uses CD#0 */
            sprintf(temp_buf, "0 1 1 0");
         }

         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
         /* Rx timing is not used */
         sprintf(temp_buf, "0 0 1 %d",pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

         /**************** PSN --> TDM IW *****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* if clock recovery is set -> Tx timing is used */
         if (pw_index < global_active_cr_async_mode)
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#else
         /* if clock recovery is disable -> Tx timing is not used */
         CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#endif
         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/
         /* ------------------------------- Create and Enable all PWs  --------------------------------------- */
         /* The First global_active_cr_async_mode PWs use CR, all other don't */

         if (pw_index < global_active_cr_async_mode)
         {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE

#if WTI_CESOP_RX_TIMING_ENABLE
            /* CR master Rx and Tx direction */
            CLI_F_PwCreate("0 0 1 1"); /* CR master */
#else
            /* CR master Tx direction */
            CLI_F_PwCreate("0 0 0 1"); /* CR master */
#endif

#else /* not  WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
            /* CR master Rx  direction only */
            CLI_F_PwCreate("0 0 1 0"); /* CR master */
#endif
#endif
            sprintf(temp_buf, "0 %d 1",pw_index);
         }
         else
         {  /* Not TX CR PW */
#if WTI_CESOP_RX_TIMING_ENABLE
            /* Set all PW IN rx to work in shapping mode */
            CLI_F_PwCreate("0 0 1 0"); /* CR master */
#else
            CLI_F_PwCreate("0 0 0 0");
#endif

            sprintf(temp_buf, "0 %d 0",pw_index);
         }
         CLI_F_PwEnable(temp_buf);
      } /* end for (configure each line) */
   }
}
/********************************************************************************************
 * Description:
 *            N = "global_active_cr_async_mode"
 * TDM2PSN :  The test uses N CD for the first N PWs (in this case PW = line)
 *            each CD uses different shaper. All pws > N are using the first shaper.
 * PSN2TDM :  The first  lines -  0...N-1 are conected to CT#0..N-1
 *            Line N...335 are conected to CT#0
 *
 * The test can run upto 336 lines (all use same PS and DUS)
 * The perpose of this test is to verify fix in UFE3 synthesis: tx_buffer_size is 14 bits
 *  and not 12 bits.
 *
 *******************************************************************************************/
void CLI_F_101_103_SBI_T1_F_1xDS0_CR_NoCas_Two_Boards_N_CD_N_CT_336_Line_336_PW(char *StrPrm)
{
   WP_U32 i, j, line_index, spe_index, pw_index;
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U8   clock_rec_lines[336] = {0}; /* list of master lines */

   /* Set the CR lines (both for RX and TX direction */
#if (WTI_CESOP_RX_TIMING_ENABLE || WTI_CESOP_CLOCK_RECOVERY_ENABLE)
   for (i=0; i< global_active_cr_async_mode; i++)
   {
      clock_rec_lines[i] = 1;         /* Set lines to be CR master */
   }
#endif

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }


   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE||WTI_CESOP_RX_TIMING_ENABLE)
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE || WTI_CESOP_RX_TIMING_ENABLE */

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 1 3",line_index);
#else
            /* set ufe Tx direction only */
            sprintf(temp_buf, "0 %d 1 1",line_index);
#endif

#else /* Not WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Rx direction only */
            sprintf(temp_buf, "0 %d 1 2",line_index);
#endif

#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */
         }
         else
         {
#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Rx direction only - for all lines */
            sprintf(temp_buf, "0 %d 1 2",line_index);
#else
            sprintf(temp_buf, "0 %d 1 0",line_index); /* line doesn't use CR on any direction */
#endif
         }

         CLI_F_UfeTransferMode(temp_buf);

         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, line_index);
         }
         else
            /* conect all others to the first line */
         {
            if (line_index < 168)
               sprintf(temp_buf, "0 %d 0", line_index);
            else
               sprintf(temp_buf, "0 %d 1", line_index);
         }

         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */
#endif /* end of WTI_CESOP_CLOCK_RECOVERY_ENABLE*/
#if WTI_CESOP_RX_TIMING_ENABLE
         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, line_index);
         }
         else
            /* conect all others to the first line */
         {
            if (line_index < 168)
               sprintf(temp_buf, "0 %d 0", line_index);
            else
               sprintf(temp_buf, "0 %d 1", line_index);
         }

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
#endif

      }
   }


   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 1");

   CLI_F_UfeChipInitLineSetup("");
   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }
#endif

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_T1_LINES_PER_SPE + j;

         sprintf(temp_buf, "0 %d 24 24 1 1", line_index);/* The line index of this PW */
         CLI_F_PwConfigureFramed(temp_buf); /* tx_buffer_size=DU*193/#slots=24*193/1= 0x1218*/

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 384");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 198 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
         /* Rx timing is used in differential mode */
         /* first global_active_cr_async_mode related to different CDs */
         if (pw_index < global_active_cr_async_mode)
         {
            sprintf(temp_buf, "0 1 1 %d",pw_index);
         }
         else
         {
            /* In differential mode all other pw (not first ones) uses CD#0 */
            sprintf(temp_buf, "0 1 1 0");
         }

         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
         /* Rx timing is not used */
         sprintf(temp_buf, "0 0 1 %d",pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

         /**************** PSN --> TDM IW *****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* if clock recovery is set -> Tx timing is used */
         if (pw_index < global_active_cr_async_mode)  /* PW 0-7 use CR, all other don't */
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#else
         /* if clock recovery is disable -> Tx timing is not used */
         CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#endif
         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/

         /* The First global_active_cr_async_mode PWs use CR, all other don't */

         if (pw_index < global_active_cr_async_mode)
         {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE

#if WTI_CESOP_RX_TIMING_ENABLE
            /* CR master Rx and Tx direction */
            CLI_F_PwCreate("0 0 1 1"); /* CR master */
#else
            /* CR master Tx direction */
            CLI_F_PwCreate("0 0 0 1"); /* CR master */
#endif

#else /* not  WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
            /* CR master Rx  direction only */
            CLI_F_PwCreate("0 0 1 0"); /* CR master */
#endif
#endif
            sprintf(temp_buf, "0 %d 1",pw_index);
         }
         else
         {  /* Not TX CR PW */
#if WTI_CESOP_RX_TIMING_ENABLE
            /* Set all PW IN rx to work in shapping mode */
            CLI_F_PwCreate("0 0 1 0"); /* CR master */
#else
            CLI_F_PwCreate("0 0 0 0");
#endif

            sprintf(temp_buf, "0 %d 0",pw_index);
         }
         CLI_F_PwEnable(temp_buf);

      } /* end for (configure each line) */
   }
}

/*-----------------------------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------------------------*/
/*----------------------------- End of Clock recovery tests section 4 ---------------------------*/
/*-----------------------------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------*/
/*-----------------------------  Clock recovery tests section 5 ----------------------------------------*/
/* All following Clock Recovery SBI Over UFE tests are define to work with TX & RX CR enable bitS only  */
/*------------------------------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------------------------------*/

#if (WTI_CESOP_RX_TIMING_ENABLE && WTI_CESOP_CLOCK_RECOVERY_ENABLE) /* endif at end of test (section 6) */

/********************************************************************************************
 * Description:
 *            N = "global_active_cr_async_mode"
 * TDM2PSN :  The test uses one CD in all PW (in this case PW = line) are using the same
 *            shaper (conected to the first one).
 * PSN2TDM :  The first N lines -  0...N-1 are conected to CT#0..N-1
 *            Line N...63 are conected to CT#0
 *            The distribution of the CD buy more the one PW is tested.
 *
 * The test can run upto 63 lines (all use same PS and DUS)
 *
 *******************************************************************************************/
void CLI_F_102_SBI_E1_U_CR_NoCas_Two_Boards_1_CD_N_CT_63_Line_63_PW(char *StrPrm)
{
   WP_U32 i, j, line_index, spe_index, timing_index, pw_index;
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   WP_U8   clock_rec_lines[336] = {0}; /* list of Tx master lines */
   WP_U8   clock_rec_pw[336] = {0}; /* list of master PWs */

   /* Set the CR lines and PWs TX direction */
   for (i=0; i< global_active_cr_async_mode; i++)
   {
      clock_rec_pw[i] = 1;
      clock_rec_lines[CLI_F_AttacheLineToPwNumber(i)] = 1;
   }

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)

      {
         line_index = i*28 + j;
         timing_index = i*WTI_E1_LINES_PER_SPE + j;

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         if (clock_rec_lines[line_index] == 1)
         {/* Only CR line are using both RX ana TX*/
            sprintf(temp_buf, "0 %d 4 3",line_index);
         }
         else
         {
            /* All other lines are shaped */
            sprintf(temp_buf, "0 %d 4 2",line_index);
         }

         CLI_F_UfeTransferMode(temp_buf);

         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, timing_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-63), shaper ID (0-31)] */
         /* TDM2PSN direction conect all line to first shaper */
         sprintf(temp_buf, "0 %d 0", line_index);

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
      }
   }
   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 2");

   CLI_F_UfeChipInitLineSetup("");
   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_E1_LINES_PER_SPE + j;

         sprintf(temp_buf, "0 %d 32 32", line_index);/* The line index of this PW */
         CLI_F_PwConfigureUnframed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 256");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CLOCK_REC_MODE
         /* Rx timing is used - in differential mode all line insert TS */
         /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER )
            ,ts_diff_if_id(0-31)] */
         sprintf(temp_buf, "0 1 1 %d",0);
#else
         sprintf(temp_buf, "0 0 0 %d",pw_index);
#endif
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
         /**************** PSN --> TDM IW *****************/
         if (clock_rec_pw[pw_index])
         {
            /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000");
         }
         else
         {
            /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0");
         }

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/

         /* The First global_active_cr_async_mode PWs use CR, all other don't */
         if (clock_rec_pw[pw_index])
         {
            /* CR master Rx and Tx direction */
            CLI_F_PwCreate("0 0 1 1"); /* CR master */
            sprintf(temp_buf, "0 %d 1",pw_index);
         }
         else
         {
            CLI_F_PwCreate("0 0 1 0"); /* CR master */
            sprintf(temp_buf, "0 %d 0",pw_index);
         }
         CLI_F_PwEnable(temp_buf);

      } /* end for (configure each line) */
   }
}
#endif /* (WTI_CESOP_RX_TIMING_ENABLE && WTI_CESOP_CLOCK_RECOVERY_ENABLE) */
#if (WTI_CESOP_RX_TIMING_ENABLE && WTI_CESOP_CLOCK_RECOVERY_ENABLE)
/********************************************************************************************
 * Description:
 *            N = "global_active_cr_async_mode"
 * TDM2PSN :  The test uses one CD in all PW (in this case PW = line) are using the same
 *            shaper (conected to the first one).
 * PSN2TDM :  The first N lines -  0...N-1 are conected to CT#0..N-1
 *            Line N...63 are conected to CT#0
 *            The distribution of the CD buy more the one PW is tested.
 *
 * The test can run upto 84 lines (all use same PS and DUS)
 *
 *******************************************************************************************/
void CLI_F_102_SBI_T1_U_CR_NoCas_Two_Boards_1_CD_N_CT_84_Line_84_PW(char *StrPrm)
{
   WP_U32 i, j, line_index, spe_index, pw_index;
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   WP_U8   clock_rec_lines[336] = {0}; /* list of Tx master lines */
   WP_U8   clock_rec_pw[336] = {0}; /* list of master PWs */

   /* Set the CR lines TX direction */
   for (i=0; i< global_active_cr_async_mode; i++)
   {
      clock_rec_pw[i] = 1;
      clock_rec_lines[i] = 1;
   }

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)

      {
         line_index = i*28 + j;
         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         if (clock_rec_lines[line_index] == 1)
         {/* Only CR line are using both RX ana TX*/
            sprintf(temp_buf, "0 %d 2 3",line_index);
         }
         else
         {
            /* All other lines are shaped */
            sprintf(temp_buf, "0 %d 2 2",line_index);
         }

         CLI_F_UfeTransferMode(temp_buf);

         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, line_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-63), shaper ID (0-31)] */
         /* TDM2PSN direction conect all line to first shaper */
         sprintf(temp_buf, "0 %d 0", line_index);

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
      }
   }
   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 0");

   CLI_F_UfeChipInitLineSetup("");
   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_T1_LINES_PER_SPE + j;

         sprintf(temp_buf, "0 %d 48 48", line_index);/* The line index of this PW */
         CLI_F_PwConfigureUnframed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 384");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 198 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CLOCK_REC_MODE
         /* Rx timing is used - in differential mode all line insert TS */
         /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER )
            ,ts_diff_if_id(0-31)] */
         sprintf(temp_buf, "0 1 1 %d",0); /* must be '0', there is only one shaper */
#else
         sprintf(temp_buf, "0 0 0 %d",pw_index);
#endif
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
         /**************** PSN --> TDM IW *****************/
         if (clock_rec_pw[pw_index] == 1)
         {
            /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000");
         }
         else
         {
            /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0");
         }

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/

         /* The First global_active_cr_async_mode PWs use CR, all other don't */
         if (clock_rec_pw[pw_index] == 1)
         {
            /* CR master Rx and Tx direction */
            CLI_F_PwCreate("0 0 1 1"); /* CR master */
            sprintf(temp_buf, "0 %d 1",pw_index);
         }
         else
         {
            CLI_F_PwCreate("0 0 1 0"); /* CR master */
            sprintf(temp_buf, "0 %d 0",pw_index);
         }
         CLI_F_PwEnable(temp_buf);

      } /* end for (configure each line) */
   }
}
#endif /* (WTI_CESOP_RX_TIMING_ENABLE && WTI_CESOP_CLOCK_RECOVERY_ENABLE) */
#if (WTI_CESOP_RX_TIMING_ENABLE && WTI_CESOP_CLOCK_RECOVERY_ENABLE)
/********************************************************************************************
 * Description:
 *            N = "global_active_cr_async_mode"
 * TDM2PSN :  The test uses one CD in all PW (in this case PW = line) are using the same
 *            shaper (conected to the first one).
 * PSN2TDM :  The first N lines -  0...N-1 are conected to CT#0..N-1
 *            Line N...63 are conected to CT#0
 *            The distribution of the CD buy more the one PW is tested.
 *
 * The test can run upto 63 lines (all use same PS and DUS)
 *
 *******************************************************************************************/
void CLI_F_102_SBI_E1_F_CR_NoCas_Two_Boards_1_CD_N_CT_63_Line_63_PW(char *StrPrm)
{
   WP_U32 i, j, line_index, spe_index, timing_index, pw_index;
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U8   clock_rec_lines[336] = {0}; /* list of master lines */
   WP_U8   clock_rec_pw[336] = {0}; /* list of master PWs */

   /* Set the CR lines PWs TX direction */
   for (i = 0; i < 32; i++)
   {
      clock_rec_pw[i] = 1;
      clock_rec_lines[CLI_F_AttacheLineToPwNumber(i)] = 1;
   }

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }


   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         timing_index = i*WTI_E1_LINES_PER_SPE + j;

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 3 3",line_index);
         }
         else
         {
            /* set ufe Rx direction only - for all lines */
            sprintf(temp_buf, "0 %d 3 2",line_index);
         }
         CLI_F_UfeTransferMode(temp_buf);

         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, timing_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-63), shaper ID (0-31)] */
         /* TDM2PSN direction conect all line to first shaper */
         sprintf(temp_buf, "0 %d 0", line_index);

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */

      }
   }


   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 3");

   CLI_F_UfeChipInitLineSetup("");

   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_E1_LINES_PER_SPE + j;

         sprintf(temp_buf, "0 %d 32 32 32 0-31", line_index);
         CLI_F_PwConfigureFramed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 256");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CLOCK_REC_MODE
         /* Rx timing is used - in differential mode all line insert TS */
         /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER )
            ,ts_diff_if_id(0-31)] */
         sprintf(temp_buf, "0 1 1 %d",0);
#else
         sprintf(temp_buf, "0 0 0 %d",pw_index);
#endif
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
         /**************** PSN --> TDM IW *****************/
         if (clock_rec_pw[pw_index] == 1)
         {
            /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000");
         }
         else
         {
            /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0");
         }


         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/
         /* ------------------------------- Create and Enable all PWs  --------------------------------------- */

         /* The First global_active_cr_async_mode PWs use CR, all other don't */
         if (clock_rec_pw[pw_index] == 1)
         {
            /* CR master Rx and Tx direction */
            CLI_F_PwCreate("0 0 1 1"); /* CR master */
            sprintf(temp_buf, "0 %d 1",pw_index);
         }
         else
         {
            CLI_F_PwCreate("0 0 1 0"); /* CR master */
            sprintf(temp_buf, "0 %d 0",pw_index);
         }
         CLI_F_PwEnable(temp_buf);

      } /* end for (configure each line) */
   }
}
#endif /* (WTI_CESOP_RX_TIMING_ENABLE && WTI_CESOP_CLOCK_RECOVERY_ENABLE) */
#if (WTI_CESOP_RX_TIMING_ENABLE && WTI_CESOP_CLOCK_RECOVERY_ENABLE)
/********************************************************************************************
 * Description:
 *            N = "global_active_cr_async_mode"
 * TDM2PSN :  The test uses one CD in all PW (in this case PW = line) are using the same
 *            shaper (conected to the first one).
 * PSN2TDM :  The first N lines -  0...N-1 are conected to CT#0..N-1
 *            Line N...63 are conected to CT#0
 *            The distribution of the CD buy more the one PW is tested.
 *
 * The test can run upto 84 lines (all use same PS and DUS)
 *
 *******************************************************************************************/
void CLI_F_102_SBI_T1_F_CR_NoCas_Two_Boards_1_CD_N_CT_84_Line_84_PW(char *StrPrm)
{
   WP_U32 i, j, line_index, spe_index, pw_index;
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U8   clock_rec_lines[336] = {0}; /* list of master lines */
   WP_U8   clock_rec_pw[336] = {0}; /* list of master PWs */

   /* Set the CR lines TX direction */
   for (i=0; i< global_active_cr_async_mode; i++)
   {
      clock_rec_pw[i] = 1;
      clock_rec_lines[i] = 1;
   }

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }


   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;

         if (line_index >= 192)
         {
            printf("**** WARNING! TEST CAN NOT RUN WITH MORE THEN 192 PHYS ON ONE RX PORT RAM ****\n");
            break;
         }
         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 1 3",line_index);
         }
         else
         {
            /* set ufe Rx direction only - for all lines */
            sprintf(temp_buf, "0 %d 1 2",line_index);
         }
         CLI_F_UfeTransferMode(temp_buf);

         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, line_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-63), shaper ID (0-31)] */
         /* TDM2PSN direction conect all line to first shaper */
         sprintf(temp_buf, "0 %d 0", line_index);

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */

      }
   }


   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 1");

   CLI_F_UfeChipInitLineSetup("");

   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_T1_LINES_PER_SPE + j;

         if (pw_index >= 192)
            break;

         sprintf(temp_buf, "0 %d 48 48 24 0-23", line_index);
         CLI_F_PwConfigureFramed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 384");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 198 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CLOCK_REC_MODE
         /* Rx timing is used - in differential mode all line insert TS */
         /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER )
            ,ts_diff_if_id(0-31)] */
         sprintf(temp_buf, "0 1 1 %d",0);
#else
         sprintf(temp_buf, "0 0 0 %d",pw_index);
#endif
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
         /**************** PSN --> TDM IW *****************/
         if (clock_rec_pw[pw_index] == 1)
         {
            /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000");
         }
         else
         {
            /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0");
         }


         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/
         /* ------------------------------- Create and Enable all PWs  --------------------------------------- */

         /* The First global_active_cr_async_mode PWs use CR, all other don't */
         if (clock_rec_pw[pw_index] == 1)
         {
            /* CR master Rx and Tx direction */
            CLI_F_PwCreate("0 0 1 1"); /* CR master */
            sprintf(temp_buf, "0 %d 1",pw_index);
         }
         else
         {
            CLI_F_PwCreate("0 0 1 0"); /* CR master */
            sprintf(temp_buf, "0 %d 0",pw_index);
         }
         CLI_F_PwEnable(temp_buf);

      } /* end for (configure each line) */
   }
}
#endif /* (WTI_CESOP_RX_TIMING_ENABLE && WTI_CESOP_CLOCK_RECOVERY_ENABLE) */
#if (WTI_CESOP_RX_TIMING_ENABLE && WTI_CESOP_CLOCK_RECOVERY_ENABLE)
/********************************************************************************************
 * Description:
 * This test runs with TX and RX CR modules.
 *
 * TDM2PSN :  The test uses one CD in all PW (in this case PW = line) are using the same
 *            shaper (conected to the first one).
 * PSN2TDM :  All lines conected to CT#0.
 *
 *
 * The test can run upto 63 lines all use same PS and data unit size (DU size).
 *
 * The use of max PWs per shaper is tested (in framed mode up to 252 PWs per shaper).
 *
 *******************************************************************************************/
void CLI_F_104_SBI_E1_F_CR_NoCas_Two_Boards_1_CD_1_CT_63_Line_252_PW(char *StrPrm)
{
   WP_U32 i, j, k, line_index, spe_index, pw_index;
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U8   clock_rec_lines[336] = {0}; /* list of master lines */

   /* Set the CR lines (both for RX and TX direction */
   /* Set line 0 to be CR master */
   clock_rec_lines[0] = 1;

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }


   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;

         if (line_index >= 84)
         {
            printf("**** WARNING! TEST CAN NOT RUN WITH MORE THEN 84 LINES ON ONE RX PORT RAM ****\n");
            break;
         }
         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 3 3",line_index);
         }
         else
         {
            /* set ufe Rx direction only - for all lines */
            sprintf(temp_buf, "0 %d 3 2",line_index);
         }
         CLI_F_UfeTransferMode(temp_buf);

         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, line_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, line_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
      }
   }


   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 3");

   CLI_F_UfeChipInitLineSetup("");

   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif
   pw_index = 0;
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;

         if (line_index >= 84)
            break;

         for (k=0; k<4; k++)
         {
            switch(k)
            {
            case 0:
            {
               sprintf(temp_buf, "0 %d 32 32 8 0-7", line_index);
            }
            break;
            case 1:
            {
               sprintf(temp_buf, "0 %d 32 32 8 8-15", line_index);
            }
            break;
            case 2:
            {
               sprintf(temp_buf, "0 %d 32 32 8 16-23", line_index);
            }
            break;
            case 3:
            {
               sprintf(temp_buf, "0 %d 32 32 8 24-31", line_index);
            }
            break;
            default:
               printf("ERROR");
            }

            CLI_F_PwConfigureFramed(temp_buf);

            /* PWE3 channel configuration */
            CLI_F_Pwe3ChannelJitterBufferSize("0 32");
            CLI_F_Pwe3ChannelRxBufferSize("0 64");
            CLI_F_Pwe3ChannelStatmode("0 1");
            CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7");
            CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31");
            CLI_F_Pwe3ChannelUdpDummyMode("0 1");
            CLI_F_Pwe3ChannelTxUdcas("0 f");

            /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
            CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
            CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
            sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
            CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
            sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
            CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
            CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 58 0");
            CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
            CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CLOCK_REC_MODE
            /* Rx timing is used in differential mode */
            /* In differential mode all other pw uses CD#0 */

            /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER),
               ts_diff_if_id(0-31)] */
            sprintf(temp_buf, "0 1 1 0");
#else
            /* Rx timing is not used */

            /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER),
               ts_diff_if_id(0-31)] */
            sprintf(temp_buf, "0 0 0 0");
#endif
            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);


            /**************** PSN --> TDM IW *****************/

            /* PW 0 is the master to CT#0 which used by all lines */
            if (pw_index == 0 )
               CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
            else
               CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */

            CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
            CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

            /**************** PSN --> TDM Tx binding*****************/
            /* ------------------------------- Create and Enable all PWs  --------------------------------------- */

            if (pw_index == 0)
            {
               /* CR master Rx and Tx direction */
               CLI_F_PwCreate("0 0 1 1");
               /* Enable CR TX */
               sprintf(temp_buf, "0 %d 1",pw_index);
            }
            else
            {
               /* Set all PW in rx to work in shapping mode */
               CLI_F_PwCreate("0 0 1 0");
               sprintf(temp_buf, "0 %d 0",pw_index);
            }
            CLI_F_PwEnable(temp_buf);

            pw_index++;

         }

      } /* end for (configure each line) */
   }
}
#endif /* (WTI_CESOP_RX_TIMING_ENABLE && WTI_CESOP_CLOCK_RECOVERY_ENABLE) */
#if (WTI_CESOP_RX_TIMING_ENABLE && WTI_CESOP_CLOCK_RECOVERY_ENABLE)
/********************************************************************************************
 * Description:
 * This test runs with TX and RX CR modules.
 *
 * TDM2PSN :  The test uses one CD in all PW (in this case PW = line) are using the same
 *            shaper (conected to the first one).
 * PSN2TDM :  All lines conected to CT#0.
 *
 *
 * The test can run upto 84 lines all use same PS and data unit size (DU size).
 *
 * The use of max PWs per shaper is tested (in framed mode up to 192 PWs per shaper).
 * Lines 0-23 have 3 pws per line, lines 24-83 have 2 pws per line
 *
 *******************************************************************************************/
void CLI_F_104_SBI_T1_F_CR_NoCas_Two_Boards_1_CD_1_CT_84_Line_192_PW(char *StrPrm)
{
   WP_U32 i, j, k, line_index, spe_index, pw_index,pw_per_line;
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U8   clock_rec_lines[336] = {0}; /* list of master lines */

   /* Set the CR lines (both for RX and TX direction */
   /* Set line 0 to be CR master */
   clock_rec_lines[0] = 1;

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }


   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;

         if (line_index >= 84)
         {
            printf("**** WARNING! TEST CAN NOT RUN WITH MORE THEN 84 LINES ON ONE RX PORT RAM ****\n");
            break;
         }
         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 1 3",line_index);
         }
         else
         {
            /* set ufe Rx direction only - for all lines */
            sprintf(temp_buf, "0 %d 1 2",line_index);
         }
         CLI_F_UfeTransferMode(temp_buf);

         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, line_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, line_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
      }
   }


   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 1");

   CLI_F_UfeChipInitLineSetup("");

   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   pw_index = 0;
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;

         /* Over all line :84 over all PWs:  24x3PW + 60x2PW = 192PW */
         if (line_index >=84)
            break;

         if(line_index<24)
         {
            /* lines 0-23 have 3 pws per line */
            pw_per_line = 3;
         }
         else
         {
            /* lines 24-83 have 2 pws per line */
            pw_per_line = 2;
         }

         for (k=0; k<pw_per_line; k++)
         {
            if(pw_per_line == 3)
            {
               switch(k)
               {
               case 0:
               {
                  sprintf(temp_buf, "0 %d 64 64 8 0-7", line_index);
               }
               break;
               case 1:
               {
                  sprintf(temp_buf, "0 %d 64 64 8 8-15", line_index);
               }
               break;
               case 2:
               {
                  sprintf(temp_buf, "0 %d 64 64 8 16-23", line_index);
               }
               break;
               default:
                  printf("ERROR");
               }

               CLI_F_PwConfigureFramed(temp_buf);


               /* PWE3 channel configuration */
               CLI_F_Pwe3ChannelJitterBufferSize("0 32");
               CLI_F_Pwe3ChannelRxBufferSize("0 64");
               CLI_F_Pwe3ChannelStatmode("0 1");
               CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7");
               CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31");
               CLI_F_Pwe3ChannelUdpDummyMode("0 1");
               CLI_F_Pwe3ChannelTxUdcas("0 f");
            }
            else
            {
               switch(k)
               {
               case 0:
               {
                  sprintf(temp_buf, "0 %d 60 60 12 0-11", line_index);
               }
               break;
               case 1:
               {
                  sprintf(temp_buf, "0 %d 60 60 12 12-23", line_index);
               }
               break;
               default:
                  printf("ERROR");
               }

               CLI_F_PwConfigureFramed(temp_buf);


               /* PWE3 channel configuration */
               CLI_F_Pwe3ChannelJitterBufferSize("0 32");
               CLI_F_Pwe3ChannelRxBufferSize("0 60");
               CLI_F_Pwe3ChannelStatmode("0 1");
               CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11");
               CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35");
               CLI_F_Pwe3ChannelUdpDummyMode("0 1");
               CLI_F_Pwe3ChannelTxUdcas("0 f");

            }

            /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
            CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
            CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
            sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
            CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
            sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
            CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif

            if(pw_per_line == 3)
            {
               CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 7c 0");
            }
            else
            {
               CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 54 0");
            }

            CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
            CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CLOCK_REC_MODE
            /* Rx timing is used in differential mode */
            /* In differential mode all other pw uses CD#0 */

            /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER),
               ts_diff_if_id(0-31)] */
            sprintf(temp_buf, "0 1 1 0");
#else
            /* Rx timing is not used */

            /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER),
               ts_diff_if_id(0-31)] */
            sprintf(temp_buf, "0 0 0 0");
#endif
            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);


            /**************** PSN --> TDM IW *****************/

            /* PW 0 is the master to CT#0 which used by all lines */
            if (pw_index == 0 )
               CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
            else
               CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */

            CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
            CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

            /**************** PSN --> TDM Tx binding*****************/
            /* ------------------------------- Create and Enable all PWs  --------------------------------------- */

            if (pw_index == 0)
            {
               /* CR master Rx and Tx direction */
               CLI_F_PwCreate("0 0 1 1");
               /* Enable CR TX */
               sprintf(temp_buf, "0 %d 1",pw_index);
            }
            else
            {
               /* Set all PW in rx to work in shapping mode */
               CLI_F_PwCreate("0 0 1 0");
               sprintf(temp_buf, "0 %d 0",pw_index);
            }
            CLI_F_PwEnable(temp_buf);

            pw_index++;
         }

      } /* end for (configure each line) */
   }
}
#endif /* (WTI_CESOP_RX_TIMING_ENABLE && WTI_CESOP_CLOCK_RECOVERY_ENABLE) */
/***************************************************************
 * Func name  :
 * Description:
 *             This test runs with RX and TX CR modules
 *             TDM2PSN: Test uses N CD for the first N PWs (PW=line in this case).
 *                      Each CD uses different shaper. All PWs > N use the first shaper.
 *             PSN2TDM: First N PWs are connected to N CTs respectively. PWs N+1 and forward
 *                      are connected to CT0.
 *             (*) N = "global_active_cr_async_mode"
 ***************************************************************/
WP_U32 CLI_F_105_SBI_E1_U_CR_NoCas_Two_Boards_1_CD_1_CT_63_line_addremove_PW(char *StrPrm)
{
   WP_U32  i, j, line_index, spe_index, cd_index, pw_index, res, cmd, iterations, index, result;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U8   clock_rec_lines[336] = {0}; /* list of master lines */
   WP_U8   clock_rec_pw[336] = {0}; /* list of master PWs */

   res = sscanf(StrPrm, "%d %d", &cmd, &iterations);
   if (res != 2 && res != 1)
   {
      WTI_TerminatePrintError("CLI_F_105_SBI_E1_U_CR_NoCas_Two_Boards_1_CD_1_CT_63_line_addremove_PW Invalid number of parameters", __LINE__);
      return WT_FAIL;
   }
   else if (res == 2)
   {
      if (iterations < 1)
      {
         WTI_TerminatePrintError("CLI_F_105_SBI_E1_U_CR_NoCas_Two_Boards_1_CD_1_CT_63_line_addremove_PW Invalid number of Iterations\n iterations is <0", __LINE__);
         return WT_FAIL;
      }
   }
   if (res == 1)
      iterations = 10;

   /* Set the CR lines (both for RX and TX direction */
#if (WTI_CESOP_RX_TIMING_ENABLE || WTI_CESOP_CLOCK_RECOVERY_ENABLE)
   for (i = 0/*236*/; i < 64/*252*/; i++)
   {
      clock_rec_lines[CLI_F_AttacheLineToPwNumber(i)] = 1;
      clock_rec_pw[i] = 1;
   }

#endif

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }


   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE||WTI_CESOP_RX_TIMING_ENABLE)
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE || WTI_CESOP_RX_TIMING_ENABLE */

   cd_index = 0;
   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;

         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */

         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */
         /* set ufe Tx and Rx direction */
         if (clock_rec_lines[line_index] == 1) /* lines 0-(N-1) use CR, all other don't */
         {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
#if WTI_CESOP_RX_TIMING_ENABLE
            sprintf(temp_buf, "0 %d 4 3",line_index);
#else
            /* set ufe Tx direction only */
            sprintf(temp_buf, "0 %d 4 1",line_index);
#endif

#else /* Not WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Rx direction only */
            sprintf(temp_buf, "0 %d 4 2",line_index);
#endif

#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */
         }
         else
         {
#if WTI_CESOP_RX_TIMING_ENABLE
            sprintf(temp_buf, "0 %d 4 2",line_index); /* lines number >N => don't use CR  */
#else
            sprintf(temp_buf, "0 %d 4 0",line_index); /* line doesn't use CR on any direction */
#endif
         }

         CLI_F_UfeTransferMode(temp_buf);

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cd_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }
         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, clock_trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */
#endif /* end of WTI_CESOP_CLOCK_RECOVERY_ENABLE*/
#if WTI_CESOP_RX_TIMING_ENABLE

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cd_index);
            cd_index++;
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
#endif
      }
   }
   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 2");

   CLI_F_UfeChipInitLineSetup("");

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }
#endif

#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   cd_index = 0;
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_E1_LINES_PER_SPE + j;

         sprintf(temp_buf, "0 %d %d 32 32", line_index, pw_index);/* The line index of this PW */
         CLI_F_PwConfigureUnframed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 256");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
         /* Rx timing is used in differential mode */
         /* first global_active_cr_async_mode related to different CDs */
         if (clock_rec_pw[pw_index])
         {
            sprintf(temp_buf, "0 1 1 %d",cd_index);
            cd_index++;
         }
         else
         {/* In differential mode all other pw (not first ones) uses CD#0 */
            sprintf(temp_buf, "0 0 1 %d",pw_index);
         }
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
         /* Rx timing is not used */
         sprintf(temp_buf, "0 0 1 %d",pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

         /**************** PSN --> TDM IW *****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* if clock recovery is set -> Tx timing is used */
         if (clock_rec_pw[pw_index])
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#else
         /* if clock recovery is disable -> Tx timing is not used */
         CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#endif

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/

         /* CR Rx and Tx direction */
         if (clock_rec_pw[pw_index])
         {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
#if WTI_CESOP_RX_TIMING_ENABLE
            sprintf(temp_buf, "0 0 1 1 %d",pw_index);
            CLI_F_PwCreate(temp_buf); /* CR master */
#else
            /* CR master Tx direction */
            sprintf(temp_buf, "0 0 0 1 %d",pw_index);
            CLI_F_PwCreate(temp_buf); /* CR master */
#endif

#else /* not  WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
            /* CR master Rx  direction only */
            sprintf(temp_buf, "0 0 1 0 %d",pw_index);
            CLI_F_PwCreate(temp_buf); /* CR master */
#endif
#endif
         }

         else
         {
#if WTI_CESOP_RX_TIMING_ENABLE
            sprintf(temp_buf, "0 0 1 0 %d",pw_index);
            CLI_F_PwCreate(temp_buf); /* CR slave */
#else
            sprintf(temp_buf, "0 0 0 0 %d",pw_index);
            CLI_F_PwCreate(temp_buf);
#endif
         }

         if (clock_rec_pw[pw_index])
            sprintf(temp_buf, "0 %d 1",pw_index); /* line 1 is the master, all other slaves */
         else
            sprintf(temp_buf, "0 %d 0",pw_index);
         CLI_F_PwEnable(temp_buf);

      } /* end for (configure each line) */
   }

   /* run test in loop mode */
   for (index=1; index <= iterations; index++)
   {
      if ((!WTI_CLOCK_REC_MODE)&&(WTI_CESOP_CLOCK_RECOVERY_ENABLE))
         {
            printf("Wait 30 seconds to give the data time to flow...\n");
            WP_Delay(30000000);
         }
         else
         {
            printf("Wait 15 seconds to give the data time to flow...\n");
            WP_Delay(15000000);
         }

      printf("\nIteration number: %d\n", index);

      result = CLI_F_GlobalStatisticsCheck("0");
      if (result == WT_FAIL)
      {
         WTI_PRINT_ERROR(("\n Test Failed in iteration number: %d\n", index));
         return WT_FAIL;
      }

      /* remove PWs */
      printf("Removing all PWs\n");

      for (i=N_ACTIVE_UFE_SBI_SPE; i>0; i--)
      {
         for (j=WTI_E1_LINES_PER_SPE; j>0; j--)
         {
            pw_index = (i-1)*WTI_E1_LINES_PER_SPE + (j-1);
            sprintf(temp_buf, "0 %d", pw_index);
            CLI_F_PwRemove(temp_buf);
         }
      }

      WP_Delay(300000);
      /* recreate PW in "old fasion way": just repeat the lines above */
      printf("\nRecreating all PWs\n");
      cd_index = 0;
      for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
      {
         for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
         {
            line_index = i*28 + j;
            pw_index = i*WTI_E1_LINES_PER_SPE + j;

            sprintf(temp_buf, "0 %d %d 32 32", line_index, pw_index);/* The line index of this PW */
            CLI_F_PwConfigureUnframed(temp_buf);

            /* PWE3 channel configuration */
            CLI_F_Pwe3ChannelJitterBufferSize("0 32");
            CLI_F_Pwe3ChannelRxBufferSize("0 256");
            CLI_F_Pwe3ChannelStatmode("0 1");
            CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
            CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
            CLI_F_Pwe3ChannelUdpDummyMode("0 1");
            CLI_F_Pwe3ChannelTxUdcas("0 f");

            /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
            CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
            CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
            sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
            CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
            sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
            CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
            CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
            CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
            CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
            /* Rx timing is used in differential mode */
            /* first global_active_cr_async_mode related to different CDs */
            if (clock_rec_pw[pw_index])
            {
               sprintf(temp_buf, "0 1 1 %d",cd_index);
               cd_index++;
            }
            else
               sprintf(temp_buf, "0 0 1 %d",pw_index);
            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
            /* Rx timing is not used */
            sprintf(temp_buf, "0 0 1 %d",pw_index);
            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

            /**************** PSN --> TDM IW *****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
            /* if clock recovery is set -> Tx timing is used */
            if (clock_rec_pw[pw_index])
               CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
            else
               CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#else
            /* if clock recovery is disable -> Tx timing is not used */
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#endif
            CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
            CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

            /**************** PSN --> TDM Tx binding*****************/

            /* CR master Rx and Tx direction */
            if (clock_rec_pw[pw_index])
            {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
#if WTI_CESOP_RX_TIMING_ENABLE
               sprintf(temp_buf, "0 0 1 1 %d",pw_index);
               CLI_F_PwCreate(temp_buf); /* CR master */
#else
               /* CR master Tx direction */
               sprintf(temp_buf, "0 0 0 1 %d",pw_index);
               CLI_F_PwCreate(temp_buf); /* CR master */
#endif

#else /* not  WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
               /* CR master Rx  direction only */
               sprintf(temp_buf, "0 0 1 0 %d",pw_index);
               CLI_F_PwCreate(temp_buf); /* CR master */
#endif
#endif
            }

            else
            {
#if WTI_CESOP_RX_TIMING_ENABLE
               sprintf(temp_buf, "0 0 1 0 %d",pw_index);
               CLI_F_PwCreate(temp_buf); /* CR slave */
#else
               sprintf(temp_buf, "0 0 0 0 %d",pw_index);
               CLI_F_PwCreate(temp_buf);
#endif
            }

            if (clock_rec_pw[pw_index])
               sprintf(temp_buf, "0 %d 1",pw_index); /* line 1 is the master, all other slaves */
            else
               sprintf(temp_buf, "0 %d 0",pw_index);
            CLI_F_PwEnable(temp_buf);

         } /* end for (configure each line) */
      }

   } /* for loop */
   WP_Delay(300000);
   printf("\nLast iteration\n");
   if ((!WTI_CLOCK_REC_MODE)&&(WTI_CESOP_CLOCK_RECOVERY_ENABLE))
      {
         printf("Wait 30 seconds to give the data time to flow...\n");
         WP_Delay(30000000);
      }
      else
      {
         printf("Wait 15 seconds to give the data time to flow...\n");
         WP_Delay(15000000);
      }
   result = CLI_F_GlobalStatisticsCheck("0");
   if (result == WT_FAIL)
   {
      WTI_PRINT_ERROR(("\n Test Failed in last iteration\n"));
      return WT_FAIL;
   }
   else return WT_PASS;
}

/***************************************************************
 * Func name  :
 * Description:
 *             This test runs with RX and TX CR modules
 *             TDM2PSN: Test uses N CD for the first N PWs (PW=line in this case).
 *                      Each CD uses different shaper. All PWs > N use the first shaper.
 *             PSN2TDM: First N PWs are connected to N CTs respectively. PWs N+1 and forward
 *                      are connected to CT0.
 *             (*) N = "global_active_cr_async_mode"
 ***************************************************************/
WP_U32 CLI_F_105_SBI_T1_U_CR_NoCas_Two_Boards_1_CD_1_CT_84_line_addremove_PW(char *StrPrm)
{
   WP_U32 i, j, line_index, spe_index, cd_index, pw_index, res, cmd, iterations, index, result;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U8   clock_rec_lines[336] = {0}; /* list of master lines */
   WP_U8   clock_rec_pw[336] = {0}; /* list of master PWs */

   res = sscanf(StrPrm, "%d %d", &cmd, &iterations);
   if (res != 2 && res != 1)
   {
      WTI_TerminatePrintError("CLI_F_105_SBI_E1_U_CR_NoCas_Two_Boards_1_CD_1_CT_63_line_addremove_PW Invalid number of parameters", __LINE__);
      return WT_FAIL;
   }
   else if (res == 2)
   {
      if (iterations < 1)
      {
         WTI_TerminatePrintError("CLI_F_105_SBI_E1_U_CR_NoCas_Two_Boards_1_CD_1_CT_63_line_addremove_PW Invalid number of Iterations\n iterations is >0", __LINE__);
         return WT_FAIL;
      }
   }
   if (res == 1)
      iterations = 10;

#if (WTI_CESOP_RX_TIMING_ENABLE || WTI_CESOP_CLOCK_RECOVERY_ENABLE)

   for (i = 0/*236*/; i < 60/*252*/; i++)
   {
      clock_rec_pw[i] = 1;
      clock_rec_lines[i] = 1;
   }
   clock_rec_pw[83] = 1;
   clock_rec_lines[83] = 1;
   clock_rec_pw[126] = 1;
   clock_rec_lines[126] = 1;
   clock_rec_pw[147] = 1;
   clock_rec_lines[147] = 1;
   clock_rec_pw[210] = 1;
   clock_rec_lines[210] = 1;
#endif

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }


   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE||WTI_CESOP_RX_TIMING_ENABLE)
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE || WTI_CESOP_RX_TIMING_ENABLE */

   cd_index = 0;
   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;

         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */

         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */
         /* set ufe Tx and Rx direction */
         if (clock_rec_lines[line_index] == 1) /* lines 0-(N-1) use CR, all other don't */
         {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
#if WTI_CESOP_RX_TIMING_ENABLE
            sprintf(temp_buf, "0 %d 2 3",line_index);
#else
            /* set ufe Tx direction only */
            sprintf(temp_buf, "0 %d 2 1",line_index);
#endif
#else /* Not WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Rx direction only */
            sprintf(temp_buf, "0 %d 2 2",line_index);
#endif

#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */
         }
         else
         {
#if WTI_CESOP_RX_TIMING_ENABLE
            sprintf(temp_buf, "0 %d 2 0",line_index); /* lines number >N => don't use CR  */
#else
            sprintf(temp_buf, "0 %d 2 0",line_index); /* line doesn't use CR on any direction */
#endif
         }

         CLI_F_UfeTransferMode(temp_buf);

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cd_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }
         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, clock_trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

#endif /* end of WTI_CESOP_CLOCK_RECOVERY_ENABLE*/
#if WTI_CESOP_RX_TIMING_ENABLE
         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cd_index);
            cd_index++;
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
#endif
      }
   }

   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 0");

   CLI_F_UfeChipInitLineSetup("");

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }
#endif

#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   cd_index = 0;
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_T1_LINES_PER_SPE + j;

         sprintf(temp_buf, "0 %d 48 48", line_index);/* The line index of this PW */
         CLI_F_PwConfigureUnframed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 384");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 198 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
         /* Rx timing is used in differential mode */
         /* first global_active_cr_async_mode related to different CDs */
         if (clock_rec_pw[pw_index])
         {
            sprintf(temp_buf, "0 1 1 %d",cd_index);
            cd_index++;
         }
         else
         {/* In differential mode all other pw (not first ones) uses CD#0 */
            sprintf(temp_buf, "0 0 1 %d",pw_index);
         }
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
         /* Rx timing is not used */
         sprintf(temp_buf, "0 0 1 %d",pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

         /**************** PSN --> TDM IW *****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* if clock recovery is set -> Tx timing is used */
         if (clock_rec_pw[pw_index])    /* lines 0-(N-1) use CR, all other don't */
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */

#else
         /* if clock recovery is disable -> Tx timing is not used */
         CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#endif
         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/

         /* CR Rx and Tx direction */
         if (clock_rec_pw[pw_index])   /* pw 0-(N-1) use CR, all other don't */
         {

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
#if WTI_CESOP_RX_TIMING_ENABLE
            sprintf(temp_buf, "0 0 1 1 %d",pw_index);
            CLI_F_PwCreate(temp_buf); /* CR master */
#else
            /* CR master Tx direction */
            sprintf(temp_buf, "0 0 0 1 %d",pw_index);
            CLI_F_PwCreate(temp_buf); /* CR master */
#endif
#else /* not  WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
            /* CR master Rx  direction only */
            sprintf(temp_buf, "0 0 1 0 %d",pw_index);
            CLI_F_PwCreate(temp_buf); /* CR master */
#endif
#endif
         }
         else
         {

#if WTI_CESOP_RX_TIMING_ENABLE
            sprintf(temp_buf, "0 0 1 0 %d",pw_index);
            CLI_F_PwCreate(temp_buf); /* CR slave */
#else
            sprintf(temp_buf, "0 0 0 0 %d",pw_index);
            CLI_F_PwCreate(temp_buf);
#endif
         }

         if (clock_rec_pw[pw_index])
            sprintf(temp_buf, "0 %d 1",pw_index); /* line 1 is the master, all other slaves */
         else
            sprintf(temp_buf, "0 %d 0",pw_index);
         CLI_F_PwEnable(temp_buf);

      } /* end for (configure each line) */
   }


   /* run test in loop mode */
   for (index=1; index <= iterations; index++)
   {
      printf("\nIteration number: %d\n", index);
      if ((!WTI_CLOCK_REC_MODE)&&(WTI_CESOP_CLOCK_RECOVERY_ENABLE))
            {
               printf("Wait 30 seconds to give the data time to flow...\n");
               WP_Delay(30000000);
            }
            else
            {
               printf("Wait 15 seconds to give the data time to flow...\n");
               WP_Delay(15000000);
            }
      result = CLI_F_GlobalStatisticsCheck("0");
      if (result == WT_FAIL)
      {
         WTI_PRINT_ERROR(("\n Test Failed in iteration number: %d\n", index));
         return WT_FAIL;
      }

#if 0
      printf("disable PHY\n");
      /* disable UFE phy */
      WT_UfePhyDisable(&the_system->ufe, 0);
      WP_Delay(1000000); /* 1 second delay */
      printf("enable phy\n");
      /* enable UFE phy */
      WT_UfePhyEnable(&the_system->ufe, 0);

#else
      /* remove PWs */
      printf("Removing all PWs\n");

      for (i=N_ACTIVE_UFE_SBI_SPE; i>0; i--)
      {
         for (j=WTI_T1_LINES_PER_SPE; j>0; j--)
         {
            pw_index = (i-1)*WTI_T1_LINES_PER_SPE + (j-1);
            sprintf(temp_buf, "0 %d", pw_index);
            CLI_F_PwRemove(temp_buf);
         }
      }

      WP_Delay(300000);
      /* recreate PW in "old fasion way": just repeat the lines above */
      printf("\nRecreating all PWs\n");

      cd_index = 0;
      for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
      {
         for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
         {
            line_index = i*28 + j;
            pw_index = i*WTI_T1_LINES_PER_SPE + j;

            sprintf(temp_buf, "0 %d 48 48", line_index);/* The line index of this PW */
            CLI_F_PwConfigureUnframed(temp_buf);

            /* PWE3 channel configuration */
            CLI_F_Pwe3ChannelJitterBufferSize("0 32");
            CLI_F_Pwe3ChannelRxBufferSize("0 384");
            CLI_F_Pwe3ChannelStatmode("0 1");
            CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
            CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
            CLI_F_Pwe3ChannelUdpDummyMode("0 1");
            CLI_F_Pwe3ChannelTxUdcas("0 f");

            /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
            CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
            CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
            sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
            CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
            sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
            CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
            CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 198 0");
            CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
            CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
            /* Rx timing is used in differential mode */
            /* first global_active_cr_async_mode related to different CDs */
            if (clock_rec_pw[pw_index])
            {
               sprintf(temp_buf, "0 1 1 %d",cd_index);
               cd_index++;
            }
            else
               sprintf(temp_buf, "0 0 1 %d",pw_index);
            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
            /* Rx timing is not used */
            sprintf(temp_buf, "0 0 1 %d",pw_index);
            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

            /**************** PSN --> TDM IW *****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
            /* if clock recovery is set -> Tx timing is used */
            if (clock_rec_pw[pw_index])    /* lines 0-(N-1) use CR, all other don't */
               CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
            else
               CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#else
            /* if clock recovery is disable -> Tx timing is not used */
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#endif
            CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
            CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

            /**************** PSN --> TDM Tx binding*****************/

            /* CR master Rx and Tx direction */
            if (clock_rec_pw[pw_index])   /* pw 0-(N-1) use CR, all other don't */
            {

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
#if WTI_CESOP_RX_TIMING_ENABLE
               sprintf(temp_buf, "0 0 1 1 %d",pw_index);
               CLI_F_PwCreate(temp_buf); /* CR master */
#else
               /* CR master Tx direction */
               sprintf(temp_buf, "0 0 0 1 %d",pw_index);
               CLI_F_PwCreate(temp_buf); /* CR master */
#endif

#else /* not  WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
               /* CR master Rx  direction only */
               sprintf(temp_buf, "0 0 1 0 %d",pw_index);
               CLI_F_PwCreate(temp_buf); /* CR master */
#endif
#endif
            }
            else
            {

#if WTI_CESOP_RX_TIMING_ENABLE
               sprintf(temp_buf, "0 0 1 0 %d",pw_index);
               CLI_F_PwCreate(temp_buf); /* CR slave */
#else
               sprintf(temp_buf, "0 0 0 0 %d",pw_index);
               CLI_F_PwCreate(temp_buf);
#endif
            }

            if (clock_rec_pw[pw_index])
               sprintf(temp_buf, "0 %d 1",pw_index); /* line 1 is the master, all other slaves */
            else
               sprintf(temp_buf, "0 %d 0",pw_index);
            CLI_F_PwEnable(temp_buf);

         } /* end for (configure each line) */
      }
#endif

   } /* for loop */
   WP_Delay(300000);
   printf("\nLast iteration\n");
   if ((!WTI_CLOCK_REC_MODE)&&(WTI_CESOP_CLOCK_RECOVERY_ENABLE))
         {
            printf("Wait 30 seconds to give the data time to flow...\n");
            WP_Delay(30000000);
         }
         else
         {
            printf("Wait 15 seconds to give the data time to flow...\n");
            WP_Delay(15000000);
         }
   result = CLI_F_GlobalStatisticsCheck("0");
   if (result == WT_FAIL)
   {
      WTI_PRINT_ERROR(("\n Test Failed in last iteration\n"));
      return WT_FAIL;
   }
   else return WT_PASS;
}

#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE & WTI_CESOP_RX_TIMING_ENABLE)
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
WP_U32 CLI_F_105_SBI_E1_F_CR_NoCas_Two_Boards_1_CD_1_CT_63_line_addremove_PW(char *StrPrm)
{

   WP_U32 i, j, line_index, spe_index, cd_index, pw_index, res, cmd, iterations, index, result;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U8   clock_rec_lines[336] = {0}; /* list of master lines */
   WP_U8   clock_rec_pw[336] = {0}; /* list of master PWs */

   res = sscanf(StrPrm, "%d %d", &cmd, &iterations);
   if (res != 2 && res != 1)
   {
      WTI_TerminatePrintError("CLI_F_105_SBI_E1_U_CR_NoCas_Two_Boards_1_CD_1_CT_63_line_addremove_PW Invalid number of parameters", __LINE__);
      return WT_FAIL;
   }
   else if (res == 2)
   {
      if (iterations < 1)
      {
         WTI_TerminatePrintError("CLI_F_105_SBI_E1_U_CR_NoCas_Two_Boards_1_CD_1_CT_63_line_addremove_PW Invalid number of Iterations\n iterations is >0", __LINE__);
         return WT_FAIL;
      }
   }
   if (res == 1)
      iterations = 10;

   for (i = 0; i < 64; i++)
   {
      clock_rec_pw[i] = 1;
      clock_rec_lines[CLI_F_AttacheLineToPwNumber(i)] = 1;
   }

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }


   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */

   cd_index = 0;
   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;

         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */

         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */
         /* set ufe Tx and Rx direction */
         if (clock_rec_lines[line_index] == 1) /* line 1 use CR, all other don't */
            sprintf(temp_buf, "0 %d 3 3",line_index);
         else
            sprintf(temp_buf, "0 %d 3 2",line_index); /* line number >1 => don't use CR  */

         CLI_F_UfeTransferMode(temp_buf);

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cd_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }
         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, clock_trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cd_index);
            cd_index++;
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */

      }
   }


   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 3");

   CLI_F_UfeChipInitLineSetup("");

   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }

#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   cd_index = 0;
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_E1_LINES_PER_SPE + j;

         sprintf(temp_buf, "0 %d 64 64 32 0-31", line_index);/* The line index of this PW */
         CLI_F_PwConfigureFramed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 256");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CLOCK_REC_MODE
         /* Rx timing is used */
         if (clock_rec_pw[pw_index])   /* line 1 use CR, all other don't */
         {
            sprintf(temp_buf, "0 1 1 %d",cd_index);
            cd_index++;
         }
         else
            sprintf(temp_buf, "0 0 1 %d",pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
         /* Rx timing is not used */
         sprintf(temp_buf, "0 0 1 %d",pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

         /**************** PSN --> TDM IW *****************/
         /* if clock recovery is set -> Tx timing is used */
         if (clock_rec_pw[pw_index])    /* line 1 use CR, all other don't */
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/


         /* CR master Rx and Tx direction */
         if (clock_rec_pw[pw_index])   /* pw 1 use CR, all other don't */
         {
            sprintf(temp_buf, "0 0 1 1 %d",pw_index);
            CLI_F_PwCreate(temp_buf); /* CR master */
         }
         else
         {
            sprintf(temp_buf, "0 0 1 0 %d",pw_index);
            CLI_F_PwCreate(temp_buf); /* CR slave */
         }
         if (clock_rec_pw[pw_index])
            sprintf(temp_buf, "0 %d 1",pw_index); /* line 1 is the master, all other slaves */
         else
            sprintf(temp_buf, "0 %d 0",pw_index);
         CLI_F_PwEnable(temp_buf);

      } /* end for (configure each line) */
   } /* for i */


   /* test in loop */
   for (index=1; index <= iterations; index++)
   {
      printf("\nIteration number: %d\n", index);
      if ((!WTI_CLOCK_REC_MODE)&&(WTI_CESOP_CLOCK_RECOVERY_ENABLE))
            {
               printf("Wait 30 seconds to give the data time to flow...\n");
               WP_Delay(30000000);
            }
            else
            {
               printf("Wait 15 seconds to give the data time to flow...\n");
               WP_Delay(15000000);
            }

      result = CLI_F_GlobalStatisticsCheck("0");
      if (result == WT_FAIL)
      {
         WTI_PRINT_ERROR(("\n Test Failed in iteration number: %d\n", index));
         return WT_FAIL;
      }

      /* remove PWs */
      printf("Removing all PWs\n");
      for (i=N_ACTIVE_UFE_SBI_SPE; i>0; i--)
      {
         for (j=WTI_E1_LINES_PER_SPE; j>0; j--)
         {
            pw_index = (i-1)*WTI_E1_LINES_PER_SPE + (j-1);
            sprintf(temp_buf, "0 %d", pw_index);
            CLI_F_PwRemove(temp_buf);
         }
      }
      WP_Delay(300000);

      /* recreate PW in "old fasion way": just repeat the lines above */
      printf("\nRecreating all PWs\n");
      cd_index = 0;
      for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
      {
         for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
         {
            line_index = i*28 + j;
            pw_index = i*WTI_E1_LINES_PER_SPE + j;

            sprintf(temp_buf, "0 %d 64 64 32 0-31", line_index);/* The line index of this PW */
            CLI_F_PwConfigureFramed(temp_buf);

            /* PWE3 channel configuration */
            CLI_F_Pwe3ChannelJitterBufferSize("0 32");
            CLI_F_Pwe3ChannelRxBufferSize("0 256");
            CLI_F_Pwe3ChannelStatmode("0 1");
            CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
            CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
            CLI_F_Pwe3ChannelUdpDummyMode("0 1");
            CLI_F_Pwe3ChannelTxUdcas("0 f");

            /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
            CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
            CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
            sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
            CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
            sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
            CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
            CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
            CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
            CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CLOCK_REC_MODE
            /* Rx timing is used */
            if (clock_rec_pw[pw_index])   /* line 1 use CR, all other don't */
            {
               sprintf(temp_buf, "0 1 1 %d",cd_index);
               cd_index++;
            }
            else
               sprintf(temp_buf, "0 0 1 %d",pw_index);
            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
            /* Rx timing is not used */
            sprintf(temp_buf, "0 0 1 %d",pw_index);
            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

            /**************** PSN --> TDM IW *****************/
            /* if clock recovery is set -> Tx timing is used */
            if (clock_rec_pw[pw_index])    /* line 1 use CR, all other don't */
               CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
            else
               CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
            CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
            CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

            /**************** PSN --> TDM Tx binding*****************/

            /* CR master Rx and Tx direction */
            if (clock_rec_pw[pw_index])   /* pw 1 use CR, all other don't */
            {
               sprintf(temp_buf, "0 0 1 1 %d",pw_index);
               CLI_F_PwCreate(temp_buf); /* CR master */
            }
            else
            {
               sprintf(temp_buf, "0 0 1 0 %d",pw_index);
               CLI_F_PwCreate(temp_buf); /* CR slave */
            }
            if (clock_rec_pw[pw_index])
               sprintf(temp_buf, "0 %d 1",pw_index); /* line 1 is the master, all other slaves */
            else
               sprintf(temp_buf, "0 %d 0",pw_index);
            CLI_F_PwEnable(temp_buf);

         } /* end for (configure each line) */
      } /* for i */

   } /* for loop */
   WP_Delay(300000);
   printf("\nLast iteration\n");
   if ((!WTI_CLOCK_REC_MODE)&&(WTI_CESOP_CLOCK_RECOVERY_ENABLE))
         {
            printf("Wait 30 seconds to give the data time to flow...\n");
            WP_Delay(30000000);
         }
         else
         {
            printf("Wait 15 seconds to give the data time to flow...\n");
            WP_Delay(15000000);
         }
   result = CLI_F_GlobalStatisticsCheck("0");
   if (result == WT_FAIL)
   {
      WTI_PRINT_ERROR(("\n Test Failed in last iteration\n"));
      return WT_FAIL;
   }
   else return WT_PASS;
}
#endif /* (WTI_CESOP_CLOCK_RECOVERY_ENABLE & WTI_CESOP_RX_TIMING_ENABLE) */

#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE & WTI_CESOP_RX_TIMING_ENABLE)
/***************************************************************
 * Func name  :
 * Description:
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
WP_U32 CLI_F_105_SBI_T1_F_CR_NoCas_Two_Boards_1_CD_1_CT_84_line_addremove_PW(char *StrPrm)
{
   WP_U32 i, j, line_index, spe_index, cd_index, pw_index, res, cmd, iterations, index, result;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U8   clock_rec_lines[336] = {0}; /* list of master lines */
   WP_U8   clock_rec_pw[336] = {0}; /* list of master PWs */

   res = sscanf(StrPrm, "%d %d", &cmd, &iterations);
   if (res != 2 && res != 1)
   {
      WTI_TerminatePrintError("CLI_F_105_SBI_E1_U_CR_NoCas_Two_Boards_1_CD_1_CT_63_line_addremove_PW Invalid number of parameters", __LINE__);
      return WT_FAIL;
   }
   else if (res == 2)
   {
      if (iterations < 1)
      {
         WTI_TerminatePrintError("CLI_F_105_SBI_E1_U_CR_NoCas_Two_Boards_1_CD_1_CT_63_line_addremove_PW Invalid number of Iterations\n iterations is >0", __LINE__);
         return WT_FAIL;
      }
   }
   if (res == 1)
      iterations = 10;

   for (i = 0; i < 64; i++)
   {
      clock_rec_pw[i] = 1;
      clock_rec_lines[i] = 1;
   }

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }


   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */

   cd_index = 0;
   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;

         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */

         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */
         /* set ufe Tx and Rx direction */
         if (clock_rec_lines[line_index] == 1) /* line 1 use CR, all other don't */
            sprintf(temp_buf, "0 %d 1 3",line_index);
         else
            sprintf(temp_buf, "0 %d 1 2",line_index); /* line number >1 => don't use CR  */

         CLI_F_UfeTransferMode(temp_buf);

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cd_index);
         }
         else
            /* conect all others to the first and second lines */
         {  /* duo to lack of space in port RAM */
            if (line_index < 168)
               sprintf(temp_buf, "0 %d 0", line_index);
            else
               sprintf(temp_buf, "0 %d 1", line_index);
         }
         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, clock_trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cd_index);
            cd_index++;
         }
         else
            /* conect all others to the first line */
         {
            if (line_index < 168)
               sprintf(temp_buf, "0 %d 0", line_index);
            else
               sprintf(temp_buf, "0 %d 1", line_index);
         }

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
      }
   }


   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 1");

   CLI_F_UfeChipInitLineSetup("");

   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }

#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif
#if 0
   printf("\n\n\n\n");
   status = WUFE_SystemDisplay(0);
   if (status != WP_OK)
   {
      printf("!!!!!!!!!! WUFE_SystemDisplay fail.\n");
      return;
   }
#endif

   cd_index = 0;
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_T1_LINES_PER_SPE + j;

         sprintf(temp_buf, "0 %d 48 48 24 0-23", line_index);/* The line index of this PW */
         CLI_F_PwConfigureFramed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 384");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 198 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CLOCK_REC_MODE
         /* Rx timing is used */
         if (clock_rec_pw[pw_index])   /* line 1 use CR, all other don't */
         {
            sprintf(temp_buf, "0 1 1 %d",cd_index);
            cd_index++;
         }
         else
            sprintf(temp_buf, "0 0 1 %d",pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
         /* Rx timing is not used */
         sprintf(temp_buf, "0 0 1 %d",pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

         /**************** PSN --> TDM IW *****************/
         /* if clock recovery is set -> Tx timing is used */
         if (clock_rec_pw[pw_index])    /* line 1 use CR, all other don't */
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/

         /* CR master Rx and Tx direction */
         if (clock_rec_pw[pw_index])   /* pw 1 use CR, all other don't */
            CLI_F_PwCreate("0 0 1 1"); /* CR master */
         else
            CLI_F_PwCreate("0 0 1 0"); /* CR slave */
         if (clock_rec_pw[pw_index])
            sprintf(temp_buf, "0 %d 1",pw_index); /* line 1 is the master, all other slaves */
         else
            sprintf(temp_buf, "0 %d 0",pw_index);
         CLI_F_PwEnable(temp_buf);

      } /* end for (configure each line) */
   }
#if 0
   printf("\n\n\n\n");
   status = WUFE_SystemDisplay(0);
   if (status != WP_OK)
   {
      printf("!!!!!!!!!! WUFE_SystemDisplay fail.\n");
      return;
   }
#endif

#if 0   /* This is the manual version of test, now doing automaticlly  */
   /***********************************************************************************/
   /***********************************************************************************/

   /* new function
   CLI_F_SBI_T1_F_AddRemovePW("0 5");*/


   /* run test in loop */
   while (exit_factor != '9')
   {

      printf("Test running.\nType 's' to print statistics, 'c' to clear statistics, '9' to quit or any other key to remove all PW.\n");
      exit_factor = getchar();
      if (exit_factor == '9')
      {
         printf("Exit test\n");
      }
      else if (exit_factor == 's')
      {
         printf("Check statistics:\n");
         sprintf(temp_buf, "0 %d", MAX_ACTIVE_PW);
         CLI_F_Pwe3StatisticsCheck(temp_buf);
         CLI_F_ClockRecSystemsStatisticsStatus("0");
      }
      else if (exit_factor == 'c')
      {
         printf("Clear statistics\n");
         sprintf(temp_buf, "0 %d", MAX_ACTIVE_PW);
         CLI_F_Pwe3StatisticsClear(temp_buf);
         CLI_F_ClockRecSystemsStatisticsReset("0");
      }
      else
      {
         /*       CLI_F_Psn2TdmFlowAggShowInfo("0 83");
            printf("Press any key to continue...\n");
            getchar(); */

         /* remove PWs */
         printf("..:: Removing PW.\n");
         WP_Delay(100000);

         for (i=N_ACTIVE_UFE_SBI_SPE; i>0; i--)
         {
            for (j=WTI_T1_LINES_PER_SPE; j>0; j--)
            {
               pw_index = (i-1)*WTI_T1_LINES_PER_SPE + (j-1);
               printf("PW to be removed: %d\n", pw_index);
               sprintf(temp_buf, "0 %d", pw_index);
               CLI_F_PwRemove(temp_buf);
            }
         }

         printf("PW removed. Press any key to continue...\n");
         exit_factor = getchar();
         if (exit_factor == '9')
            break;

         /* recreate PW in "old fasion way": just repeat the lines above */
         cd_index = 0;
         for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
         {
            for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
            {

               line_index = i*28 + j;
               pw_index = i*WTI_T1_LINES_PER_SPE + j;

               printf("..:: recreating PW %d... line_number is: %d\n", pw_index, line_index);

               sprintf(temp_buf, "0 %d 48 48 24 0-23", line_index);/* The line index of this PW */
               CLI_F_PwConfigureFramed(temp_buf);

               /* PWE3 channel configuration */
               CLI_F_Pwe3ChannelJitterBufferSize("0 32");
               CLI_F_Pwe3ChannelRxBufferSize("0 384");
               CLI_F_Pwe3ChannelStatmode("0 1");
               CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
               CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
               CLI_F_Pwe3ChannelUdpDummyMode("0 1");
               CLI_F_Pwe3ChannelTxUdcas("0 f");

               /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
               CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
               CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
               sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
               CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
               sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
               CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
               CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 198 0");
               CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
               CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CLOCK_REC_MODE
               /* Rx timing is used */
               if (clock_rec_pw[pw_index])   /* line 1 use CR, all other don't */
               {
                  sprintf(temp_buf, "0 1 1 %d",pw_index);
                  cd_index++;
               }
               else
                  sprintf(temp_buf, "0 0 1 %d",pw_index);
               CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
               /* Rx timing is not used */
               sprintf(temp_buf, "0 0 1 %d",pw_index);
               CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

               /**************** PSN --> TDM IW *****************/
               /* if clock recovery is set -> Tx timing is used */
               if (clock_rec_pw[pw_index])    /* line 1 use CR, all other don't */
                  CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
               else
                  CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
               CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
               CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

               /**************** PSN --> TDM Tx binding*****************/

               /* CR master Rx and Tx direction */
               if (clock_rec_pw[pw_index])   /* pw 1 use CR, all other don't */
                  CLI_F_PwCreate("0 0 1 1"); /* CR master */
               else
                  CLI_F_PwCreate("0 0 1 0"); /* CR slave */
               if (clock_rec_pw[pw_index])
                  sprintf(temp_buf, "0 %d 1",pw_index); /* line 1 is the master, all other slaves */
               else
                  sprintf(temp_buf, "0 %d 0",pw_index);
               CLI_F_PwEnable(temp_buf);

            } /* end for (configure each line) */
         }

      } /*if exit_factor */
   } /* while */
#endif   // 0

   /***********************************************************************************/
   /***********************************************************************************/


   for (index=1; index <= iterations; index++)
   {
      printf("\nIteration number: %d\n", index);
      if ((!WTI_CLOCK_REC_MODE)&&(WTI_CESOP_CLOCK_RECOVERY_ENABLE))
            {
               printf("Wait 30 seconds to give the data time to flow...\n");
               WP_Delay(30000000);
            }
            else
            {
               printf("Wait 15 seconds to give the data time to flow...\n");
               WP_Delay(15000000);
            }

      result = CLI_F_GlobalStatisticsCheck("0");
      if (result == WT_FAIL)
      {
         WTI_PRINT_ERROR(("\n Test Failed in iteration number: %d\n", index));
         return WT_FAIL;
      }

      /*       CLI_F_Psn2TdmFlowAggShowInfo("0 83");
         printf("Press any key to continue...\n");
         getchar(); */

      /* remove PWs */
      printf("Removing all PWs\n");

      for (i=N_ACTIVE_UFE_SBI_SPE; i>0; i--)
      {
         for (j=WTI_T1_LINES_PER_SPE; j>0; j--)
         {
            pw_index = (i-1)*WTI_T1_LINES_PER_SPE + (j-1);
            sprintf(temp_buf, "0 %d", pw_index);
            CLI_F_PwRemove(temp_buf);
         }
      }

      WP_Delay(300000);
      /* recreate PW in "old fasion way": just repeat the lines above */
      printf("\nRecreating all PWs\n");

      cd_index = 0;
      for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
      {
         for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
         {

            line_index = i*28 + j;
            pw_index = i*WTI_T1_LINES_PER_SPE + j;

            sprintf(temp_buf, "0 %d 48 48 24 0-23", line_index);/* The line index of this PW */
            CLI_F_PwConfigureFramed(temp_buf);

            /* PWE3 channel configuration */
            CLI_F_Pwe3ChannelJitterBufferSize("0 32");
            CLI_F_Pwe3ChannelRxBufferSize("0 384");
            CLI_F_Pwe3ChannelStatmode("0 1");
            CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
            CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
            CLI_F_Pwe3ChannelUdpDummyMode("0 1");
            CLI_F_Pwe3ChannelTxUdcas("0 f");

            /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
            CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
            CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
            sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
            CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
            sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
            CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
            CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 198 0");
            CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
            CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CLOCK_REC_MODE
            /* Rx timing is used */
            if (clock_rec_pw[pw_index])   /* line 1 use CR, all other don't */
            {
               sprintf(temp_buf, "0 1 1 %d",pw_index);
               cd_index++;
            }
            else
               sprintf(temp_buf, "0 0 1 %d",pw_index);
            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
            /* Rx timing is not used */
            sprintf(temp_buf, "0 0 1 %d",pw_index);
            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

            /**************** PSN --> TDM IW *****************/
            /* if clock recovery is set -> Tx timing is used */
            if (clock_rec_pw[pw_index])    /* line 1 use CR, all other don't */
               CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
            else
               CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
            CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
            CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

            /**************** PSN --> TDM Tx binding*****************/

            /* CR master Rx and Tx direction */
            if (clock_rec_pw[pw_index])   /* pw 1 use CR, all other don't */
               CLI_F_PwCreate("0 0 1 1"); /* CR master */
            else
               CLI_F_PwCreate("0 0 1 0"); /* CR slave */
            if (clock_rec_pw[pw_index])
               sprintf(temp_buf, "0 %d 1",pw_index); /* line 1 is the master, all other slaves */
            else
               sprintf(temp_buf, "0 %d 0",pw_index);
            CLI_F_PwEnable(temp_buf);

         } /* end for (configure each line) */
      }

   } /* for loop */
   WP_Delay(300000);
   printf("\nLast iteration\n");
   if ((!WTI_CLOCK_REC_MODE)&&(WTI_CESOP_CLOCK_RECOVERY_ENABLE))
         {
            printf("Wait 30 seconds to give the data time to flow...\n");
            WP_Delay(30000000);
         }
         else
         {
            printf("Wait 15 seconds to give the data time to flow...\n");
            WP_Delay(15000000);
         }
   result = CLI_F_GlobalStatisticsCheck("0");
   if (result == WT_FAIL)
   {
      WTI_PRINT_ERROR(("\n Test Failed in last iteration\n"));
      return WT_FAIL;
   }
   else return WT_PASS;
}
#endif /* (WTI_CESOP_CLOCK_RECOVERY_ENABLE & WTI_CESOP_RX_TIMING_ENABLE) */

#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE & WTI_CESOP_RX_TIMING_ENABLE)
/***************************************************************
 * Func name  :
 * Description:
 *             This test runs with RX and TX CR modules with 2 CD.
 *             The "Master" lines are '0' and 'second_cr_line' (lines with TX CR).
 *             After all lines were initialize and the test runs, some lines are been moved
 *             from shaper to shaper (By remove PW, disable the line, modify and recreate it
 *             and recreate the assosiate PW).
 *             initial setup:
 *                TDM2PSN: Test uses 2 CD for the first N PWs (PW=line in this case).
 *                         Each CD uses different shaper. All PWs > N use the first shaper.
 *                PSN2TDM: First N PWs are connected to N CTs respectively. PWs N+1 and forward
 *                         are connected to CT0.
 *             (*) N = "global_active_cr_async_mode"
 ***************************************************************/
void CLI_F_106_SBI_E1_U_CR_NoCas_Two_Boards_1_CD_1_CT_63_line_with_shaper_modify(char *StrPrm)
{
   int NUM = 3; /* NUM is the size of the modify arrays */
   WP_U32 i, j;
   WP_U32 line_index, spe_index, pw_index, second_cr_pw, cd_index, shaper_index;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_CHAR exit_factor = '0';
   WUFE_line_sbi_reconfig new_ufe_line_config;
   WUFE_status ufe_status;
   int second_cr_line = 6;
   int modify_line1 = 4;
   int modify_line2 = second_cr_line;
   int modify_line3 = 30;
   /* used for running with 1 line only; change NUM to '1' and mark the 'WT_UfeLineSbiModify' functions.
   int modify_line[] = {modify_line1};
   int modify_pw[] = {CLI_F_AttachePwToLineNumber(modify_line[0])};*/
   int modify_line[] = {modify_line1, modify_line2, modify_line3};
   int modify_pw[] = {CLI_F_AttachePwToLineNumber(modify_line[0]),
         CLI_F_AttachePwToLineNumber(modify_line[1]),
         CLI_F_AttachePwToLineNumber(modify_line[2])};
   int new_shaper_location[] = {0, 0, 0}; /* Create with the same size as modify_line */

   WP_U8   tx_clock_rec_lines[336] = {0}; /* list of master lines */
   WP_U8   tx_clock_rec_pw[336 * WTI_PW_PER_LINE] = {0}; /* list of master pw */

   if (WTI_PW_PER_LINE != 1)
   {
      WTI_TerminatePrintError("ERROR - currently, this test can not work with WTI_PW_PER_LINE != 1\n",
                              __LINE__);
      return;
   }

   /* define the CR master lines array */
   tx_clock_rec_lines[0] = 1;
   tx_clock_rec_lines[second_cr_line] = 1;
   /* attached PW number to line number */
   second_cr_pw = CLI_F_AttachePwToLineNumber(second_cr_line);

   /* define the CR master PWs array */
   tx_clock_rec_pw[0] = 1;
   tx_clock_rec_pw[second_cr_pw] = 1;

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;

         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */

         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */
         /* set ufe Tx and Rx direction */
         if (tx_clock_rec_lines[line_index] == 1) /* lines 0-(N-1) use CR, all other don't */
            sprintf(temp_buf, "0 %d 4 3",line_index);
         else
            sprintf(temp_buf, "0 %d 4 2",line_index); /* lines number >N => use RX CR only */

         CLI_F_UfeTransferMode(temp_buf);

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (line_index < second_cr_line)
         {
            sprintf(temp_buf, "0 %d %d", line_index, 0);
         }
         else

         {
            sprintf(temp_buf, "0 %d %d", line_index, 1);
         }
         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, clock_trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (line_index < second_cr_line)
         {
            sprintf(temp_buf, "0 %d %d", line_index, 0);
         }
         else

         {
            sprintf(temp_buf, "0 %d %d", line_index, 1);
         }
         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, shper_id */
      }
   }
   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 2");

   CLI_F_UfeChipInitLineSetup("");

   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (tx_clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }

#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   cd_index = 0;
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_E1_LINES_PER_SPE + j;

         sprintf(temp_buf, "0 %d %d 32 32", line_index, pw_index);/* The line index of this PW */
         CLI_F_PwConfigureUnframed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 256");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CLOCK_REC_MODE

         /* Rx timing is used in differential mode */
         /* first global_active_cr_async_mode related to different CDs */
         if (tx_clock_rec_pw[pw_index] == 1)
         {
            printf("cd_index= %d, pw_index = %d\n", cd_index, pw_index);
            sprintf(temp_buf, "0 1 1 %d",cd_index);
            cd_index++;
         }
         else
         {/* In differential mode all other pw (not first ones) uses CD#0 */
            printf("cd_index= %d, pw_index = %d\n", cd_index-1, pw_index);
            sprintf(temp_buf, "0 0 1 %d",cd_index-1);/*due to cd_index++ at PW0*/
         }
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else

         /* Rx timing is not used */
         sprintf(temp_buf, "0 0 1 %d",pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

         /**************** PSN --> TDM IW *****************/
         /* if clock recovery is set -> Tx timing is used */
         if (tx_clock_rec_pw[pw_index] == 1)    /* lines 0-(N-1) use CR, all other don't */
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/

         /* CR Rx and Tx direction */
         if (tx_clock_rec_pw[pw_index] == 1) /* pw 0-(N-1) use CR, all other don't */
         {
            sprintf(temp_buf, "0 0 1 1 %d",pw_index);
            CLI_F_PwCreate(temp_buf); /* CR master */
         }

         else
         {
            sprintf(temp_buf, "0 0 1 0 %d",pw_index);
            CLI_F_PwCreate(temp_buf); /* CR slave */
         }

         if (tx_clock_rec_pw[pw_index] == 1)
            sprintf(temp_buf, "0 %d 1",pw_index); /* line 1 is the master, all other slaves */
         else
            sprintf(temp_buf, "0 %d 0",pw_index);
         CLI_F_PwEnable(temp_buf);

      } /* end for (configure each line) */
   }

   while (exit_factor != '9')
   {

      printf("Test running.\nType 's' to see statistics, 'c' to clean statistics, '9' to quit or any other key to modify shapers.\n");
      printf(" 1- line %d\n 2- line %d (second CR)\n 3- line %d\n",
             modify_line1, modify_line2, modify_line3);
      exit_factor = getchar();
      if (exit_factor == '9')
      {
         printf("Exit test\n");
      }
      else if (exit_factor == 's')
      {
         printf("Check statistics:\n");
         sprintf(temp_buf, "0 %d", N_ACTIVE_UFE_SBI_SPE*WTI_E1_LINES_PER_SPE);
         CLI_F_Pwe3StatisticsCheck(temp_buf);
         CLI_F_ClockRecSystemsStatisticsStatus("0");
      }
      else if (exit_factor == 'c')
      {
         printf("Clear statistics\n");
         sprintf(temp_buf, "0 %d", N_ACTIVE_UFE_SBI_SPE*WTI_E1_LINES_PER_SPE);
         CLI_F_Pwe3StatisticsClear(temp_buf);
         CLI_F_ClockRecSystemsStatisticsReset("0");
      }
      else if (exit_factor == '1')
      {
         CLI_F_TransDevShowInfo("0 4 4");
      }
      else if (exit_factor == '2')
      {
         CLI_F_TransDevShowInfo("0 6 6");
      }
      else if (exit_factor == '3')
      {
         CLI_F_TransDevShowInfo("0 30 23");
      }
      else
      {

         /* This section reconfigure the shaper for modify_line1 */
         /* remove PW -> disable line -> modify line configuration -> enable line -> recreate and reenable PW */
         /* -------------------------------------------------------------------------------------------- */

         /* PW remove: */
         for (i=0; i<NUM; i++)
         {
            printf("remove PW %d\n", modify_pw[i]);
            sprintf(temp_buf, "0 %d", modify_pw[i]);
            CLI_F_PwRemove(temp_buf);
         }

         /* line disable: */
         for (i=0; i<NUM; i++)
         {
            printf("Disable line: %d\n", modify_line[i]);
            ufe_status = WUFE_LineDisable(
                                          (&the_system->ufe)->line_handle[modify_line[i]], WUFE_FULL_DUPLEX);
            WT_UfeTerminateOnError(ufe_status, "WUFE_LineDisable", modify_line[i], __LINE__);
         }

         /* line modify: */
         printf("Modify lines\n");
         memset(&new_ufe_line_config, 0xff, sizeof(WUFE_line_sbi_reconfig));
         /* move line to shaper 1 as slave */
         new_ufe_line_config.clock_rec_mode = WUFE_LINE_CLOCK_REC_ENABLE_RX;
         new_ufe_line_config.rx_clk_rec_if = 1;
         WT_UfeLineSbiModify(&(the_system->ufe), modify_line[0], &new_ufe_line_config);
         new_shaper_location[0] = new_ufe_line_config.rx_clk_rec_if;
         /* move master line to shaper 0 as slave but keep the TX direction working (TX CR on CT1) */
         new_ufe_line_config.clock_rec_mode = WUFE_LINE_CLOCK_REC_ENABLE_DUPLEX;
         new_ufe_line_config.rx_clk_rec_if = 0;
         new_ufe_line_config.clock_translator_id = 1; /* not really required */
         new_ufe_line_config.tx_clk_master = WUFE_LINE_CLOCK_MASTER; /* not really required */
         WT_UfeLineSbiModify(&(the_system->ufe), modify_line[1], &new_ufe_line_config);
         new_shaper_location[1] = new_ufe_line_config.rx_clk_rec_if;
         /* move line to shaper 0 as slave */
         new_ufe_line_config.clock_rec_mode = WUFE_LINE_CLOCK_REC_ENABLE_RX;
         new_ufe_line_config.rx_clk_rec_if = 0;
         WT_UfeLineSbiModify(&(the_system->ufe), modify_line[2], &new_ufe_line_config);
         new_shaper_location[2] = new_ufe_line_config.rx_clk_rec_if;

         printf("line modified. press any key to continue...\n");
         getchar();

         /* line enable: */
         for (i=0; i<NUM; i++)
         {
            printf("Enable line: %d\n", modify_line[i]);
            ufe_status = WUFE_LineEnable((&the_system->ufe)->line_handle[modify_line[i]], WUFE_FULL_DUPLEX);
            WT_UfeTerminateOnError(ufe_status, "SBI WUFE_LineEnable", modify_line[i], __LINE__);
         }

         /* recreate PW: */
         for (i=0; i<NUM; i++)
         {
            line_index = modify_line[i];
            pw_index = modify_pw[i];

            sprintf(temp_buf, "0 %d %d 32 32", line_index, pw_index);/* The line index of this PW */
            CLI_F_PwConfigureUnframed(temp_buf);

            /* PWE3 channel configuration */
            CLI_F_Pwe3ChannelJitterBufferSize("0 32");
            CLI_F_Pwe3ChannelRxBufferSize("0 256");
            CLI_F_Pwe3ChannelStatmode("0 1");
            CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
            CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
            CLI_F_Pwe3ChannelUdpDummyMode("0 1");
            CLI_F_Pwe3ChannelTxUdcas("0 f");

            /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
            CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
            CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
            sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
            CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
            sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
            CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
            CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
            CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
            CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

            shaper_index = 0;
#if WTI_CLOCK_REC_MODE

            /* Rx timing is used in differential mode */
            /* first global_active_cr_async_mode related to different CDs */
            if (tx_clock_rec_pw[pw_index] == 1)
            {
               shaper_index = new_shaper_location[i];
               sprintf(temp_buf, "0 1 1 %d",shaper_index);
            }
            else
            {/* In differential mode all other pw (not first ones) uses CD#0 */
               shaper_index = new_shaper_location[i];
               sprintf(temp_buf, "0 0 1 %d",shaper_index);
            }

            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
            /* Rx timing is not used */
            sprintf(temp_buf, "0 0 1 %d",pw_index);
            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

            /**************** PSN --> TDM IW *****************/
            /* if clock recovery is set -> Tx timing is used */
            if (tx_clock_rec_pw[pw_index] == 1)    /* lines 0-(N-1) use CR, all other don't */
               CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
            else
               CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */

            CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
            CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

            /**************** PSN --> TDM Tx binding*****************/

            /* CR Rx and Tx direction */
            if (tx_clock_rec_pw[pw_index] == 1) /* pw 0-(N-1) use CR, all other don't */
            {
               sprintf(temp_buf, "0 0 1 1 %d",pw_index);
               CLI_F_PwCreate(temp_buf); /* CR master */
            }

            else
            {
               sprintf(temp_buf, "0 0 1 0 %d",pw_index);
               CLI_F_PwCreate(temp_buf); /* CR slave */
            }

            if (tx_clock_rec_pw[pw_index] == 1)
               sprintf(temp_buf, "0 %d 1",pw_index); /* line is tx master */
            else
               sprintf(temp_buf, "0 %d 0",pw_index);
            CLI_F_PwEnable(temp_buf);

         }

         /*print PW info:*/
         /*sprintf(temp_buf, "0 %d %d", modify_line1, modify_line1);
           CLI_F_TransDevShowInfo(temp_buf);
           sprintf(temp_buf, "0 %d %d", modify_line1+1, modify_line1+1);
           CLI_F_TransDevShowInfo(temp_buf);*/

      } /*if exit_factor */
   } /*while */
}
#endif /* (WTI_CESOP_CLOCK_RECOVERY_ENABLE & WTI_CESOP_RX_TIMING_ENABLE) */

#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE & WTI_CESOP_RX_TIMING_ENABLE)
/***************************************************************
 * Func name  :
 * Description:
 *             This test runs with RX and TX CR modules with 2 CD.
 *             The "Master" lines are '0' and 'second_cr_line' (lines with TX CR).
 *             After all lines were initialize and the test runs, some lines are been moved
 *             from shaper to shaper (By remove PW, disable the line, modify and recreate it
 *             and recreate the assosiate PW).
 *             initial setup:
 *                TDM2PSN: Test uses 2 CD for the first N PWs (PW=line in this case).
 *                         Each CD uses different shaper. All PWs > N use the first shaper.
 *                PSN2TDM: First N PWs are connected to N CTs respectively. PWs N+1 and forward
 *                         are connected to CT0.
 *             second_cr_line can run from 80 to 255. If second_cr_line is lower than 80 or bigger
 *             than 255, an error WUFE_ERR_CLOCK_REC_NO_FREE_RAM_ENTRY will rise.
 *
 *             (*) N = "global_active_cr_async_mode"
 ***************************************************************/
void CLI_F_106_SBI_T1_U_CR_NoCas_Two_Boards_1_CD_1_CT_84_line_with_shaper_modify(char *StrPrm)
{
   int NUM = 3; /* NUM is the size of the modify arrays */
   WP_U32 i, j, line_index, spe_index, pw_index, second_cr_pw, ct_index;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_CHAR exit_factor = '0';
   WUFE_line_sbi_reconfig new_ufe_line_config;
   WUFE_status ufe_status;
   int second_cr_line = 168;
   int modify_line1 = 3;
   int modify_line2 = 8;
   int modify_line3 = second_cr_line;
   /* used for running with 1 line only; change NUM to '1' and mark the 'WT_UfeLineSbiModify' functions.
   int modify_line[] = {modify_line1};
   int modify_pw[] = {modify_line[0]}; */
   int modify_line[] = {modify_line1, modify_line2, modify_line3};
   int modify_pw[] = {modify_line[0],
         modify_line[1],
         modify_line[2]};
   int new_shaper_location[] = {0, 0, 0}; /* Create with the same size as modify_line */

   WP_U8   tx_clock_rec_lines[336] = {0}; /* list of master lines */
   WP_U8   tx_clock_rec_pw[336 * WTI_PW_PER_LINE] = {0}; /* list of master pw */

   if (WTI_PW_PER_LINE != 1)
   {
      printf("ERROR - currently, this test can not work with WTI_PW_PER_LINE != 1\n");
      exit(1);
   }
   /* define the CR master lines array */
   tx_clock_rec_lines[0] = 1;
   tx_clock_rec_lines[second_cr_line] = 1;
   /* attached PW number to line number */
   second_cr_pw = second_cr_line;

   /* define the CR master PWs array */
   tx_clock_rec_pw[0] = 1;
   tx_clock_rec_pw[second_cr_pw] = 1;

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;

         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */

         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */
         /* set ufe Tx and Rx direction */
         if (tx_clock_rec_lines[line_index] == 1) /* lines 0-(N-1) use CR, all other don't */
            sprintf(temp_buf, "0 %d 2 3",line_index);
         else
            sprintf(temp_buf, "0 %d 2 2",line_index); /* lines number >N => use RX CR only */

         CLI_F_UfeTransferMode(temp_buf);

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (line_index < second_cr_line)
         {
            sprintf(temp_buf, "0 %d %d", line_index, 0);
         }
         else

         {
            sprintf(temp_buf, "0 %d %d", line_index, 1);
         }
         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, clock_trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (line_index < second_cr_line)
         {
            sprintf(temp_buf, "0 %d %d", line_index, 0);
         }
         else

         {
            sprintf(temp_buf, "0 %d %d", line_index, 1);
         }
         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, shper_id */
      }
   }
   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 0");

   CLI_F_UfeChipInitLineSetup("");

   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (tx_clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }

#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   ct_index = 0;
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_T1_LINES_PER_SPE + j;

         sprintf(temp_buf, "0 %d %d 48 48", line_index, pw_index);/* The line index of this PW */


         CLI_F_PwConfigureUnframed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 384");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 198 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CLOCK_REC_MODE

         /* Rx timing is used in differential mode */
         /* first global_active_cr_async_mode related to different CDs */
         if (tx_clock_rec_pw[pw_index] == 1)
         {
            sprintf(temp_buf, "0 1 1 %d",ct_index);
            ct_index++;
         }
         else
         {/* In differential mode all other pw (not first ones) uses CD#0 */
            sprintf(temp_buf, "0 0 1 %d",ct_index-1);/*due to ct_index++ at PW0*/
         }
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else

         /* Rx timing is not used */
         sprintf(temp_buf, "0 0 1 %d",pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

         /**************** PSN --> TDM IW *****************/
         /* if clock recovery is set -> Tx timing is used */
         if (tx_clock_rec_pw[pw_index] == 1)    /* lines 0-(N-1) use CR, all other don't */
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/

         /* CR Rx and Tx direction */
         if (tx_clock_rec_pw[pw_index] == 1) /* pw 0-(N-1) use CR, all other don't */
         {
            sprintf(temp_buf, "0 0 1 1 %d",pw_index);
            CLI_F_PwCreate(temp_buf); /* CR master */
         }

         else
         {
            sprintf(temp_buf, "0 0 1 0 %d",pw_index);
            CLI_F_PwCreate(temp_buf); /* CR slave */
         }

         if (tx_clock_rec_pw[pw_index] == 1)
            sprintf(temp_buf, "0 %d 1",pw_index); /* line 1 is the master, all other slaves */
         else
            sprintf(temp_buf, "0 %d 0",pw_index);
         CLI_F_PwEnable(temp_buf);

      } /* end for (configure each line) */
   }

   while (exit_factor != '9')
   {
      printf("Test running.\nType 's' to print statistics, 'c' to clear statistics, '9' to quit or any other key to modify shapers.\n");
      printf(" 1- line %d\n 2- line %d (second CR)\n 3- line %d\n",
             modify_line1, modify_line2, modify_line3);
      exit_factor = getchar();
      if (exit_factor == '9')
      {
         printf("Exit test\n");
      }
      else if (exit_factor == 's')
      {
         printf("Check statistics:\n");
         sprintf(temp_buf, "0 %d", N_ACTIVE_UFE_SBI_SPE*WTI_E1_LINES_PER_SPE);
         CLI_F_Pwe3StatisticsCheck(temp_buf);
         CLI_F_ClockRecSystemsStatisticsStatus("0");
      }
      else if (exit_factor == 'c')
      {
         printf("Clear statistics\n");
         sprintf(temp_buf, "0 %d", N_ACTIVE_UFE_SBI_SPE*WTI_E1_LINES_PER_SPE);
         CLI_F_Pwe3StatisticsClear(temp_buf);
         CLI_F_ClockRecSystemsStatisticsReset("0");
      }
      else if (exit_factor == '1')
      {
         CLI_F_TransDevShowInfo("0 3 3");
      }
      else if (exit_factor == '2')
      {
         CLI_F_TransDevShowInfo("0 8 8");
      }
      else if (exit_factor == '3')
      {
         CLI_F_TransDevShowInfo("0 168 168");
      }
      else
      {

         /* This section reconfigure the shaper for modify_line1 */
         /* remove PW -> disable line -> modify line configuration -> enable line -> recreate and reenable PW */
         /* -------------------------------------------------------------------------------------------- */
         /*sprintf(temp_buf, "0 %d %d", modify_line1, modify_line1);
           CLI_F_TransDevShowInfo(temp_buf);*/

         /* PW remove: */
         for (i=0; i<NUM; i++)
         {
            printf("remove PW %d\n", modify_pw[i]);
            sprintf(temp_buf, "0 %d", modify_pw[i]);
            CLI_F_PwRemove(temp_buf);
         }


         /* line disable: */
         for (i=0; i<NUM; i++)
         {
            printf("Disable line: %d\n", modify_line[i]);
            ufe_status = WUFE_LineDisable(
                                          (&the_system->ufe)->line_handle[modify_line[i]], WUFE_FULL_DUPLEX);
            WT_UfeTerminateOnError(ufe_status, "WUFE_LineDisable", modify_line[i], __LINE__);
         }


         /* line modify: */
         printf("Modify lines\n");
         memset(&new_ufe_line_config, 0xff, sizeof(WUFE_line_sbi_reconfig));
         /* move line to shaper 1 as slave */
         new_ufe_line_config.clock_rec_mode = WUFE_LINE_CLOCK_REC_ENABLE_RX;
         new_ufe_line_config.rx_clk_rec_if = 1;
         WT_UfeLineSbiModify(&(the_system->ufe), modify_line[0], &new_ufe_line_config);
         new_shaper_location[0] = new_ufe_line_config.rx_clk_rec_if;
         /* no changes in line, recreate original */
         new_ufe_line_config.clock_rec_mode = WUFE_LINE_CLOCK_REC_ENABLE_RX;
         new_ufe_line_config.rx_clk_rec_if = 0;
         WT_UfeLineSbiModify(&(the_system->ufe), modify_line[1], &new_ufe_line_config);
         new_shaper_location[1] = new_ufe_line_config.rx_clk_rec_if;
         /*  move master line to shaper 0 as slave but keep the TX direction as master */
         new_ufe_line_config.clock_rec_mode = WUFE_LINE_CLOCK_REC_ENABLE_DUPLEX;
         new_ufe_line_config.rx_clk_rec_if = 0;
         new_ufe_line_config.clock_translator_id = 1; /* not really required */
         new_ufe_line_config.tx_clk_master = WUFE_LINE_CLOCK_MASTER; /* not really required */
         WT_UfeLineSbiModify(&(the_system->ufe), modify_line[2], &new_ufe_line_config);
         new_shaper_location[2] = new_ufe_line_config.rx_clk_rec_if;

         printf("line modified. press any key to continue...\n");
         getchar();

         /* line enable: */
         for (i=0; i<NUM; i++)
         {
            printf("Enable line: %d\n", modify_line[i]);
            ufe_status = WUFE_LineEnable((&the_system->ufe)->line_handle[modify_line[i]], WUFE_FULL_DUPLEX);
            WT_UfeTerminateOnError(ufe_status, "SBI WUFE_LineEnable", modify_line[i], __LINE__);
         }

         /* recreate PW: */

         for (i=0; i<NUM; i++)
         {
            line_index = modify_line[i];
            pw_index = modify_pw[i];

            sprintf(temp_buf, "0 %d %d 48 48", line_index, pw_index);/* The line index of this PW */
            CLI_F_PwConfigureUnframed(temp_buf);

            /* PWE3 channel configuration */
            CLI_F_Pwe3ChannelJitterBufferSize("0 32");
            CLI_F_Pwe3ChannelRxBufferSize("0 384");
            CLI_F_Pwe3ChannelStatmode("0 1");
            CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
            CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
            CLI_F_Pwe3ChannelUdpDummyMode("0 1");
            CLI_F_Pwe3ChannelTxUdcas("0 f");

            /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
            CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
            CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
            sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
            CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
            sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
            CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
            CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 198 0");
            CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
            CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CLOCK_REC_MODE

            /* Rx timing is used in differential mode */
            /* first global_active_cr_async_mode related to different CDs */
            if (tx_clock_rec_pw[pw_index] == 1)
            {
               if (pw_index >= second_cr_pw)
                  ct_index = 1;
               else
                  ct_index = 0;
               sprintf(temp_buf, "0 1 1 %d",ct_index);
               ct_index++;
            }
            else
            {/* In differential mode all other pw (not first ones) uses CD#0 */
               if (pw_index >= second_cr_pw)
                  ct_index = 1;
               else
                  ct_index = 0;
               sprintf(temp_buf, "0 0 1 %d",ct_index);
            }

            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else

            /* Rx timing is not used */
            sprintf(temp_buf, "0 0 1 %d",pw_index);
            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

            /**************** PSN --> TDM IW *****************/
            /* if clock recovery is set -> Tx timing is used */
            if (tx_clock_rec_pw[pw_index] == 1)    /* lines 0-(N-1) use CR, all other don't */
               CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
            else
               CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */

            CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
            CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

            /**************** PSN --> TDM Tx binding*****************/

            /* CR Rx and Tx direction */
            if (tx_clock_rec_pw[pw_index] == 1) /* pw 0-(N-1) use CR, all other don't */
            {
               sprintf(temp_buf, "0 0 1 1 %d",pw_index);
               CLI_F_PwCreate(temp_buf); /* CR master */
            }

            else
            {
               sprintf(temp_buf, "0 0 1 0 %d",pw_index);
               CLI_F_PwCreate(temp_buf); /* CR slave */
            }

            if (tx_clock_rec_pw[pw_index] == 1)
               sprintf(temp_buf, "0 %d 1",pw_index); /* line 1 is the master, all other slaves */
            else
               sprintf(temp_buf, "0 %d 0",pw_index);
            CLI_F_PwEnable(temp_buf);

         }

         /*print PW info:*/
         /*sprintf(temp_buf, "0 %d %d", modify_line1, modify_line1);
           CLI_F_TransDevShowInfo(temp_buf);*/


      } /*if exit_factor */
   }
}
#endif /* (WTI_CESOP_CLOCK_RECOVERY_ENABLE & WTI_CESOP_RX_TIMING_ENABLE) */

#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE & WTI_CESOP_RX_TIMING_ENABLE)
/***************************************************************
 * Func name  :
 * Description:
 *             This test runs with RX and TX CR modules with 2 CD.
 *             The "Master" lines are '0' and 'second_cr_line' (lines with TX CR).
 *             After all lines were initialize and the test runs, some lines are been moved
 *             from shaper to shaper (By remove PW, disable the line, modify and recreate it
 *             and recreate the assosiate PW).
 *             initial setup:
 *                TDM2PSN: Test uses 2 CD for the first N PWs (PW=line in this case).
 *                         Each CD uses different shaper. All PWs > N use the first shaper.
 *                PSN2TDM: First N PWs are connected to N CTs respectively. PWs N+1 and forward
 *                         are connected to CT0.
 *             (*) N = "global_active_cr_async_mode"
 ***************************************************************/
void CLI_F_106_SBI_E1_F_CR_NoCas_Two_Boards_1_CD_1_CT_63_line_with_shaper_modify(char *StrPrm)
{
   int NUM = 3; /* NUM is the size of the modify arrays */
   WP_U32 i, j, line_index, spe_index, pw_index, second_cr_pw, ct_index;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_CHAR exit_factor = '0';
   WUFE_line_sbi_reconfig new_ufe_line_config;
   WUFE_status ufe_status;
   int second_cr_line = 6;
   int modify_line1 = 3;
   int modify_line2 = second_cr_line;
   int modify_line3 = 20;
   /* used for running with 1 line only; change NUM to '1' and mark the 'WT_UfeLineSbiModify' functions.
   int modify_line[] = {modify_line1};
   int modify_pw[] = {CLI_F_AttachePwToLineNumber(modify_line[0])};*/
   int modify_line[] = {modify_line1, modify_line2, modify_line3};
   int modify_pw[] = {CLI_F_AttachePwToLineNumber(modify_line[0]),
         CLI_F_AttachePwToLineNumber(modify_line[1]),
         CLI_F_AttachePwToLineNumber(modify_line[2])};
   int new_shaper_location[] = {0, 0, 0}; /* Create with the same size as modify_line */

   WP_U8   tx_clock_rec_lines[336] = {0}; /* list of master lines */
   WP_U8   tx_clock_rec_pw[336 * WTI_PW_PER_LINE] = {0}; /* list of master pw */

   if (WTI_PW_PER_LINE != 1)
   {
      printf("ERROR - currently, this test can not work with WTI_PW_PER_LINE != 1\n");
      exit(1);
   }
   /* define the CR master lines array */
   tx_clock_rec_lines[0] = 1;
   tx_clock_rec_lines[second_cr_line] = 1;
   /* attached PW number to line number */
   second_cr_pw = CLI_F_AttachePwToLineNumber(second_cr_line);

   /* define the CR master PWs array */
   tx_clock_rec_pw[0] = 1;
   tx_clock_rec_pw[second_cr_pw] = 1;

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;

         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */

         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */
         /* set ufe Tx and Rx direction */
         if (tx_clock_rec_lines[line_index] == 1) /* lines 0-(N-1) use CR, all other don't */
            sprintf(temp_buf, "0 %d 3 3",line_index);
         else
            sprintf(temp_buf, "0 %d 3 2",line_index); /* lines number >N => use RX CR only */

         CLI_F_UfeTransferMode(temp_buf);

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (line_index < second_cr_line)
         {
            sprintf(temp_buf, "0 %d %d", line_index, 0);
         }
         else

         {
            sprintf(temp_buf, "0 %d %d", line_index, 1);
         }
         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, clock_trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (line_index < second_cr_line)
         {
            sprintf(temp_buf, "0 %d %d", line_index, 0);
         }
         else

         {
            sprintf(temp_buf, "0 %d %d", line_index, 1);
         }
         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, shper_id */
      }
   }
   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 3");

   CLI_F_UfeChipInitLineSetup("");

   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (tx_clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }

#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   ct_index = 0;
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_E1_LINES_PER_SPE + j;

         sprintf(temp_buf, "0 %d %d 32 32 32 0-31", line_index, pw_index);/* The line index of this PW */
         CLI_F_PwConfigureFramed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 256");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CLOCK_REC_MODE

         /* Rx timing is used in differential mode */
         /* first global_active_cr_async_mode related to different CDs */
         if (tx_clock_rec_pw[pw_index] == 1)
         {
            sprintf(temp_buf, "0 1 1 %d",ct_index);
            ct_index++;
         }
         else
         {/* In differential mode all other pw (not first ones) uses CD#0 */
            sprintf(temp_buf, "0 0 1 %d",ct_index-1);
         }
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else

         /* Rx timing is not used */
         sprintf(temp_buf, "0 0 1 %d",pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

         /**************** PSN --> TDM IW *****************/
         /* if clock recovery is set -> Tx timing is used */
         if (tx_clock_rec_pw[pw_index] == 1)    /* lines 0-(N-1) use CR, all other don't */
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/

         /* CR Rx and Tx direction */
         if (tx_clock_rec_pw[pw_index] == 1) /* pw 0-(N-1) use CR, all other don't */
         {
            sprintf(temp_buf, "0 0 1 1 %d",pw_index);
            CLI_F_PwCreate(temp_buf); /* CR master */
         }

         else
         {
            sprintf(temp_buf, "0 0 1 0 %d",pw_index);
            CLI_F_PwCreate(temp_buf); /* CR slave */
         }

         if (tx_clock_rec_pw[pw_index] == 1)
            sprintf(temp_buf, "0 %d 1",pw_index); /* line 1 is the master, all other slaves */
         else
            sprintf(temp_buf, "0 %d 0",pw_index);
         CLI_F_PwEnable(temp_buf);

      } /* end for (configure each line) */
   }

   while (exit_factor != '9')
   {
      printf("Test running.\nType 's' to print statistics, 'c' to clear statistics, '9' to quit or any other key to modify shapers.\n");
      printf(" 1- line %d\n 2- line %d (second CR)\n 3- line %d\n",
             modify_line1, modify_line2, modify_line3);
      exit_factor = getchar();
      if (exit_factor == '9')
      {
         printf("Exit test\n");
      }
      else if (exit_factor == 's')
      {
         printf("Check statistics:\n");
         sprintf(temp_buf, "0 %d", N_ACTIVE_UFE_SBI_SPE*WTI_E1_LINES_PER_SPE);
         CLI_F_Pwe3StatisticsCheck(temp_buf);
         CLI_F_ClockRecSystemsStatisticsStatus("0");
      }
      else if (exit_factor == 'c')
      {
         printf("Clear statistics\n");
         sprintf(temp_buf, "0 %d", N_ACTIVE_UFE_SBI_SPE*WTI_E1_LINES_PER_SPE);
         CLI_F_Pwe3StatisticsClear(temp_buf);
         CLI_F_ClockRecSystemsStatisticsReset("0");
      }
      else if (exit_factor == '1')
      {
         CLI_F_TransDevShowInfo("0 3 3");
      }
      else if (exit_factor == '2')
      {
         CLI_F_TransDevShowInfo("0 6 6");
      }
      else if (exit_factor == '3')
      {
         CLI_F_TransDevShowInfo("0 20 20");
      }
      else
      {

         /* This section reconfigure the shaper for modify_line1 */
         /* remove PW -> disable line -> modify line configuration -> enable line -> recreate and reenable PW */
         /* -------------------------------------------------------------------------------------------- */
         sprintf(temp_buf, "0 %d %d", modify_line1, modify_pw[0]);
         CLI_F_TransDevShowInfo(temp_buf);

         /* PW remove: */
         for (i=0; i<NUM; i++)
         {
            printf("remove PW %d\n", modify_pw[i]);
            sprintf(temp_buf, "0 %d", modify_pw[i]);
            CLI_F_PwRemove(temp_buf);
         }


         /* line disable: */
         for (i=0; i<NUM; i++)
         {
            ufe_status = WUFE_LineDisable(
                                          (&the_system->ufe)->line_handle[modify_line[i]], WUFE_FULL_DUPLEX);
            WT_UfeTerminateOnError(ufe_status, "WUFE_LineDisable", modify_line[i], __LINE__);
         }


         /* line modify: */
         printf("Modify lines\n");
         memset(&new_ufe_line_config, 0xff, sizeof(WUFE_line_sbi_reconfig));
         /* move line to shaper 1 as slave */
         new_ufe_line_config.clock_rec_mode = WUFE_LINE_CLOCK_REC_ENABLE_RX;
         new_ufe_line_config.rx_clk_rec_if = 1;
         WT_UfeLineSbiModify(&(the_system->ufe), modify_line[0], &new_ufe_line_config);
         new_shaper_location[0] = new_ufe_line_config.rx_clk_rec_if;
         /* move line to shaper 0 as slave, disable TX direction */
         new_ufe_line_config.clock_rec_mode = WUFE_LINE_CLOCK_REC_ENABLE_DUPLEX;
         new_ufe_line_config.rx_clk_rec_if = 0;
         WT_UfeLineSbiModify(&(the_system->ufe), modify_line[1], &new_ufe_line_config);
         new_shaper_location[1] = new_ufe_line_config.rx_clk_rec_if;
         /* move line to shaper 0 as slave */
         new_ufe_line_config.clock_rec_mode = WUFE_LINE_CLOCK_REC_ENABLE_RX;
         new_ufe_line_config.rx_clk_rec_if = 0;
         WT_UfeLineSbiModify(&(the_system->ufe), modify_line[2], &new_ufe_line_config);
         new_shaper_location[2] = new_ufe_line_config.rx_clk_rec_if;

         printf("line modified. press any key to continue...\n");
         getchar();

         /* line enable: */
         for (i=0; i<NUM; i++)
         {
            ufe_status = WUFE_LineEnable((&the_system->ufe)->line_handle[modify_line[i]], WUFE_FULL_DUPLEX);
            WT_UfeTerminateOnError(ufe_status, "SBI WUFE_LineEnable", modify_line[i], __LINE__);
         }

         /* recreate PW: */

         for (i=0; i<NUM; i++)
         {
            line_index = modify_line[i];
            pw_index = modify_pw[i];

            sprintf(temp_buf, "0 %d %d 32 32 32 0-31", line_index, pw_index);/* The line index of this PW */
            CLI_F_PwConfigureFramed(temp_buf);

            /* PWE3 channel configuration */
            CLI_F_Pwe3ChannelJitterBufferSize("0 32");
            CLI_F_Pwe3ChannelRxBufferSize("0 256");
            CLI_F_Pwe3ChannelStatmode("0 1");
            CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
            CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
            CLI_F_Pwe3ChannelUdpDummyMode("0 1");
            CLI_F_Pwe3ChannelTxUdcas("0 f");

            /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
            CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
            CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
            sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
            CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
            sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
            CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
            CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
            CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
            CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CLOCK_REC_MODE

            /* Rx timing is used in differential mode */
            /* first global_active_cr_async_mode related to different CDs */
            if (tx_clock_rec_pw[pw_index] == 1)
            {
               if (pw_index >= second_cr_pw)
                  ct_index = 1;
               else
                  ct_index = 0;
               sprintf(temp_buf, "0 1 1 %d",ct_index);
               ct_index++;
            }
            else
            {/* In differential mode all other pw (not first ones) uses CD#0 */
               if (pw_index >= second_cr_pw)
                  ct_index = 1;
               else
                  ct_index = 0;
               sprintf(temp_buf, "0 0 1 %d",ct_index);
            }

            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
            /* Rx timing is not used */
            sprintf(temp_buf, "0 0 1 %d",pw_index);
            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

            /**************** PSN --> TDM IW *****************/
            /* if clock recovery is set -> Tx timing is used */
            if (tx_clock_rec_pw[pw_index] == 1)    /* lines 0-(N-1) use CR, all other don't */
               CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
            else
               CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */

            CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
            CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

            /**************** PSN --> TDM Tx binding*****************/

            /* CR Rx and Tx direction */
            if (tx_clock_rec_pw[pw_index] == 1) /* pw 0-(N-1) use CR, all other don't */
            {
               sprintf(temp_buf, "0 0 1 1 %d",pw_index);
               CLI_F_PwCreate(temp_buf); /* CR master */
            }

            else
            {
               sprintf(temp_buf, "0 0 1 0 %d",pw_index);
               CLI_F_PwCreate(temp_buf); /* CR slave */
            }

            if (tx_clock_rec_pw[pw_index] == 1)
               sprintf(temp_buf, "0 %d 1",pw_index); /* line 1 is the master, all other slaves */
            else
               sprintf(temp_buf, "0 %d 0",pw_index);
            CLI_F_PwEnable(temp_buf);

         }

         /*print PW info:*/
         sprintf(temp_buf, "0 %d %d", modify_line1, modify_pw[0]);
         CLI_F_TransDevShowInfo(temp_buf);


      } /*if exit_factor */
   }
}
#endif /* (WTI_CESOP_CLOCK_RECOVERY_ENABLE & WTI_CESOP_RX_TIMING_ENABLE) */

#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE & WTI_CESOP_RX_TIMING_ENABLE)
/***************************************************************
 * Func name  :
 * Description:
 *             This test runs with RX and TX CR modules with 2 CD.
 *             The "Master" lines are '0' and 'second_cr_line' (lines with TX CR).
 *             After all lines were initialize and the test runs, some lines are been moved
 *             from shaper to shaper (By remove PW, disable the line, modify and recreate it
 *             and recreate the assosiate PW).
 *             initial setup:
 *                TDM2PSN: Test uses 2 CD for the first N PWs (PW=line in this case).
 *                         Each CD uses different shaper. All PWs > N use the first shaper.
 *                PSN2TDM: First N PWs are connected to N CTs respectively. PWs N+1 and forward
 *                         are connected to CT0.
 *             second_cr_line can run from 80 to 255. If second_cr_line is lower than 80 or bigger
 *             than 255, an error WUFE_ERR_CLOCK_REC_NO_FREE_RAM_ENTRY will rise.
 *
 *             (*) N = "global_active_cr_async_mode"
 ***************************************************************/
void CLI_F_106_SBI_T1_F_CR_NoCas_Two_Boards_1_CD_1_CT_84_line_with_shaper_modify(char *StrPrm)
{
   int NUM = 3; /* NUM is the size of the modify arrays */
   WP_U32 i, j, line_index, spe_index, pw_index, second_cr_pw, ct_index;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_CHAR exit_factor = '0';
   WUFE_line_sbi_reconfig new_ufe_line_config;
   WUFE_status ufe_status;
   int second_cr_line = 170;
   int modify_line1 = 3;
   int modify_line2 = second_cr_line;/*was 6*/
   int modify_line3 = 200;/*was 8*/
   /* used for running with 1 line only; change NUM to '1' and mark the 'WT_UfeLineSbiModify' functions.
   int modify_line[] = {modify_line1};
   int modify_pw[] = {modify_line[0]};*/
   int modify_line[] = {modify_line1, modify_line2, modify_line3};
   int modify_pw[] = {modify_line[0],
         modify_line[1],
         modify_line[2]};
   int new_shaper_location[] = {0, 0, 0}; /* Create with the same size as modify_line */

   WP_U8   tx_clock_rec_lines[336] = {0}; /* list of master lines */
   WP_U8   tx_clock_rec_pw[336 * WTI_PW_PER_LINE] = {0}; /* list of master pw */

   if (WTI_PW_PER_LINE != 1)
   {
      printf("ERROR - currently, this test can not work with WTI_PW_PER_LINE != 1\n");
      exit(1);
   }
   /* define the CR master lines array */
   tx_clock_rec_lines[0] = 1;
   tx_clock_rec_lines[second_cr_line] = 1;
   /* attached PW number to line number */
   second_cr_pw = second_cr_line;

   /* define the CR master PWs array */
   tx_clock_rec_pw[0] = 1;
   tx_clock_rec_pw[second_cr_pw] = 1;

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;

         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */

         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */
         /* set ufe Tx and Rx direction */
         if (tx_clock_rec_lines[line_index] == 1) /* lines 0-(N-1) use CR, all other don't */
            sprintf(temp_buf, "0 %d 1 3",line_index);
         else
            sprintf(temp_buf, "0 %d 1 2",line_index); /* lines number >N => use RX CR only */

         CLI_F_UfeTransferMode(temp_buf);

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (line_index < second_cr_line)
         {
            sprintf(temp_buf, "0 %d %d", line_index, 0);
         }
         else

         {
            sprintf(temp_buf, "0 %d %d", line_index, 1);
         }
         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, clock_trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (line_index < second_cr_line)
         {
            sprintf(temp_buf, "0 %d %d", line_index, 0);
         }
         else

         {
            sprintf(temp_buf, "0 %d %d", line_index, 1);
         }
         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, shper_id */
      }
   }
   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 1");

   CLI_F_UfeChipInitLineSetup("");

   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (tx_clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }

#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   ct_index = 0;
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_T1_LINES_PER_SPE + j;

         sprintf(temp_buf, "0 %d %d 24 24 24 0-23", line_index, pw_index);/* The line index of this PW */
         CLI_F_PwConfigureFramed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 384");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CLOCK_REC_MODE

         printf("ct_index= %d, pw_index = %d\n", ct_index, pw_index);

         /* Rx timing is used in differential mode */
         /* first global_active_cr_async_mode related to different CDs */
         if (tx_clock_rec_pw[pw_index] == 1)
         {
            sprintf(temp_buf, "0 1 1 %d",ct_index);
            ct_index++;
         }
         else
         {/* In differential mode all other pw (not first ones) uses CD#0 */
            sprintf(temp_buf, "0 0 1 %d",ct_index-1);/*due to ct_index++ at PW0*/
         }
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else

         /* Rx timing is not used */
         sprintf(temp_buf, "0 0 1 %d",pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

         /**************** PSN --> TDM IW *****************/
         /* if clock recovery is set -> Tx timing is used */
         if (tx_clock_rec_pw[pw_index] == 1)    /* lines 0-(N-1) use CR, all other don't */
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/

         /* CR Rx and Tx direction */
         if (tx_clock_rec_pw[pw_index] == 1) /* pw 0-(N-1) use CR, all other don't */
         {
            sprintf(temp_buf, "0 0 1 1 %d",pw_index);
            CLI_F_PwCreate(temp_buf); /* CR master */
         }

         else
         {
            sprintf(temp_buf, "0 0 1 0 %d",pw_index);
            CLI_F_PwCreate(temp_buf); /* CR slave */
         }

         if (tx_clock_rec_pw[pw_index] == 1)
            sprintf(temp_buf, "0 %d 1",pw_index); /* line 1 is the master, all other slaves */
         else
            sprintf(temp_buf, "0 %d 0",pw_index);
         CLI_F_PwEnable(temp_buf);

      } /* end for (configure each line) */
   }

   while (exit_factor != '9')
   {
      printf("Test running.\nType 's' to print statistics, 'c' to clear statistics, '9' to quit or any other key to modify shapers.\n");
      printf(" 1- line %d\n 2- line %d (second CR)\n 3- line %d\n",
             modify_line1, modify_line2, modify_line3);
      exit_factor = getchar();
      if (exit_factor == '9')
      {
         printf("Exit test\n");
      }
      else if (exit_factor == 's')
      {
         printf("Check statistics:\n");
         sprintf(temp_buf, "0 %d", N_ACTIVE_UFE_SBI_SPE*WTI_E1_LINES_PER_SPE);
         CLI_F_Pwe3StatisticsCheck(temp_buf);
         CLI_F_ClockRecSystemsStatisticsStatus("0");
      }
      else if (exit_factor == 'c')
      {
         printf("Clear statistics\n");
         sprintf(temp_buf, "0 %d", N_ACTIVE_UFE_SBI_SPE*WTI_E1_LINES_PER_SPE);
         CLI_F_Pwe3StatisticsClear(temp_buf);
         CLI_F_ClockRecSystemsStatisticsReset("0");
      }
      else if (exit_factor == '1')
      {
         CLI_F_TransDevShowInfo("0 3 3");
      }
      else if (exit_factor == '2')
      {
         CLI_F_TransDevShowInfo("0 170 170");
      }
      else if (exit_factor == '3')
      {
         CLI_F_TransDevShowInfo("0 200 200");
      }
      else
      {

         /* This section reconfigure the shaper for modify_line1 */
         /* remove PW -> disable line -> modify line configuration -> enable line -> recreate and reenable PW */
         /* -------------------------------------------------------------------------------------------- */
         /*sprintf(temp_buf, "0 %d %d", modify_line1, modify_line1);
           CLI_F_TransDevShowInfo(temp_buf);*/

         /* PW remove: */
         for (i=0; i<NUM; i++)
         {
            printf("remove PW %d\n", modify_pw[i]);
            sprintf(temp_buf, "0 %d", modify_pw[i]);
            CLI_F_PwRemove(temp_buf);
         }


         /* line disable: */
         for (i=0; i<NUM; i++)
         {
            printf("Disable line: %d\n", modify_line[i]);
            ufe_status = WUFE_LineDisable(
                                          (&the_system->ufe)->line_handle[modify_line[i]], WUFE_FULL_DUPLEX);
            WT_UfeTerminateOnError(ufe_status, "WUFE_LineDisable", modify_line[i], __LINE__);
         }


         /* line modify: */
         printf("Modify lines\n");
         memset(&new_ufe_line_config, 0xff, sizeof(WUFE_line_sbi_reconfig));
         /* move line to shaper 1 as slave */
         new_ufe_line_config.clock_rec_mode = WUFE_LINE_CLOCK_REC_ENABLE_RX;
         new_ufe_line_config.rx_clk_rec_if = 1;
         WT_UfeLineSbiModify(&(the_system->ufe), modify_line[0], &new_ufe_line_config);
         new_shaper_location[0] = new_ufe_line_config.rx_clk_rec_if;
         /* move line to shaper 0 as slave, disable TX direction */
         new_ufe_line_config.clock_rec_mode = WUFE_LINE_CLOCK_REC_ENABLE_DUPLEX;
         new_ufe_line_config.rx_clk_rec_if = 0;
         WT_UfeLineSbiModify(&(the_system->ufe), modify_line[1], &new_ufe_line_config);
         new_shaper_location[1] = new_ufe_line_config.rx_clk_rec_if;
         /* move line to shaper 0 as slave */
         new_ufe_line_config.clock_rec_mode = WUFE_LINE_CLOCK_REC_ENABLE_RX;
         new_ufe_line_config.rx_clk_rec_if = 0;
         WT_UfeLineSbiModify(&(the_system->ufe), modify_line[2], &new_ufe_line_config);
         new_shaper_location[2] = new_ufe_line_config.rx_clk_rec_if;

         printf("line modified. press any key to continue...\n");
         getchar();

         /* line enable: */
         for (i=0; i<NUM; i++)
         {
            printf("Enable line: %d\n", modify_line[i]);
            ufe_status = WUFE_LineEnable((&the_system->ufe)->line_handle[modify_line[i]], WUFE_FULL_DUPLEX);
            WT_UfeTerminateOnError(ufe_status, "SBI WUFE_LineEnable", modify_line[i], __LINE__);
         }

         /* recreate PW: */

         for (i=0; i<NUM; i++)
         {
            line_index = modify_line[i];
            pw_index = modify_pw[i];

            sprintf(temp_buf, "0 %d %d 24 24 24 0-23", line_index, pw_index);/* The line index of this PW */
            CLI_F_PwConfigureFramed(temp_buf);

            /* PWE3 channel configuration */
            CLI_F_Pwe3ChannelJitterBufferSize("0 32");
            CLI_F_Pwe3ChannelRxBufferSize("0 192");
            CLI_F_Pwe3ChannelStatmode("0 1");
            CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
            CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
            CLI_F_Pwe3ChannelUdpDummyMode("0 1");
            CLI_F_Pwe3ChannelTxUdcas("0 f");

            /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
            CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
            CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
            sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
            CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
            sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
            CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
            CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 d8 0");
            CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
            CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CLOCK_REC_MODE

            /* Rx timing is used in differential mode */
            /* first global_active_cr_async_mode related to different CDs */
            if (tx_clock_rec_pw[pw_index] == 1)
            {
               if (pw_index >= second_cr_pw)
                  ct_index = 1;
               else
                  ct_index = 0;
               sprintf(temp_buf, "0 1 1 %d",ct_index);
               ct_index++;
            }
            else
            {/* In differential mode all other pw (not first ones) uses CD#0 */
               if (pw_index >= second_cr_pw)
                  ct_index = 1;
               else
                  ct_index = 0;
               sprintf(temp_buf, "0 0 1 %d",ct_index);
            }

            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else

            /* Rx timing is not used */
            sprintf(temp_buf, "0 0 1 %d",pw_index);
            CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

            /**************** PSN --> TDM IW *****************/
            /* if clock recovery is set -> Tx timing is used */
            if (tx_clock_rec_pw[pw_index] == 1)    /* lines 0-(N-1) use CR, all other don't */
               CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
            else
               CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */

            CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
            CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

            /**************** PSN --> TDM Tx binding*****************/

            /* CR Rx and Tx direction */
            if (tx_clock_rec_pw[pw_index] == 1) /* pw 0-(N-1) use CR, all other don't */
            {
               sprintf(temp_buf, "0 0 1 1 %d",pw_index);
               CLI_F_PwCreate(temp_buf); /* CR master */
            }

            else
            {
               sprintf(temp_buf, "0 0 1 0 %d",pw_index);
               CLI_F_PwCreate(temp_buf); /* CR slave */
            }

            if (tx_clock_rec_pw[pw_index] == 1)
               sprintf(temp_buf, "0 %d 1",pw_index); /* line 1 is the master, all other slaves */
            else
               sprintf(temp_buf, "0 %d 0",pw_index);
            CLI_F_PwEnable(temp_buf);

         }

      } /*if exit_factor */
   }
}
#endif /* (WTI_CESOP_CLOCK_RECOVERY_ENABLE & WTI_CESOP_RX_TIMING_ENABLE) */

#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE & WTI_CESOP_RX_TIMING_ENABLE)
/***************************************************************
 * Func name  :
 * Description:
 *             This test runs with RX and TX CR modules with 2 CD.
 *             The "Master" lines are '0' and 'second_cr_line' (lines with TX CR).
 *             After all lines were initialize and the test runs, all PW and lines are removed
 *             and deleted. Then, the system is recreated all lines and PWs but with different
 *             'second_cr_line'
 *             TDM2PSN: Test uses 2 CD for the first N PWs (PW=line in this case).
 *                      Each CD uses different shaper. All PWs > N use the first shaper.
 *             PSN2TDM: First N PWs are connected to N CTs respectively. PWs N+1 and forward
 *                      are connected to CT0.
 *             (*) N = "global_active_cr_async_mode"
 ***************************************************************/
void CLI_F_108_SBI_E1_U_CR_NoCas_Two_Boards_1_CD_1_CT_63_line_addremove_PW_with_shaper_modify(char *StrPrm)
{
   WP_U32 i, j, line_index, spe_index, pw_index, second_cr_pw, ct_index;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_CHAR exit_factor = '0';
   int temp_cr_line, second_cr_line = 6;
   int second_cr_line_modify = 47;
   int MAX_ACTIVE_PW = N_ACTIVE_UFE_SBI_SPE * WTI_E1_LINES_PER_SPE;

   WP_U8   tx_clock_rec_lines[336] = {0}; /* list of master lines */
   WP_U8   tx_clock_rec_pw[336 * WTI_PW_PER_LINE] = {0}; /* list of master pw */

   if (WTI_PW_PER_LINE != 1)
   {
      printf("ERROR - currently, this test can not work with WTI_PW_PER_LINE != 1\n");
      exit(1);
   }
   /* define the CR master lines array */
   tx_clock_rec_lines[0] = 1;
   tx_clock_rec_lines[second_cr_line] = 1;
   /* attached PW number to line number */
   second_cr_pw = CLI_F_AttachePwToLineNumber(second_cr_line);
   /* define the CR master PWs array */
   tx_clock_rec_pw[0] = 1;
   tx_clock_rec_pw[second_cr_pw] = 1;

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;

         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */

         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */
         /* set ufe Tx and Rx direction */
         if (tx_clock_rec_lines[line_index] == 1) /* lines 0-(N-1) use CR, all other don't */
            sprintf(temp_buf, "0 %d 4 3",line_index);
         else
            sprintf(temp_buf, "0 %d 4 2",line_index); /* lines number >N => don't use CR  */

         CLI_F_UfeTransferMode(temp_buf);

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (line_index < second_cr_line)
         {
            sprintf(temp_buf, "0 %d %d", line_index, 0);
         }
         else

         {
            sprintf(temp_buf, "0 %d %d", line_index, 1);
         }
         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, clock_trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (line_index < second_cr_line)
         {
            sprintf(temp_buf, "0 %d %d", line_index, 0);
         }
         else

         {
            sprintf(temp_buf, "0 %d %d", line_index, 1);
         }

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
      }
   }
   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 2");

   CLI_F_UfeChipInitLineSetup("");

   WUFE_SbiClockTranslatorDisplay(the_system->ufe.ufe_id);

   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (tx_clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }

#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   ct_index = 0;
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_E1_LINES_PER_SPE + j;

         sprintf(temp_buf, "0 %d %d 32 32", line_index, pw_index);/* The line index of this PW */
         CLI_F_PwConfigureUnframed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 256");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CLOCK_REC_MODE
         /* Rx timing is used in differential mode */
         /* first global_active_cr_async_mode related to different CDs */
         if (tx_clock_rec_pw[pw_index] == 1)
         {
            sprintf(temp_buf, "0 1 1 %d",ct_index);
            ct_index++;
         }
         else
         {/* In differential mode all other pw (not first ones) uses CD#0 */
            sprintf(temp_buf, "0 0 1 %d",ct_index-1);
         }
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
         /* Rx timing is not used */
         sprintf(temp_buf, "0 0 1 %d",pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

         /**************** PSN --> TDM IW *****************/
         /* if clock recovery is set -> Tx timing is used */
         if (tx_clock_rec_pw[pw_index] == 1)    /* lines 0-(N-1) use CR, all other don't */
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/

         /* CR Rx and Tx direction */
         if (tx_clock_rec_pw[pw_index] == 1) /* pw 0-(N-1) use CR, all other don't */
            sprintf(temp_buf,"0 0 1 1 %d", pw_index); /* CR master */
         else
            sprintf(temp_buf,"0 0 1 0 %d", pw_index); /* CR slave */
         CLI_F_PwCreate(temp_buf);

         if (tx_clock_rec_pw[pw_index] == 1)
            sprintf(temp_buf, "0 %d 1",pw_index); /* line 1 is the master, all other slaves */
         else
            sprintf(temp_buf, "0 %d 0",pw_index);
         CLI_F_PwEnable(temp_buf);

      } /* end for (configure each line) */
   }

   /* run test in loop mode */
   while (exit_factor != '9')
   {
      printf("Test running.\nType 's' to see statistics, 'c' to clean statistics, '9' to quit or any other key to modify shapers.\n");
      printf(" 1- line 0\n 2- second CR line (%d)\n 3- modify CR line (%d)\n",
             second_cr_line, second_cr_line_modify);
      exit_factor = getchar();
      if (exit_factor == '9')
      {
         printf("Exit test\n");
      }
      else if (exit_factor == 's')
      {
         printf("Check statistics:\n");
         sprintf(temp_buf, "0 %d", MAX_ACTIVE_PW);
         CLI_F_Pwe3StatisticsCheck(temp_buf);
         CLI_F_ClockRecSystemsStatisticsStatus("0");
      }
      else if (exit_factor == 'c')
      {
         printf("Clear statistics\n");
         sprintf(temp_buf, "0 %d", MAX_ACTIVE_PW);
         CLI_F_Pwe3StatisticsClear(temp_buf);
         CLI_F_ClockRecSystemsStatisticsReset("0");
      }
      else if (exit_factor == '1')
      {
         CLI_F_TransDevShowInfo("0 0 0");
      }
      else if (exit_factor == '2')
      {
         sprintf(temp_buf, "0 %d %d", second_cr_line, second_cr_pw);
         CLI_F_TransDevShowInfo(temp_buf);
      }
      else if (exit_factor == '3')
      {
         sprintf(temp_buf, "0 %d %d",
                 second_cr_line_modify, CLI_F_AttachePwToLineNumber(second_cr_line_modify));
         CLI_F_TransDevShowInfo(temp_buf);
      }
      else
      {

         /* remove PWs */
         printf("..:: Removing PW.\n");
         WP_Delay(100000); /*time in usec*/

         for (i=N_ACTIVE_UFE_SBI_SPE; i>0; i--)
         {
            for (j=WTI_E1_LINES_PER_SPE; j>0; j--)
            {
               pw_index = (i-1)*WTI_E1_LINES_PER_SPE + (j-1);
               sprintf(temp_buf, "0 %d", pw_index);
               CLI_F_PwRemove(temp_buf);
            }
         }

         /* remove lines */
         for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
         {
            for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
            {
               line_index = i*28 + j;

               /* this do line disable and line delete */
               WT_UfeLineDelete(&the_system->ufe, line_index);
            }
         }
         printf("PWs and lines removed. Type any key to Recreate...\n");
         exit_factor = getchar();
         if (exit_factor == '9')
            break;

         /* change CR place, from PW=second_cr_line to PW="new" second_cr_line */

         /* define the CR master lines array */
         tx_clock_rec_lines[second_cr_line] = 0; /*old CR*/
         tx_clock_rec_pw[second_cr_pw] = 0; /*old CR*/
         /* initialize the clock recovery parameters for new cr line */
         memcpy(&the_system->clock_rec[second_cr_line_modify],
                &the_system->clock_rec[second_cr_line],
                sizeof(WP_clock_rec_params));
         temp_cr_line = second_cr_line;/* in order to swap over and over again */
         second_cr_line = second_cr_line_modify;
         second_cr_line_modify = temp_cr_line;
         tx_clock_rec_lines[second_cr_line] = 1; /*new CR line*/

         /* attached PW number to line number */
         second_cr_pw = CLI_F_AttachePwToLineNumber(second_cr_line);

         /* define the CR master PWs array */
         tx_clock_rec_pw[0] = 1;
         tx_clock_rec_pw[second_cr_pw] = 1; /*new CR PW*/

         /* UFE line configuration */
         for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
         {
            for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
            {
               line_index = i*28 + j;

               /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
               /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */

               /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */
               /* set ufe Tx and Rx direction */
               if (tx_clock_rec_lines[line_index] == 1) /* lines 0-(N-1) use CR, all other don't */
                  sprintf(temp_buf, "0 %d 4 3",line_index);
               else
                  sprintf(temp_buf, "0 %d 4 2",line_index); /* lines number >N => don't use CR  */

               CLI_F_UfeTransferMode(temp_buf);

               /* match between clock tarnslators and lines for the CR lines   */
               /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
               if (line_index < second_cr_line)
               {
                  sprintf(temp_buf, "0 %d %d", line_index, 0);
               }
               else
                  /* conect all others to the first line */
               {
                  sprintf(temp_buf, "0 %d %d", line_index, 1);
               }
               CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, clock_trans_id */

               /* match between clock shaper and lines for the CR lines   */
               /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
               if (line_index < second_cr_line)
                  sprintf(temp_buf, "0 %d %d", line_index, 0);
               else
                  sprintf(temp_buf, "0 %d %d", line_index, 1);

               CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
            }
         }
         /* create line second time */
         CLI_F_UfeChipInitLineSetup("");
         /* recreate PW  */
         ct_index = 0;
         for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
         {
            for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
            {
               line_index = i*28 + j;
               pw_index = i*WTI_E1_LINES_PER_SPE + j;

               sprintf(temp_buf, "0 %d %d 32 32", line_index, pw_index);/* The line index of this PW */
               CLI_F_PwConfigureUnframed(temp_buf);

               /* PWE3 channel configuration */
               CLI_F_Pwe3ChannelJitterBufferSize("0 32");
               CLI_F_Pwe3ChannelRxBufferSize("0 256");
               CLI_F_Pwe3ChannelStatmode("0 1");
               CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
               CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
               CLI_F_Pwe3ChannelUdpDummyMode("0 1");
               CLI_F_Pwe3ChannelTxUdcas("0 f");

               /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
               CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
               CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
               sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
               CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
               sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
               CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
               CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
               CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
               CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CLOCK_REC_MODE
               /* Rx timing is used in differential mode */
               /* first global_active_cr_async_mode related to different CDs */
               if (tx_clock_rec_pw[pw_index] == 1)
               {
                  sprintf(temp_buf, "0 1 1 %d",ct_index);
                  ct_index++;
               }
               else
                  sprintf(temp_buf, "0 0 1 %d",ct_index-1); /* 0->0 (1-(N-1))-> 0 too, so ct_index-1 */
               CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
               /* Rx timing is not used */
               sprintf(temp_buf, "0 0 1 %d",pw_index);
               CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

               /**************** PSN --> TDM IW *****************/
               /* if clock recovery is set -> Tx timing is used */
               if (tx_clock_rec_pw[pw_index] == 1)    /* lines 0-(N-1) use CR, all other don't */
                  CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
               else
                  CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
               CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
               CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

               /**************** PSN --> TDM Tx binding*****************/
               /* CR Rx and Tx direction */
               if (tx_clock_rec_pw[pw_index] == 1)   /* pw 0-(N-1) use CR, all other don't */
                  sprintf(temp_buf,"0 0 1 1 %d", pw_index); /* CR master */
               else
                  sprintf(temp_buf,"0 0 1 0 %d", pw_index); /* CR slave */
               CLI_F_PwCreate(temp_buf);

               if (tx_clock_rec_pw[pw_index] == 1)
                  sprintf(temp_buf, "0 %d 1",pw_index); /* line 1 is the master, all other slaves */
               else
                  sprintf(temp_buf, "0 %d 0",pw_index);
               CLI_F_PwEnable(temp_buf);


            } /* end for (configure each line) */
         }
      } /*if exit_factor */
   } /* while */
}
#endif /* (WTI_CESOP_CLOCK_RECOVERY_ENABLE & WTI_CESOP_RX_TIMING_ENABLE) */

#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE & WTI_CESOP_RX_TIMING_ENABLE)
/***************************************************************
 * Func name  :
 * Description:
 *             This test runs with RX and TX CR modules with 2 CD.
 *             The "Master" lines are '0' and 'second_cr_line' (lines with TX CR).
 *             After all lines were initialize and the test runs, all PW and lines are removed
 *             and deleted. Then, the system is recreated all lines and PWs but with different
 *             'second_cr_line'
 *             TDM2PSN: Test uses 2 CD for the first N PWs (PW=line in this case).
 *                      Each CD uses different shaper. All PWs > N use the first shaper.
 *             PSN2TDM: First N PWs are connected to N CTs respectively. PWs N+1 and forward
 *                      are connected to CT0.
 *             second_cr_line and second_cr_line_modify must be between 80 to 255 in order
 *             to enter all lines to RX Port RAM.
 *
 *             (*) N = "global_active_cr_async_mode"
 ***************************************************************/
void CLI_F_108_SBI_T1_U_CR_NoCas_Two_Boards_1_CD_1_CT_63_line_addremove_PW_with_shaper_modify(char *StrPrm)
{
   WP_U32 i, j, line_index, spe_index, pw_index, second_cr_pw, ct_index;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_CHAR exit_factor = '0';
   int temp_cr_line, second_cr_line = 110;
   int second_cr_line_modify = 169;
   int MAX_ACTIVE_PW = N_ACTIVE_UFE_SBI_SPE * WTI_T1_LINES_PER_SPE;

   WP_U8   tx_clock_rec_lines[336] = {0}; /* list of master lines */
   WP_U8   tx_clock_rec_pw[336 * WTI_PW_PER_LINE] = {0}; /* list of master pw */

   if (WTI_PW_PER_LINE != 1)
   {
      printf("ERROR - currently, this test can not work with WTI_PW_PER_LINE != 1\n");
      exit(1);
   }
   /* define the CR master lines array */
   tx_clock_rec_lines[0] = 1;
   tx_clock_rec_lines[second_cr_line] = 1;
   /* attached PW number to line number */
   second_cr_pw = second_cr_line;
   /* define the CR master PWs array */
   tx_clock_rec_pw[0] = 1;
   tx_clock_rec_pw[second_cr_pw] = 1;

   printf("second cr: line = %d, pw = %d\n", second_cr_line, second_cr_pw);

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;

         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */

         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */
         /* set ufe Tx and Rx direction */
         if (tx_clock_rec_lines[line_index] == 1) /* lines 0-(N-1) use CR, all other don't */
            sprintf(temp_buf, "0 %d 2 3",line_index);
         else
            sprintf(temp_buf, "0 %d 2 2",line_index); /* lines number >N => don't use CR  */

         CLI_F_UfeTransferMode(temp_buf);

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (line_index < second_cr_line)
         {
            sprintf(temp_buf, "0 %d %d", line_index, 0);
         }
         else
         {
            sprintf(temp_buf, "0 %d %d", line_index, 1);
         }
         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, clock_trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (line_index < second_cr_line)
         {
            sprintf(temp_buf, "0 %d %d", line_index, 0);
         }
         else

         {
            sprintf(temp_buf, "0 %d %d", line_index, 1);
         }

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
      }
   }
   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 0");

   CLI_F_UfeChipInitLineSetup("");

   WUFE_SbiClockTranslatorDisplay(the_system->ufe.ufe_id);

   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (tx_clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }

#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   ct_index = 0;
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_T1_LINES_PER_SPE + j;

         sprintf(temp_buf, "0 %d %d 48 48", line_index, pw_index);/* The line index of this PW */
         CLI_F_PwConfigureUnframed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 384");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 198 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CLOCK_REC_MODE
         /* Rx timing is used in differential mode */
         /* first global_active_cr_async_mode related to different CDs */
         if (tx_clock_rec_pw[pw_index] == 1)
         {
            sprintf(temp_buf, "0 1 1 %d",ct_index);
            ct_index++;
         }
         else
         {/* In differential mode all other pw (not first ones) uses CD#0 */
            sprintf(temp_buf, "0 0 1 %d",ct_index-1);
         }
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
         /* Rx timing is not used */
         sprintf(temp_buf, "0 0 1 %d",pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

         /**************** PSN --> TDM IW *****************/
         /* if clock recovery is set -> Tx timing is used */
         if (tx_clock_rec_pw[pw_index] == 1)    /* lines 0-(N-1) use CR, all other don't */
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/

         /* CR Rx and Tx direction */
         if (tx_clock_rec_pw[pw_index] == 1) /* pw 0-(N-1) use CR, all other don't */
            sprintf(temp_buf,"0 0 1 1 %d", pw_index); /* CR master */
         else
            sprintf(temp_buf,"0 0 1 0 %d", pw_index); /* CR slave */
         CLI_F_PwCreate(temp_buf);

         if (tx_clock_rec_pw[pw_index] == 1)
            sprintf(temp_buf, "0 %d 1",pw_index); /* line 1 is the master, all other slaves */
         else
            sprintf(temp_buf, "0 %d 0",pw_index);
         CLI_F_PwEnable(temp_buf);

      } /* end for (configure each line) */
   }

   /* run test in loop mode */
   while (exit_factor != '9')
   {
      /* print CR parameters */
      printf("Test running.\nType 's' to print statistics, 'c' to clear statistics, '9' to quit or any other key to modify shapers.\n");
      printf(" 1- line 0\n 2- second CR line (%d)\n 3- modify CR line (%d)\n",
             second_cr_line, second_cr_line_modify);
      exit_factor = getchar();
      if (exit_factor == '9')
      {
         printf("Exit test\n");
      }
      else if (exit_factor == 's')
      {
         printf("Check statistics:\n");
         sprintf(temp_buf, "0 %d", MAX_ACTIVE_PW);
         CLI_F_Pwe3StatisticsCheck(temp_buf);
         CLI_F_ClockRecSystemsStatisticsStatus("0");
      }
      else if (exit_factor == 'c')
      {
         printf("Clear statistics\n");
         sprintf(temp_buf, "0 %d", MAX_ACTIVE_PW);
         CLI_F_Pwe3StatisticsClear(temp_buf);
         CLI_F_ClockRecSystemsStatisticsReset("0");
      }
      else if (exit_factor == '1')
      {
         CLI_F_TransDevShowInfo("0 0 0");
      }
      else if (exit_factor == '2')
      {
         sprintf(temp_buf, "0 %d %d", second_cr_line, second_cr_line);
         CLI_F_TransDevShowInfo(temp_buf);
      }
      else if (exit_factor == '3')
      {
         sprintf(temp_buf, "0 %d %d", second_cr_line_modify, second_cr_line_modify);
         CLI_F_TransDevShowInfo(temp_buf);
      }
      else
      {
         /* remove PWs */
         printf("..:: Removing PW.\n");
         WP_Delay(100000); /*time in usec*/

         for (i=N_ACTIVE_UFE_SBI_SPE; i>0; i--)
         {
            for (j=WTI_T1_LINES_PER_SPE; j>0; j--)
            {
               pw_index = (i-1)*WTI_T1_LINES_PER_SPE + (j-1);
               sprintf(temp_buf, "0 %d", pw_index);
               CLI_F_PwRemove(temp_buf);
            }
         }

         /* remove lines */
         for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
         {
            for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
            {
               line_index = i*28 + j;

               /* this do line disable and line delete */
               WT_UfeLineDelete(&the_system->ufe, line_index);
            }
         }

         printf("PWs and lines removed. Type any key to Recreate...\n");
         exit_factor = getchar();
         if (exit_factor == '9')
            break;
         /* change CR place, from PW=second_cr_line to PW="new" second_cr_line */

         /* define the CR master lines array */
         tx_clock_rec_lines[second_cr_line] = 0; /*old CR*/
         tx_clock_rec_pw[second_cr_pw] = 0; /*old CR*/
         /* initialize the clock recovery parameters for new cr line */
         memcpy(&the_system->clock_rec[second_cr_line_modify],
                &the_system->clock_rec[second_cr_line],
                sizeof(WP_clock_rec_params));
         temp_cr_line = second_cr_line;
         second_cr_line = second_cr_line_modify;
         second_cr_line_modify = temp_cr_line;
         tx_clock_rec_lines[second_cr_line] = 1; /*new CR line*/

         /* attached PW number to line number */
         second_cr_pw = second_cr_line;

         /* define the CR master PWs array */
         tx_clock_rec_pw[0] = 1;
         tx_clock_rec_pw[second_cr_pw] = 1; /*new CR PW*/

         /* UFE line configuration */
         for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
         {
            for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
            {
               line_index = i*28 + j;

               /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
               /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */

               /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */
               /* set ufe Tx and Rx direction */
               if (tx_clock_rec_lines[line_index] == 1) /* lines 0-(N-1) use CR, all other don't */
                  sprintf(temp_buf, "0 %d 2 3",line_index);
               else
                  sprintf(temp_buf, "0 %d 2 2",line_index); /* lines number >N => don't use CR  */

               CLI_F_UfeTransferMode(temp_buf);

               /* match between clock tarnslators and lines for the CR lines   */
               /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
               if (line_index < second_cr_line)
               {
                  sprintf(temp_buf, "0 %d %d", line_index, 0);
               }
               else
                  /* conect all others to the first line */
               {
                  sprintf(temp_buf, "0 %d %d", line_index, 1);
               }
               CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, clock_trans_id */

               /* match between clock shaper and lines for the CR lines   */
               /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
               if (line_index < second_cr_line)
                  sprintf(temp_buf, "0 %d %d", line_index, 0);
               else
                  sprintf(temp_buf, "0 %d %d", line_index, 1);

               CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
            }
         }
         /* create line second time */
         CLI_F_UfeChipInitLineSetup("");
         /* recreate PW  */
         ct_index = 0;
         for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
         {
            for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
            {
               line_index = i*28 + j;
               pw_index = i*WTI_T1_LINES_PER_SPE + j;

               sprintf(temp_buf, "0 %d %d 48 48", line_index, pw_index);/* The line index of this PW */
               CLI_F_PwConfigureUnframed(temp_buf);

               /* PWE3 channel configuration */
               CLI_F_Pwe3ChannelJitterBufferSize("0 32");
               CLI_F_Pwe3ChannelRxBufferSize("0 384");
               CLI_F_Pwe3ChannelStatmode("0 1");
               CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
               CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
               CLI_F_Pwe3ChannelUdpDummyMode("0 1");
               CLI_F_Pwe3ChannelTxUdcas("0 f");

               /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
               CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
               CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
               sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
               CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
               sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
               CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
               CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 198 0");
               CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
               CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CLOCK_REC_MODE
               /* Rx timing is used in differential mode */
               /* first global_active_cr_async_mode related to different CDs */
               if (tx_clock_rec_pw[pw_index] == 1)
               {
                  sprintf(temp_buf, "0 1 1 %d",ct_index);
                  ct_index++;
               }
               else
                  sprintf(temp_buf, "0 0 1 %d",ct_index-1); /* 0->0 (1-(N-1))-> 0 too, so ct_index-1 */
               CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
               /* Rx timing is not used */
               sprintf(temp_buf, "0 0 1 %d",pw_index);
               CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

               /**************** PSN --> TDM IW *****************/
               /* if clock recovery is set -> Tx timing is used */
               if (tx_clock_rec_pw[pw_index] == 1)    /* lines 0-(N-1) use CR, all other don't */
                  CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
               else
                  CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
               CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
               CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

               /**************** PSN --> TDM Tx binding*****************/
               /* CR Rx and Tx direction */
               if (tx_clock_rec_pw[pw_index] == 1)   /* pw 0-(N-1) use CR, all other don't */
                  sprintf(temp_buf,"0 0 1 1 %d", pw_index); /* CR master */
               else
                  sprintf(temp_buf,"0 0 1 0 %d", pw_index); /* CR slave */
               CLI_F_PwCreate(temp_buf);

               if (tx_clock_rec_pw[pw_index] == 1)
                  sprintf(temp_buf, "0 %d 1",pw_index); /* line 1 is the master, all other slaves */
               else
                  sprintf(temp_buf, "0 %d 0",pw_index);
               CLI_F_PwEnable(temp_buf);


            } /* end for (configure each line) */
         }
      } /*if exit_factor */
   } /* while */
}
#endif /* (WTI_CESOP_CLOCK_RECOVERY_ENABLE & WTI_CESOP_RX_TIMING_ENABLE) */

#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE & WTI_CESOP_RX_TIMING_ENABLE)
/***************************************************************
 * Func name  :
 * Description:
 *             This test runs with RX and TX CR modules with 2 CD.
 *             The "Master" lines are '0' and 'second_cr_line' (lines with TX CR).
 *             After all lines were initialize and the test runs, all PW and lines are removed
 *             and deleted. Then, the system is recreated all lines and PWs but with different
 *             'second_cr_line'
 *             TDM2PSN: Test uses 2 CD for the first N PWs (PW=line in this case).
 *                      Each CD uses different shaper. All PWs > N use the first shaper.
 *             PSN2TDM: First N PWs are connected to N CTs respectively. PWs N+1 and forward
 *                      are connected to CT0.
 *             (*) N = "global_active_cr_async_mode"
 ***************************************************************/
void CLI_F_108_SBI_E1_F_CR_NoCas_Two_Boards_1_CD_1_CT_63_line_addremove_PW_with_shaper_modify(char *StrPrm)
{
   WP_U32 i, j, line_index, spe_index, pw_index, second_cr_pw, ct_index;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_CHAR exit_factor = '0';
   int temp_cr_line, second_cr_line = 6;
   int second_cr_line_modify = 47;/*67;*/
   int MAX_ACTIVE_PW = N_ACTIVE_UFE_SBI_SPE * WTI_E1_LINES_PER_SPE;

   WP_U8   tx_clock_rec_lines[336] = {0}; /* list of master lines */
   WP_U8   tx_clock_rec_pw[336 * WTI_PW_PER_LINE] = {0}; /* list of master pw */

   if (WTI_PW_PER_LINE != 1)
   {
      printf("ERROR - currently, this test can not work with WTI_PW_PER_LINE != 1\n");
      exit(1);
   }
   /* define the CR master lines array */
   tx_clock_rec_lines[0] = 1;
   tx_clock_rec_lines[second_cr_line] = 1;
   /* attached PW number to line number */
   second_cr_pw = CLI_F_AttachePwToLineNumber(second_cr_line);
   /* define the CR master PWs array */
   tx_clock_rec_pw[0] = 1;
   tx_clock_rec_pw[second_cr_pw] = 1;

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;

         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */

         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */
         /* set ufe Tx and Rx direction */
         if (tx_clock_rec_lines[line_index] == 1) /* lines 0-(N-1) use CR, all other don't */
            sprintf(temp_buf, "0 %d 3 3",line_index);
         else
            sprintf(temp_buf, "0 %d 3 2",line_index); /* lines number >N => don't use CR  */

         CLI_F_UfeTransferMode(temp_buf);

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (line_index < second_cr_line)
         {
            sprintf(temp_buf, "0 %d %d", line_index, 0);
         }
         else

         {
            sprintf(temp_buf, "0 %d %d", line_index, 1);
         }
         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, clock_trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (line_index < second_cr_line)
         {
            sprintf(temp_buf, "0 %d %d", line_index, 0);
         }
         else

         {
            sprintf(temp_buf, "0 %d %d", line_index, 1);
         }

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
      }
   }
   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 3");

   CLI_F_UfeChipInitLineSetup("");

   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (tx_clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }

#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   ct_index = 0;
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_E1_LINES_PER_SPE + j;

         sprintf(temp_buf, "0 %d %d 32 32 32 0-31", line_index, pw_index);/* The line index of this PW */
         CLI_F_PwConfigureFramed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 256");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CLOCK_REC_MODE
         /* Rx timing is used in differential mode */
         /* first global_active_cr_async_mode related to different CDs */
         if (tx_clock_rec_pw[pw_index] == 1)
         {
            sprintf(temp_buf, "0 1 1 %d",ct_index);
            ct_index++;
         }
         else
         {/* In differential mode all other pw (not first ones) uses CD#0 */
            sprintf(temp_buf, "0 0 1 %d",ct_index-1);
         }
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
         /* Rx timing is not used */
         sprintf(temp_buf, "0 0 1 %d",pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

         /**************** PSN --> TDM IW *****************/
         /* if clock recovery is set -> Tx timing is used */
         if (tx_clock_rec_pw[pw_index] == 1)    /* lines 0-(N-1) use CR, all other don't */
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/

         /* CR Rx and Tx direction */
         if (tx_clock_rec_pw[pw_index] == 1) /* pw 0-(N-1) use CR, all other don't */
            sprintf(temp_buf,"0 0 1 1 %d", pw_index); /* CR master */
         else
            sprintf(temp_buf,"0 0 1 0 %d", pw_index); /* CR slave */
         CLI_F_PwCreate(temp_buf);

         if (tx_clock_rec_pw[pw_index] == 1)
            sprintf(temp_buf, "0 %d 1",pw_index); /* line 1 is the master, all other slaves */
         else
            sprintf(temp_buf, "0 %d 0",pw_index);
         CLI_F_PwEnable(temp_buf);

      } /* end for (configure each line) */
   }

   /* run test in loop mode */
   while (exit_factor != '9')
   {
      /* print CR parameters */
      printf("Test running.\nType 's' to see statistics, 'c' to clean statistics, '9' to quit or any other key to modify shapers.\n");
      printf(" 1- line 0\n 2- second CR line (%d)\n 3- modify CR line (%d)\n",
             second_cr_line, second_cr_line_modify);
      exit_factor = getchar();
      if (exit_factor == '9')
      {
         printf("Exit test\n");
      }
      else if (exit_factor == 's')
      {
         printf("Check statistics:\n");
         sprintf(temp_buf, "0 %d", MAX_ACTIVE_PW);
         CLI_F_Pwe3StatisticsCheck(temp_buf);
         CLI_F_ClockRecSystemsStatisticsStatus("0");
      }
      else if (exit_factor == 'c')
      {
         printf("Clear statistics\n");
         sprintf(temp_buf, "0 %d", MAX_ACTIVE_PW);
         CLI_F_Pwe3StatisticsClear(temp_buf);
         CLI_F_ClockRecSystemsStatisticsReset("0");
      }
      else if (exit_factor == '1')
      {
         CLI_F_TransDevShowInfo("0 0 0");
      }
      else if (exit_factor == '2')
      {
         sprintf(temp_buf, "0 %d %d", second_cr_line, second_cr_pw);
         CLI_F_TransDevShowInfo(temp_buf);
      }
      else if (exit_factor == '3')
      {
         sprintf(temp_buf, "0 %d %d",
                 second_cr_line_modify, CLI_F_AttachePwToLineNumber(second_cr_line_modify));
         CLI_F_TransDevShowInfo(temp_buf);
      }
      else
      {

         /* remove PWs */
         printf("..:: Removing PW.\n");
         WP_Delay(100000); /*time in usec*/

         for (i=N_ACTIVE_UFE_SBI_SPE; i>0; i--)
         {
            for (j=WTI_E1_LINES_PER_SPE; j>0; j--)
            {
               pw_index = (i-1)*WTI_E1_LINES_PER_SPE + (j-1);
               sprintf(temp_buf, "0 %d", pw_index);
               CLI_F_PwRemove(temp_buf);
            }
         }

         /* remove lines */
         for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
         {
            for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
            {
               line_index = i*28 + j;

               /* this do line disable and line delete */
               WT_UfeLineDelete(&the_system->ufe, line_index);
            }
         }

         printf("PWs and lines removed. Type any key to Recreate...\n");
         exit_factor = getchar();
         if (exit_factor == '9')
            break;
         /* change CR place, from PW=second_cr_line to PW="new" second_cr_line */

         /* define the CR master lines array */
         tx_clock_rec_lines[second_cr_line] = 0; /*old CR*/
         tx_clock_rec_pw[second_cr_pw] = 0; /*old CR*/
         /* initialize the clock recovery parameters for new cr line */
         memcpy(&the_system->clock_rec[second_cr_line_modify],
                &the_system->clock_rec[second_cr_line],
                sizeof(WP_clock_rec_params));
         temp_cr_line = second_cr_line;
         second_cr_line = second_cr_line_modify;
         second_cr_line_modify = temp_cr_line;
         tx_clock_rec_lines[second_cr_line] = 1; /*new CR line*/

         /* attached PW number to line number */
         second_cr_pw = CLI_F_AttachePwToLineNumber(second_cr_line);

         /* define the CR master PWs array */
         tx_clock_rec_pw[0] = 1;
         tx_clock_rec_pw[second_cr_pw] = 1; /*new CR PW*/

         /* UFE line configuration */
         for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
         {
            for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
            {
               line_index = i*28 + j;

               /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
               /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */

               /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */
               /* set ufe Tx and Rx direction */
               if (tx_clock_rec_lines[line_index] == 1) /* lines 0-(N-1) use CR, all other don't */
                  sprintf(temp_buf, "0 %d 3 3",line_index);
               else
                  sprintf(temp_buf, "0 %d 3 2",line_index); /* lines number >N => don't use CR  */

               CLI_F_UfeTransferMode(temp_buf);

               /* match between clock tarnslators and lines for the CR lines   */
               /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
               if (line_index < second_cr_line)
               {
                  sprintf(temp_buf, "0 %d %d", line_index, 0);
               }
               else
                  /* conect all others to the first line */
               {
                  sprintf(temp_buf, "0 %d %d", line_index, 1);
               }
               CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, clock_trans_id */

               /* match between clock shaper and lines for the CR lines   */
               /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
               if (line_index < second_cr_line)
                  sprintf(temp_buf, "0 %d %d", line_index, 0);
               else
                  sprintf(temp_buf, "0 %d %d", line_index, 1);

               CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
            }
         }
         /* create line second time */
         CLI_F_UfeChipInitLineSetup("");
         /* recreate PW  */
         ct_index = 0;
         for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
         {
            for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
            {
               line_index = i*28 + j;
               pw_index = i*WTI_E1_LINES_PER_SPE + j;

               sprintf(temp_buf, "0 %d %d 32 32 32 0-31", line_index, pw_index);/* The line index of this PW */
               CLI_F_PwConfigureFramed(temp_buf);

               /* PWE3 channel configuration */
               CLI_F_Pwe3ChannelJitterBufferSize("0 32");
               CLI_F_Pwe3ChannelRxBufferSize("0 256");
               CLI_F_Pwe3ChannelStatmode("0 1");
               CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
               CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
               CLI_F_Pwe3ChannelUdpDummyMode("0 1");
               CLI_F_Pwe3ChannelTxUdcas("0 f");

               /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
               CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
               CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
               sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
               CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
               sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
               CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
               CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
               CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
               CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CLOCK_REC_MODE
               /* Rx timing is used in differential mode */
               /* first global_active_cr_async_mode related to different CDs */
               if (tx_clock_rec_pw[pw_index] == 1)
               {
                  sprintf(temp_buf, "0 1 1 %d",ct_index);
                  ct_index++;
               }
               else
                  sprintf(temp_buf, "0 0 1 %d",ct_index-1); /* 0->0 (1-(N-1))-> 0 too, so ct_index-1 */
               CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
               /* Rx timing is not used */
               sprintf(temp_buf, "0 0 1 %d",pw_index);
               CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

               /**************** PSN --> TDM IW *****************/
               /* if clock recovery is set -> Tx timing is used */
               if (tx_clock_rec_pw[pw_index] == 1)    /* lines 0-(N-1) use CR, all other don't */
                  CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
               else
                  CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
               CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
               CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

               /**************** PSN --> TDM Tx binding*****************/
               /* CR Rx and Tx direction */
               if (tx_clock_rec_pw[pw_index] == 1)   /* pw 0-(N-1) use CR, all other don't */
                  sprintf(temp_buf,"0 0 1 1 %d", pw_index); /* CR master */
               else
                  sprintf(temp_buf,"0 0 1 0 %d", pw_index); /* CR slave */
               CLI_F_PwCreate(temp_buf);

               if (tx_clock_rec_pw[pw_index] == 1)
                  sprintf(temp_buf, "0 %d 1",pw_index); /* line 1 is the master, all other slaves */
               else
                  sprintf(temp_buf, "0 %d 0",pw_index);
               CLI_F_PwEnable(temp_buf);
            } /* end for (configure each line) */
         }
      } /*if exit_factor */
   } /* while */
}
#endif /* (WTI_CESOP_CLOCK_RECOVERY_ENABLE & WTI_CESOP_RX_TIMING_ENABLE) */

#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE & WTI_CESOP_RX_TIMING_ENABLE)
/***************************************************************
 * Func name  :
 * Description:
 *             This test runs with RX and TX CR modules with 2 CD.
 *             The "Master" lines are '0' and 'second_cr_line' (lines with TX CR).
 *             After all lines were initialize and the test runs, all PW and lines are removed
 *             and deleted. Then, the system is recreated all lines and PWs but with different
 *             'second_cr_line'
 *             TDM2PSN: Test uses 2 CD for the first N PWs (PW=line in this case).
 *                      Each CD uses different shaper. All PWs > N use the first shaper.
 *             PSN2TDM: First N PWs are connected to N CTs respectively. PWs N+1 and forward
 *                      are connected to CT0.
 *             second_cr_line and second_cr_line_modify must be between 80 to 255 in order
 *             to enter all lines to RX Port RAM.
 *
 *             (*) N = "global_active_cr_async_mode"
 ***************************************************************/
void CLI_F_108_SBI_T1_F_CR_NoCas_Two_Boards_1_CD_1_CT_63_line_addremove_PW_with_shaper_modify(char *StrPrm)
{
   WP_U32 i, j, line_index, spe_index, pw_index, second_cr_pw, ct_index;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_CHAR exit_factor = '0';
   int temp_cr_line, second_cr_line = 160;
   int second_cr_line_modify = 169;
   int MAX_ACTIVE_PW = N_ACTIVE_UFE_SBI_SPE * WTI_T1_LINES_PER_SPE;

   WP_U8   tx_clock_rec_lines[336] = {0}; /* list of master lines */
   WP_U8   tx_clock_rec_pw[336 * WTI_PW_PER_LINE] = {0}; /* list of master pw */

   if (WTI_PW_PER_LINE != 1)
   {
      printf("ERROR - currently, this test can not work with WTI_PW_PER_LINE != 1\n");
      exit(1);
   }
   /* define the CR master lines array */
   tx_clock_rec_lines[0] = 1;
   tx_clock_rec_lines[second_cr_line] = 1;
   /* attached PW number to line number */
   second_cr_pw = second_cr_line;
   /* define the CR master PWs array */
   tx_clock_rec_pw[0] = 1;
   tx_clock_rec_pw[second_cr_pw] = 1;

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;

         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */

         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */
         /* set ufe Tx and Rx direction */
         if (tx_clock_rec_lines[line_index] == 1) /* lines 0-(N-1) use CR, all other don't */
            sprintf(temp_buf, "0 %d 1 3",line_index);
         else
            sprintf(temp_buf, "0 %d 1 2",line_index); /* lines number >N => don't use CR  */

         CLI_F_UfeTransferMode(temp_buf);

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (line_index < second_cr_line)
         {
            sprintf(temp_buf, "0 %d %d", line_index, 0);
         }
         else
         {
            sprintf(temp_buf, "0 %d %d", line_index, 1);
         }
         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, clock_trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (line_index < second_cr_line)
         {
            sprintf(temp_buf, "0 %d %d", line_index, 0);
         }
         else

         {
            sprintf(temp_buf, "0 %d %d", line_index, 1);
         }

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
      }
   }
   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 1");

   CLI_F_UfeChipInitLineSetup("");

   WUFE_SbiClockTranslatorDisplay(the_system->ufe.ufe_id);

   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (tx_clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }

#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   ct_index = 0;
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_T1_LINES_PER_SPE + j;

         sprintf(temp_buf, "0 %d %d 48 48 24 0-23", line_index, pw_index);/* The line index of this PW */
         CLI_F_PwConfigureFramed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 384");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 198 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CLOCK_REC_MODE
         /* Rx timing is used in differential mode */
         /* first global_active_cr_async_mode related to different CDs */
         if (tx_clock_rec_pw[pw_index] == 1)
         {
            sprintf(temp_buf, "0 1 1 %d",ct_index);
            ct_index++;
         }
         else
         {/* In differential mode all other pw (not first ones) uses CD#0 */
            sprintf(temp_buf, "0 0 1 %d",ct_index-1);
         }
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
         /* Rx timing is not used */
         sprintf(temp_buf, "0 0 1 %d",pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

         /**************** PSN --> TDM IW *****************/
         /* if clock recovery is set -> Tx timing is used */
         if (tx_clock_rec_pw[pw_index] == 1)    /* lines 0-(N-1) use CR, all other don't */
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/

         /* CR Rx and Tx direction */
         if (tx_clock_rec_pw[pw_index] == 1) /* pw 0-(N-1) use CR, all other don't */
            sprintf(temp_buf,"0 0 1 1 %d", pw_index); /* CR master */
         else
            sprintf(temp_buf,"0 0 1 0 %d", pw_index); /* CR slave */
         CLI_F_PwCreate(temp_buf);

         if (tx_clock_rec_pw[pw_index] == 1)
            sprintf(temp_buf, "0 %d 1",pw_index); /* line 1 is the master, all other slaves */
         else
            sprintf(temp_buf, "0 %d 0",pw_index);
         CLI_F_PwEnable(temp_buf);

      } /* end for (configure each line) */
   }

   /* run test in loop mode */
   while (exit_factor != '9')
   {
      /* print CR parameters */
      printf("Test running.\nType 's' to print statistics, 'c' to clear statistics, '9' to quit or any other key to modify shapers.\n");
      printf(" 1- line 0\n 2- second CR line (%d)\n 3- modify CR line (%d)\n",
             second_cr_line, second_cr_line_modify);
      exit_factor = getchar();
      if (exit_factor == '9')
      {
         printf("Exit test\n");
      }
      else if (exit_factor == 's')
      {
         printf("Check statistics:\n");
         sprintf(temp_buf, "0 %d", MAX_ACTIVE_PW);
         CLI_F_Pwe3StatisticsCheck(temp_buf);
         CLI_F_ClockRecSystemsStatisticsStatus("0");
      }
      else if (exit_factor == 'c')
      {
         printf("Clear statistics\n");
         sprintf(temp_buf, "0 %d", MAX_ACTIVE_PW);
         CLI_F_Pwe3StatisticsClear(temp_buf);
         CLI_F_ClockRecSystemsStatisticsReset("0");
      }
      else if (exit_factor == '1')
      {
         CLI_F_TransDevShowInfo("0 0 0");
      }
      else if (exit_factor == '2')
      {
         sprintf(temp_buf, "0 %d %d", second_cr_line, second_cr_line);
         CLI_F_TransDevShowInfo(temp_buf);
      }
      else if (exit_factor == '3')
      {
         sprintf(temp_buf, "0 %d %d", second_cr_line_modify, second_cr_line_modify);
         CLI_F_TransDevShowInfo(temp_buf);
      }
      else
      {
         /* remove PWs */
         printf("..:: Removing PW.\n");
         WP_Delay(100000); /*time in usec*/

         for (i=N_ACTIVE_UFE_SBI_SPE; i>0; i--)
         {
            for (j=WTI_T1_LINES_PER_SPE; j>0; j--)
            {
               pw_index = (i-1)*WTI_T1_LINES_PER_SPE + (j-1);
               sprintf(temp_buf, "0 %d", pw_index);
               CLI_F_PwRemove(temp_buf);
            }
         }

         /* remove lines */
         for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
         {
            for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
            {
               line_index = i*28 + j;

               /* this do line disable and line delete */
               WT_UfeLineDelete(&the_system->ufe, line_index);
            }
         }

         printf("PWs and lines removed. Type any key to Recreate...\n");
         exit_factor = getchar();
         if (exit_factor == '9')
            break;
         /* change CR place, from PW=second_cr_line to PW="new" second_cr_line */

         /* define the CR master lines array */
         tx_clock_rec_lines[second_cr_line] = 0; /*old CR*/
         tx_clock_rec_pw[second_cr_pw] = 0; /*old CR*/
         /* initialize the clock recovery parameters for new cr line */
         memcpy(&the_system->clock_rec[second_cr_line_modify],
                &the_system->clock_rec[second_cr_line],
                sizeof(WP_clock_rec_params));
         temp_cr_line = second_cr_line;
         second_cr_line = second_cr_line_modify;
         second_cr_line_modify = temp_cr_line;
         tx_clock_rec_lines[second_cr_line] = 1; /*new CR line*/

         /* attached PW number to line number */
         second_cr_pw = second_cr_line;

         /* define the CR master PWs array */
         tx_clock_rec_pw[0] = 1;
         tx_clock_rec_pw[second_cr_pw] = 1; /*new CR PW*/

         /* UFE line configuration */
         for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
         {
            for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
            {
               line_index = i*28 + j;

               /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
               /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */

               /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */
               /* set ufe Tx and Rx direction */
               if (tx_clock_rec_lines[line_index] == 1) /* lines 0-(N-1) use CR, all other don't */
                  sprintf(temp_buf, "0 %d 1 3",line_index);
               else
                  sprintf(temp_buf, "0 %d 1 2",line_index); /* lines number >N => don't use CR  */

               CLI_F_UfeTransferMode(temp_buf);

               /* match between clock tarnslators and lines for the CR lines   */
               /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
               if (line_index < second_cr_line)
               {
                  sprintf(temp_buf, "0 %d %d", line_index, 0);
               }
               else
                  /* conect all others to the first line */
               {
                  sprintf(temp_buf, "0 %d %d", line_index, 1);
               }
               CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, clock_trans_id */

               /* match between clock shaper and lines for the CR lines   */
               /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
               if (line_index < second_cr_line)
                  sprintf(temp_buf, "0 %d %d", line_index, 0);
               else
                  sprintf(temp_buf, "0 %d %d", line_index, 1);

               CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
            }
         }
         /* create line second time */
         CLI_F_UfeChipInitLineSetup("");
         /* recreate PW  */
         ct_index = 0;
         for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
         {
            for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
            {
               line_index = i*28 + j;
               pw_index = i*WTI_T1_LINES_PER_SPE + j;

               sprintf(temp_buf, "0 %d %d 48 48 24 0-23", line_index, pw_index);/* The line index of this PW */
               CLI_F_PwConfigureFramed(temp_buf);

               /* PWE3 channel configuration */
               CLI_F_Pwe3ChannelJitterBufferSize("0 32");
               CLI_F_Pwe3ChannelRxBufferSize("0 384");
               CLI_F_Pwe3ChannelStatmode("0 1");
               CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
               CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
               CLI_F_Pwe3ChannelUdpDummyMode("0 1");
               CLI_F_Pwe3ChannelTxUdcas("0 f");

               /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
               CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
               CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
               sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
               CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
               sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
               CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
               CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 198 0");
               CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
               CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CLOCK_REC_MODE
               /* Rx timing is used in differential mode */
               /* first global_active_cr_async_mode related to different CDs */
               if (tx_clock_rec_pw[pw_index] == 1)
               {
                  sprintf(temp_buf, "0 1 1 %d",ct_index);
                  ct_index++;
               }
               else
                  sprintf(temp_buf, "0 0 1 %d",ct_index-1); /* 0->0 (1-(N-1))-> 0 too, so ct_index-1 */
               CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
               /* Rx timing is not used */
               sprintf(temp_buf, "0 0 1 %d",pw_index);
               CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

               /**************** PSN --> TDM IW *****************/
               /* if clock recovery is set -> Tx timing is used */
               if (tx_clock_rec_pw[pw_index] == 1)    /* lines 0-(N-1) use CR, all other don't */
                  CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
               else
                  CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
               CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
               CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

               /**************** PSN --> TDM Tx binding*****************/
               /* CR Rx and Tx direction */
               if (tx_clock_rec_pw[pw_index] == 1)   /* pw 0-(N-1) use CR, all other don't */
                  sprintf(temp_buf,"0 0 1 1 %d", pw_index); /* CR master */
               else
                  sprintf(temp_buf,"0 0 1 0 %d", pw_index); /* CR slave */
               CLI_F_PwCreate(temp_buf);

               if (tx_clock_rec_pw[pw_index] == 1)
                  sprintf(temp_buf, "0 %d 1",pw_index); /* line 1 is the master, all other slaves */
               else
                  sprintf(temp_buf, "0 %d 0",pw_index);
               CLI_F_PwEnable(temp_buf);
            } /* end for (configure each line) */
         }
      } /*if exit_factor */
   } /* while */
}
#endif /* (WTI_CESOP_CLOCK_RECOVERY_ENABLE & WTI_CESOP_RX_TIMING_ENABLE) */

#if (WTI_CESOP_RX_TIMING_ENABLE && WTI_CESOP_CLOCK_RECOVERY_ENABLE)
/********************************************************************************************
 * Description:
 * This test runs with TX and RX CR modules.
 *
 * TDM2PSN :  The test uses one CD in all PW (in this case PW = line) are using the same
 *            shaper (conected to the first one).
 * PSN2TDM :  All lines conected to CT#0.
 *
 *
 * The test can run upto 252 lines all use same PS but 2 different data unit size (DU size).
 * Set half (even) pw to work with DUS = 32 and half (odd) with DUS 64
 *
 * The use of different DU sizes on the same shaper is tested.
 *
 *******************************************************************************************/
void CLI_F_107_SBI_E1_F_CR_NoCas_Two_Boards_1_CD_1_CT_Different_DU_size(char *StrPrm)
{
   WP_U32 i, j, line_index, spe_index, pw_index,Temp_index;
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U8   clock_rec_lines[336] = {0}; /* list of master lines */

   /* Set the CR lines (both for RX and TX direction */
   /* Set line 0 to be CR master */
   clock_rec_lines[0] = 1;

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }


   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 3 3",line_index);
         }
         else
         {
            /* set ufe Rx direction only - for all lines */
            sprintf(temp_buf, "0 %d 3 2",line_index);
         }
         CLI_F_UfeTransferMode(temp_buf);

         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, line_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, line_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
      }
   }


   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 3");

   CLI_F_UfeChipInitLineSetup("");

   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_E1_LINES_PER_SPE + j;
         /* Set half (even) pw to work with DUS = 32 and half (odd) with DUS 64 */
         Temp_index = pw_index%2;
         if(Temp_index)
         {
            sprintf(temp_buf, "0 %d 64 64 32 0-31", line_index);
         }
         else
         {
            sprintf(temp_buf, "0 %d 32 32 32 0-31", line_index);
         }

         CLI_F_PwConfigureFramed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 256");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CLOCK_REC_MODE
         /* Rx timing is used in differential mode */
         /* In differential mode all other pw uses CD#0 */

         /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER),
            ts_diff_if_id(0-31)] */
         sprintf(temp_buf, "0 1 1 0");
#else
         /* Rx timing is not used */

         /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER),
            ts_diff_if_id(0-31)] */
         sprintf(temp_buf, "0 0 0 0");
#endif
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);


         /**************** PSN --> TDM IW *****************/

         /* PW 0 is the master to CT#0 which used by all lines */
         if (pw_index == 0 )
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/
         /* ------------------------------- Create and Enable all PWs  --------------------------------------- */

         if (pw_index == 0)
         {
            /* CR master Rx and Tx direction */
            CLI_F_PwCreate("0 0 1 1");
            /* Enable CR TX */
            sprintf(temp_buf, "0 %d 1",pw_index);
         }
         else
         {
            /* Set all PW in rx to work in shapping mode */
            CLI_F_PwCreate("0 0 1 0");
            sprintf(temp_buf, "0 %d 0",pw_index);
         }
         CLI_F_PwEnable(temp_buf);

      } /* end for (configure each line) */
   }
}
#endif /* (WTI_CESOP_RX_TIMING_ENABLE && WTI_CESOP_CLOCK_RECOVERY_ENABLE) */

#if (WTI_CESOP_RX_TIMING_ENABLE && WTI_CESOP_CLOCK_RECOVERY_ENABLE)
/********************************************************************************************
 * Description:
 * This test runs with TX and RX CR modules.
 *
 * TDM2PSN :  The test uses one CD in all PW (in this case PW = line) are using the same
 *            shaper (conected to the first one).
 * PSN2TDM :  All lines conected to CT#0.
 *
 *
 * This test fills DU with only 2 slots from each frame. Therefore, (125*2)*24 T1 clocks is
 * required to fill 1 DU. => the delta_TS should be bigger then TS width field and error
 * will rise. THIS IS RELEVANT FOR UFE2 ONLY because the TS pass inband. In UFE3 the TS
 * is read directly from the host and no delta_TS is required.
 *
 * The test can run upto 192 lines all use same PS (192 is the max size of TSRX RAM).
 *
 *******************************************************************************************/
void CLI_F_107_SBI_T1_F_CR_NoCas_Two_Boards_1_CD_1_CT_TSWidth_Overflow(char *StrPrm)
{
   WP_U32 i, j, line_index, spe_index, pw_index,Temp_index;
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U8   clock_rec_lines[336] = {0}; /* list of master lines */

   /* Set the CR lines (both for RX and TX direction */
   /* Set line 0 to be CR master */
   clock_rec_lines[0] = 1;

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }


   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;

         if (line_index >= 192)
         {
            printf("**** WARNING! TEST CAN NOT RUN WITH MORE THEN 192 LINES ON ONE RX PORT RAM ****\n");
            break;
         }
         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 1 3",line_index);
         }
         else
         {
            /* set ufe Rx direction only - for all lines */
            sprintf(temp_buf, "0 %d 1 2",line_index);
         }
         CLI_F_UfeTransferMode(temp_buf);

         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, line_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, line_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
      }
   }


   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 1");

   CLI_F_UfeChipInitLineSetup("");

   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_T1_LINES_PER_SPE + j;

         if (line_index >= 192)
            break;

         /* Set half (even) pw to work with DUS = 32 and half (odd) with DUS 64 */
         Temp_index = pw_index%2;
         if(Temp_index)
         {
            sprintf(temp_buf, "0 %d 48 48 2 0-1", line_index);
         }
         else
         {
            sprintf(temp_buf, "0 %d 48 48 2 0-1", line_index);
         }

         CLI_F_PwConfigureFramed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 192");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");


         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 d8 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CLOCK_REC_MODE
         /* Rx timing is used in differential mode */
         /* In differential mode all other pw uses CD#0 */

         /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER),
            ts_diff_if_id(0-31)] */
         sprintf(temp_buf, "0 1 1 0");
#else
         /* Rx timing is not used */

         /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER),
            ts_diff_if_id(0-31)] */
         sprintf(temp_buf, "0 0 0 0");
#endif
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);


         /**************** PSN --> TDM IW *****************/

         /* PW 0 is the master to CT#0 which used by all lines */
         if (pw_index == 0 )
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/
         /* ------------------------------- Create and Enable all PWs  --------------------------------------- */

         if (pw_index == 0)
         {
            /* CR master Rx and Tx direction */
            CLI_F_PwCreate("0 0 1 1");
            /* Enable CR TX */
            sprintf(temp_buf, "0 %d 1",pw_index);
         }
         else
         {
            /* Set all PW in rx to work in shapping mode */
            CLI_F_PwCreate("0 0 1 0");
            sprintf(temp_buf, "0 %d 0",pw_index);
         }
         CLI_F_PwEnable(temp_buf);

      } /* end for (configure each line) */
   }
}
#endif /* (WTI_CESOP_RX_TIMING_ENABLE && WTI_CESOP_CLOCK_RECOVERY_ENABLE) */

#if (WTI_CESOP_RX_TIMING_ENABLE && WTI_CESOP_CLOCK_RECOVERY_ENABLE)
/********************************************************************************************
 * Description:
 * This test runs with TX and RX CR modules.
 *
 * TDM2PSN :  The test uses one CD in all PW (in this case PW = line) are using the same
 *            shaper (conected to the first one).
 * PSN2TDM :  All lines conected to CT#0.
 *
 *
 * The test can run upto 84 lines all use same PS but 2 different data unit size (DU size).
 * Set half (even) pw to work with DUS = 24 and half (odd) with DUS 48
 *
 * The use of different DU sizes on the same shaper is tested.
 *
 *******************************************************************************************/
void CLI_F_107_SBI_T1_F_CR_NoCas_Two_Boards_1_CD_1_CT_Different_DU_size(char *StrPrm)
{
   WP_U32 i, j, line_index, spe_index, pw_index,Temp_index;
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U8   clock_rec_lines[336] = {0}; /* list of master lines */

   /* Set the CR lines (both for RX and TX direction */
   /* Set line 0 to be CR master */
   clock_rec_lines[0] = 1;

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }


   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;

         if (line_index >= 192)
         {
            printf("**** WARNING! TEST CAN NOT RUN WITH MORE THEN 192 LINES ON ONE RX PORT RAM ****\n");
            break;
         }
         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 1 3",line_index);
         }
         else
         {
            /* set ufe Rx direction only - for all lines */
            sprintf(temp_buf, "0 %d 1 2",line_index);
         }
         CLI_F_UfeTransferMode(temp_buf);

         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, line_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, line_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
      }
   }


   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 1");

   CLI_F_UfeChipInitLineSetup("");

   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_T1_LINES_PER_SPE + j;
         if (line_index >= 192)
            break;

         /* Set half (even) pw to work with DUS = 32 and half (odd) with DUS 64 */
         Temp_index = pw_index%2;
         if(Temp_index)
         {
            sprintf(temp_buf, "0 %d 48 48 24 0-23", line_index);
         }
         else
         {
            sprintf(temp_buf, "0 %d 24 24 24 0-23", line_index);
         }

         CLI_F_PwConfigureFramed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 192");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");


         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 d8 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CLOCK_REC_MODE
         /* Rx timing is used in differential mode */
         /* In differential mode all other pw uses CD#0 */

         /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER),
            ts_diff_if_id(0-31)] */
         sprintf(temp_buf, "0 1 1 0");
#else
         /* Rx timing is not used */

         /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER),
            ts_diff_if_id(0-31)] */
         sprintf(temp_buf, "0 0 0 0");
#endif
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);


         /**************** PSN --> TDM IW *****************/

         /* PW 0 is the master to CT#0 which used by all lines */
         if (pw_index == 0 )
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/
         /* ------------------------------- Create and Enable all PWs  --------------------------------------- */

         if (pw_index == 0)
         {
            /* CR master Rx and Tx direction */
            CLI_F_PwCreate("0 0 1 1");
            /* Enable CR TX */
            sprintf(temp_buf, "0 %d 1",pw_index);
         }
         else
         {
            /* Set all PW in rx to work in shapping mode */
            CLI_F_PwCreate("0 0 1 0");
            sprintf(temp_buf, "0 %d 0",pw_index);
         }
         CLI_F_PwEnable(temp_buf);

      } /* end for (configure each line) */
   }
}
#endif /* (WTI_CESOP_RX_TIMING_ENABLE && WTI_CESOP_CLOCK_RECOVERY_ENABLE) */

#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE && WTI_CESOP_RX_TIMING_ENABLE)
/***************************************************************
 * Func name  :
 * Description:
 *             This test runs with RX and TX CR modules
 *             TDM2PSN: Test uses N CD for the first N PWs (PW=line in this case).
 *                      Each CD uses different shaper. All PWs > N use the first shaper.
 *             PSN2TDM: First N PWs are connected to N CTs respectively. PWs N+1 and forward
 *                      are connected to CT0.
 *             (*) N = "global_active_cr_async_mode"
 ***************************************************************/
void CLI_F_110_SBI_E1_U_CR_NoCas_Two_Boards_N_CD_N_CT_max_lines_FA_modify(char *StrPrm)
{
   WP_U32 i, j, line_index, spe_index, cd_index, pw_index;
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_CHAR exit_factor = '0';
   int MAX_ACTIVE_PW = N_ACTIVE_UFE_SBI_SPE * WTI_E1_LINES_PER_SPE;
   WP_status status;

   WP_U8   clock_rec_lines[336] = {0}; /* list of master lines */
   WP_U8   clock_rec_pw[336] = {0}; /* list of master PWs */

   /* Set the CR lines (both for RX and TX direction */
#if (WTI_CESOP_RX_TIMING_ENABLE || WTI_CESOP_CLOCK_RECOVERY_ENABLE)
   for (i = 0/*236*/; i < 32/*252*/; i++)
   {
      clock_rec_lines[CLI_F_AttacheLineToPwNumber(i)] = 1;
      clock_rec_pw[i] = 1;
   }

#endif

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }


   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE||WTI_CESOP_RX_TIMING_ENABLE)
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE || WTI_CESOP_RX_TIMING_ENABLE */

   cd_index = 0;
   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;

         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */

         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */
         /* set ufe Tx and Rx direction */
         if (clock_rec_lines[line_index] == 1) /* lines 0-(N-1) use CR, all other don't */
         {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
#if WTI_CESOP_RX_TIMING_ENABLE
            sprintf(temp_buf, "0 %d 4 3",line_index);
#else
            /* set ufe Tx direction only */
            sprintf(temp_buf, "0 %d 4 1",line_index);
#endif

#else /* Not WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Rx direction only */
            sprintf(temp_buf, "0 %d 4 2",line_index);
#endif

#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */
         }
         else
         {
#if WTI_CESOP_RX_TIMING_ENABLE
            sprintf(temp_buf, "0 %d 4 2",line_index); /* lines number >N => don't use CR  */
#else
            sprintf(temp_buf, "0 %d 4 0",line_index); /* line doesn't use CR on any direction */
#endif
         }

         CLI_F_UfeTransferMode(temp_buf);

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cd_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }
         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, clock_trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */
#endif /* end of WTI_CESOP_CLOCK_RECOVERY_ENABLE*/
#if WTI_CESOP_RX_TIMING_ENABLE

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cd_index);
            cd_index++;
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
#endif
      }
   }
   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 2");

   CLI_F_UfeChipInitLineSetup("");

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }
#endif

#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   cd_index = 0;
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_E1_LINES_PER_SPE + j;

         sprintf(temp_buf, "0 %d %d 32 32", line_index, pw_index);/* The line index of this PW */
         CLI_F_PwConfigureUnframed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 256");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
         /* Rx timing is used in differential mode */
         /* first global_active_cr_async_mode related to different CDs */
         if (clock_rec_pw[pw_index])
         {
            sprintf(temp_buf, "0 1 1 %d",cd_index);
            cd_index++;
         }
         else
         {/* In differential mode all other pw (not first ones) uses CD#0 */
            sprintf(temp_buf, "0 0 1 %d",pw_index);
         }
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
         /* Rx timing is not used */
         sprintf(temp_buf, "0 0 1 %d",pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

         /**************** PSN --> TDM IW *****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* if clock recovery is set -> Tx timing is used */
         if (clock_rec_pw[pw_index])
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#else
         /* if clock recovery is disable -> Tx timing is not used */
         CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#endif

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/

         /* CR Rx and Tx direction */
         if (clock_rec_pw[pw_index])
         {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
#if WTI_CESOP_RX_TIMING_ENABLE
            sprintf(temp_buf, "0 0 1 1 %d",pw_index);
            CLI_F_PwCreate(temp_buf); /* CR master */
#else
            /* CR master Tx direction */
            sprintf(temp_buf, "0 0 0 1 %d",pw_index);
            CLI_F_PwCreate(temp_buf); /* CR master */
#endif

#else /* not  WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
            /* CR master Rx  direction only */
            sprintf(temp_buf, "0 0 1 0 %d",pw_index);
            CLI_F_PwCreate(temp_buf); /* CR master */
#endif
#endif
         }

         else
         {
#if WTI_CESOP_RX_TIMING_ENABLE
            sprintf(temp_buf, "0 0 1 0 %d",pw_index);
            CLI_F_PwCreate(temp_buf); /* CR slave */
#else
            sprintf(temp_buf, "0 0 0 0 %d",pw_index);
            CLI_F_PwCreate(temp_buf);
#endif
         }

         if (clock_rec_pw[pw_index])
            sprintf(temp_buf, "0 %d 1",pw_index); /* line 1 is the master, all other slaves */
         else
            sprintf(temp_buf, "0 %d 0",pw_index);
         CLI_F_PwEnable(temp_buf);

      } /* end for (configure each line) */
   }

   /* run test in loop mode */
   while (exit_factor != '9')
   {
      printf("Test running.\nType 's' to print statistics, 'c' to clear statistics, d/e RCPT for lines 0/1, '9' to quit or any other key to remove all PW.\n");
      exit_factor = getchar();
      if (exit_factor == '9')
      {
         printf("Exit test\n");
      }
      else if (exit_factor == 's')
      {
         printf("Check statistics:\n");
         sprintf(temp_buf, "0 %d", MAX_ACTIVE_PW);
         CLI_F_Pwe3StatisticsCheck(temp_buf);
      }
      else if (exit_factor == 'c')
      {
         printf("Clear statistics\n");
         sprintf(temp_buf, "0 %d", MAX_ACTIVE_PW);
         CLI_F_Pwe3StatisticsClear(temp_buf);
      }
      else if (exit_factor == 'd')
      {
         printf("CLI_F_TransDevShowInfo for line 0\n");
         CLI_F_Pwe3ChannelShowInfo("0 0 0");
      }
      else if (exit_factor == 'e')
      {
         printf("CLI_F_TransDevShowInfo for line 1\n");
         CLI_F_Pwe3ChannelShowInfo("0 0 1");
      }
      else
      {
         /* modify PWs */
         printf("..:: Modify PW.\n");
         WP_Delay(100000); /*time in usec*/

         for (i=N_ACTIVE_UFE_SBI_SPE; i>0; i--)
         {
            for (j=WTI_E1_LINES_PER_SPE; j>0; j--)
            {
               /* (1) PW disable */
               pw_index = (i-1)*WTI_E1_LINES_PER_SPE + (j-1);
               sprintf(temp_buf, "0 %d", pw_index);
               CLI_F_PwDisable(temp_buf);

               /* (2) Channel Modify */
               sprintf(temp_buf, "0 %d 3 256", pw_index);
               CLI_F_Pwe3TransRxChannelModify(temp_buf);/*&cmd, &index, &mod, &val RX_BUFFERSIZE */

               /* (3) RX FA Modify */
               if (clock_rec_pw[pw_index])
                  sprintf(temp_buf, "0 %d 22 %d 0", pw_index, pw_index);
               else
                  sprintf(temp_buf, "0 %d 22 %d 0", pw_index, 0);
               CLI_F_Tdm2PsnCesopFlowAggModify(temp_buf);

               /* (4) IW RX binding */
               WTI_RxBindingDirectMapConfig(&trans_rx_binding_config, pw_index);
               status = WP_IwRxBindingModify(the_system->pw[pw_index].trans_rx,
                                             the_system->tdm2psn_iw_system,
                                             the_system->qnode[WTI_QNODE_IW_TDM2PSN].handle,
                                             WP_IW_RX_BIND_MOD_DEFAULT_AGG,
                                             &trans_rx_binding_config);
               WTI_TerminateOnError(status, "WP_IwRxBindingModify TDM --> PSN", __LINE__);
            }
         }

         printf("PW modified. Type any key to Recreate...\n");
         exit_factor = getchar();
         if (exit_factor == '9')
            break;

         /* Enable PW again with the same parameters */
         for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
         {
            for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
            {
               pw_index = i*WTI_E1_LINES_PER_SPE + j;

               if (clock_rec_pw[pw_index])
                  sprintf(temp_buf, "0 %d 1",pw_index);
               else
                  sprintf(temp_buf, "0 %d 0",pw_index);
               CLI_F_PwEnable(temp_buf);

            } /* end for (configure each line) */
         }
      } /*if exit_factor */
   } /* while */

}
#endif /* (WTI_CESOP_RX_TIMING_ENABLE && WTI_CESOP_CLOCK_RECOVERY_ENABLE) */

#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE && WTI_CESOP_RX_TIMING_ENABLE)
/***************************************************************
 * Func name  :
 * Description: This test creates multiple PW per line with two CR masters on different places.
 *              First CR (CR 0) is connected to SPE 0, line 0, PW 0. Second CR (CR 1) can be
 *              connected to any line in any SPE (including SPE 0) but have to be on the first PW
 *              in the line.
 *              CR 0 acts as master for SPE 0, line 0 and to all lines until CR 1. CR 1 acts as master
 *              for all other available lines. For example, if CR 1 is on SPE 1's first line so;
 *              CR 0 is master for SPE 0, lines 0-27 (T1). CR 1 is master for SPE 1+2, lines 28-83.
 *              The PW with CR have to be defined properly according to the second line's CR master
 *              location.
 *
 *              This test is one board simulation, Enet in loopback, ACTIVE_CR_FOR_ASYNC_MODE = 3,
 *              ACTIVE_UFE_SBI_SPE = 3, ACTIVE_UFE_OCT_LINES = 3,
 *              ==> Important!! Due to measurement problems, only one SPE can be monitoring
 *              (on the ANT-20) so if CR 1 isn't connected to the first line in the SPE,
 *              the lines before it will not be synchronize (the JB will gets underruns and overruns).
 *
 *              second_cr_line defines the line location of the second CR master.
 *              second_CR_PW defines the PW location of the second CR master. The CR's PW and the
 *              CR's line have to be well defined (for example: in T1 2nd_CR_line = 28, pw_per_line = 3
 *              => 2nd_CR_PW = 84.
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_111_SBI_E1_F_CR_NoCas_Two_Boards_Two_CR_Master_Multiple_PW_per_line(char *StrPrm)
{
   int pw_per_line = 2;
   WP_U32 i, j, line_index, spe_index, pw_index, second_CR_PW, ct_index = 0;
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U8   clock_rec_lines[336] = {0}; /* list of master lines */
   WP_U8   clock_rec_pw[336 * 32] = {0}; /* list of master pw */
   WP_U8   clock_rec_pw_psn2tdm[336*32] = {0}; /* list of active CR PWs in the TX direction */
   int second_cr_line = 6;

   /* validate CR line number */
   CLI_F_CheckValidE1Line(second_cr_line);

   /* define the CR master lines array */
   clock_rec_lines[0] = 1;
   clock_rec_pw_psn2tdm[0] = 1;
   clock_rec_lines[second_cr_line] = 1;


   second_CR_PW = CLI_F_AttachePwToLineNumber(second_cr_line*pw_per_line);
   /* define the CR master PWs array */
   clock_rec_pw[0] = 1;
   clock_rec_pw_psn2tdm[0] = 1;
   clock_rec_pw[second_CR_PW] = 1;
   clock_rec_pw_psn2tdm[second_CR_PW] = 1;

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }


   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;

         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */
#if WTI_CESOP_RX_TIMING_ENABLE

         /* set ufe Tx and Rx direction */
         if (clock_rec_lines[line_index] == 1) /* line uses CR */
            sprintf(temp_buf, "0 %d 3 3",line_index);
         else
            sprintf(temp_buf, "0 %d 3 0",line_index); /* line doesn't use CR  */
#else
         /* set ufe Tx direction only */
         if (clock_rec_lines[line_index] == 1) /* line uses CR */
            sprintf(temp_buf, "0 %d 3 1",line_index);
         else
            sprintf(temp_buf, "0 %d 3 0",line_index); /* line doesn't use CR  */
#endif

#else

#if WTI_CESOP_RX_TIMING_ENABLE
         /* differential mode timing only set ufe Rx direction */
         sprintf(temp_buf, "0 %d 3 2",line_index);
#else
         /* no timing or adaptive mode */
         sprintf(temp_buf, "0 %d 3 0",line_index);
#endif

#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */

         CLI_F_UfeTransferMode(temp_buf);

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines*/
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (line_index < second_cr_line)
         { /* line index can exceed the corrent SPE. '0' and '1' are CT numbers */
            sprintf(temp_buf, "0 %d %d", line_index,0);
         }
         else
         {
            sprintf(temp_buf, "0 %d %d", line_index,1);
         }

         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index (0-83), trans_id (0-31) */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

#if WTI_CESOP_RX_TIMING_ENABLE
         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (line_index < second_cr_line)
         {
            sprintf(temp_buf, "0 %d %d", line_index, 0);
         }
         else

         {
            sprintf(temp_buf, "0 %d %d", line_index, 1);
         }

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
#endif
      }
   }


   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 3");

   CLI_F_UfeChipInitLineSetup("");

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }
#endif

#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif
   ct_index = 0; /* ct_index is used as an internal CT counter in the upcoming loop */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE * pw_per_line; j++)
      {

         line_index = i*28 + j/pw_per_line;
         pw_index = i*WTI_E1_LINES_PER_SPE * pw_per_line + j;

         sprintf(temp_buf, "0 %d 32 32 %d %d-%d", line_index, 32/pw_per_line, 32/pw_per_line*(pw_index%pw_per_line), 32/pw_per_line*(pw_index%pw_per_line)+(32/pw_per_line-1)); /* The line index of this PW and its matching slots. */
         CLI_F_PwConfigureFramed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 256");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if (WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE)
         /* Rx timing is used */
         /* Note that we send the CR interface ID not the line id*/

         if (clock_rec_pw[pw_index] == 1)
         {
            sprintf(temp_buf, "0 1 1 %d", ct_index); /* ct_index is the Clk Translator interface ID */
            ct_index++;
         }
         else
            sprintf(temp_buf, "0 0 0 0");

         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS),ts_diff_if_id(0-31)] */
#else
         sprintf(temp_buf, "0 0 0 0");
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS),ts_diff_if_id(0-31)] */
#endif

         /**************** PSN --> TDM IW *****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* if clock recovery is set -> Tx timing is used */
         if (clock_rec_pw[pw_index] == 1)
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#else
         /* if clock recovery is disable -> Tx timing is not used */
         CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#endif
         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE

#if WTI_CESOP_RX_TIMING_ENABLE
         /* CR master Rx and Tx direction */
         if (clock_rec_pw[pw_index] == 1)
            CLI_F_PwCreate("0 0 1 1"); /* CR master */
         else
            CLI_F_PwCreate("0 0 0 0"); /* CR slave */
#else
         /* CR master Tx direction */
         if (clock_rec_pw[pw_index] == 1)
            CLI_F_PwCreate("0 0 0 1"); /* CR master */
         else
            CLI_F_PwCreate("0 0 0 0"); /* CR slave */
#endif
         if (clock_rec_pw[pw_index] == 1)
            sprintf(temp_buf, "0 %d 1",pw_index); /* pw is master, all other slaves */
         else
            sprintf(temp_buf, "0 %d 0",pw_index);
         CLI_F_PwEnable(temp_buf);
#else
         /* no timing */
         CLI_F_PwCreate("0 0 0 0"); /* slave mode */
         sprintf(temp_buf, "0 %d 0",pw_index);
         CLI_F_PwEnable(temp_buf);
#endif

      } /* end for (configure each line and pw) */
   }
}
#endif /* (WTI_CESOP_RX_TIMING_ENABLE && WTI_CESOP_CLOCK_RECOVERY_ENABLE) */

#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE && WTI_CESOP_RX_TIMING_ENABLE)
/***************************************************************
 * Func name  :
 * Description: This test creates multiple PW per line with two CR masters on different places.
 *              First CR (CR 0) is connected to SPE 0, line 0, PW 0. Second CR (CR 1) can be
 *              connected to any line in any SPE (including SPE 0) but have to be on the first PW
 *              in the line.
 *              CR 0 acts as master for SPE 0, line 0 and to all lines until CR 1. CR 1 acts as master
 *              for all other available lines. For example, if CR 1 is on SPE 1's first line so;
 *              CR 0 is master for SPE 0, lines 0-27 (T1). CR 1 is master for SPE 1+2, lines 28-83.
 *              The PW with CR have to be defined properly according to the second line's CR master
 *              location.
 *
 *              This test is one board simulation, Enet in loopback, ACTIVE_CR_FOR_ASYNC_MODE = 3,
 *              ACTIVE_UFE_SBI_SPE = 3, ACTIVE_UFE_OCT_LINES = 3,
 *              ==> Important!! Due to measurement problems, only one SPE can be monitoring
 *              (on the ANT-20) so if CR 1 isn't connected to the first line in the SPE,
 *              the lines before it will not be synchronize (the JB will gets underruns and overruns).
 *
 *              second_cr_line defines the line location of the second CR master.
 *              second_CR_PW defines the PW location of the second CR master. The CR's PW and the
 *              CR's line have to be well defined (for example: in T1 2nd_CR_line = 28, pw_per_line = 3
 *              => 2nd_CR_PW = 84.
 * Input      :
 * OutPut     :
 * Return Val :
 ***************************************************************/
void CLI_F_111_SBI_T1_F_CR_NoCas_Two_Boards_Two_CR_Master_Multiple_PW_per_line(char *StrPrm)
{
   int pw_per_line = 2;
   WP_U32 i, j, line_index, spe_index, pw_index, second_CR_PW, ct_index = 0;
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U8   clock_rec_lines[336] = {0}; /* list of master lines */
   WP_U8   clock_rec_pw[336 * 32] = {0}; /* list of master pw */
   int second_cr_line = 48;

   second_CR_PW = second_cr_line * pw_per_line;
   /* define the CR master lines array */
   clock_rec_lines[0] = 1;
   clock_rec_lines[second_cr_line] = 1;
   /* define the CR master PWs array */
   clock_rec_pw[0] = 1;
   clock_rec_pw[second_CR_PW] = 1;

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }


   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;

         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */
#if WTI_CESOP_RX_TIMING_ENABLE

         /* set ufe Tx and Rx direction */
         if (clock_rec_lines[line_index] == 1) /* line uses CR */
            sprintf(temp_buf, "0 %d 1 3",line_index);
         else
            sprintf(temp_buf, "0 %d 1 0",line_index); /* line doesn't use CR  */
#else
         /* set ufe Tx direction only */
         if (clock_rec_lines[line_index] == 1) /* line uses CR */
            sprintf(temp_buf, "0 %d 1 1",line_index);
         else
            sprintf(temp_buf, "0 %d 1 0",line_index); /* line doesn't use CR  */
#endif

#else

#if WTI_CESOP_RX_TIMING_ENABLE
         /* differential mode timing only set ufe Rx direction */
         sprintf(temp_buf, "0 %d 1 2",line_index);
#else
         /* no timing or adaptive mode */
         sprintf(temp_buf, "0 %d 1 0",line_index);
#endif

#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */

         CLI_F_UfeTransferMode(temp_buf);

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines*/
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (line_index < second_cr_line)
         { /* line index can exceed the corrent SPE. '0' and '1' are CT numbers */
            sprintf(temp_buf, "0 %d %d", line_index,0);
         }
         else
         {
            sprintf(temp_buf, "0 %d %d", line_index,1);
         }

         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index (0-83), trans_id (0-31) */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

#if WTI_CESOP_RX_TIMING_ENABLE
         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (line_index < second_cr_line)
         {
            sprintf(temp_buf, "0 %d %d", line_index, 0);
         }
         else

         {
            sprintf(temp_buf, "0 %d %d", line_index, 1);
         }

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
#endif
      }
   }


   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 1");

   CLI_F_UfeChipInitLineSetup("");

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }
#endif

#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif
   ct_index = 0; /* ct_index is used as an internal CT counter in the upcoming loop */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE *pw_per_line; j++)
      {

         line_index = i*28 + j/pw_per_line;
         pw_index = i*WTI_T1_LINES_PER_SPE * pw_per_line + j;

         sprintf(temp_buf, "0 %d 24 24 %d %d-%d", line_index, 24/pw_per_line, 24/pw_per_line*(pw_index%pw_per_line), 24/pw_per_line*(pw_index%pw_per_line)+(24/pw_per_line-1)); /* The line index of this PW and its matching slots. */
         CLI_F_PwConfigureFramed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 384");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 198 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
         /* Rx timing is used */
         /* Note that we send the CR interface ID not the line id*/

         if (clock_rec_pw[pw_index] == 1)
         {
            sprintf(temp_buf, "0 1 1 %d", ct_index); /* ct_index is the Clk Translator interface ID */
            ct_index++;
         }
         else
            sprintf(temp_buf, "0 0 0 0");

         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS),ts_diff_if_id(0-31)] */
#else
         sprintf(temp_buf, "0 0 0 0");
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS),ts_diff_if_id(0-31)] */
#endif

         /**************** PSN --> TDM IW *****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* if clock recovery is set -> Tx timing is used */
         if (clock_rec_pw[pw_index] == 1)
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#else
         /* if clock recovery is disable -> Tx timing is not used */
         CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#endif
         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE

#if WTI_CESOP_RX_TIMING_ENABLE
         /* CR master Rx and Tx direction */
         if (clock_rec_pw[pw_index] == 1)
            CLI_F_PwCreate("0 0 1 1"); /* CR master */
         else
            CLI_F_PwCreate("0 0 0 0"); /* CR slave */
#else
         /* CR master Tx direction */
         if (clock_rec_pw[pw_index] == 1)
            CLI_F_PwCreate("0 0 0 1"); /* CR master */
         else
            CLI_F_PwCreate("0 0 0 0"); /* CR slave */
#endif
         if (clock_rec_pw[pw_index] == 1)
            sprintf(temp_buf, "0 %d 1",pw_index); /* pw is master, all other slaves */
         else
            sprintf(temp_buf, "0 %d 0",pw_index);
         CLI_F_PwEnable(temp_buf);
#else
         /* no timing */
         CLI_F_PwCreate("0 0 0 0"); /* slave mode */
         sprintf(temp_buf, "0 %d 0",pw_index);
         CLI_F_PwEnable(temp_buf);
#endif

      } /* end for (configure each line and pw) */
   }
}
#endif /* (WTI_CESOP_RX_TIMING_ENABLE && WTI_CESOP_CLOCK_RECOVERY_ENABLE) */

/*-----------------------------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------------------------*/
/*----------------------------- End of Clock recovery tests section 5 ---------------------------*/
/*-----------------------------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------*/
/*-----------------------------  Clock recovery tests section 6 ----------------------------------------*/
/* All following Clock Recovery SBI DS3/E3 Over UFE tests can work with RX,TX,BOTH,NON Timing options   */
/*------------------------------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------------------------------*/

/********************************************************************************************
 * Description:
 *
 * TDM2PSN :  The test uses 3xDS3 unfreamed PWs each on different CD.
 *            each CD uses different shaper.
 *            The DS3 clock is recovered by the TEMUX PLLs and used by the clock generators logic
 *            The CG is dividing the clock by 8 before used by the RX TS logic (in DCR).

 *
 * PSN2TDM :  The DCO output is set to DS3/4,the UFE divide the (DS3/4)/(1398) = 8KHz
 *            The 8KHz clock is feed to the jitter attenuator (FX-700) that genarate recovered DS3 clock
 *            The DS3 clock is feed to the temux as recovered clock and also to ufe that divide
 *            the clock by 4 and inject the recovered DS3/4 clock to the TX TS logic
 *
 * The test can run upto 3 lines on 3 SPE (all use same PS and DUS)
 *
 *******************************************************************************************/
void CLI_F_109_SBI_DS3_U_CR_NoCas_Two_Boards_3_CD_1_JAT_3_Line_3_PW(char *StrPrm)
{
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 i, line_index, spe_index, pw_index;
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE)
   WP_U32 j;
   WP_U8 clock_rec_lines[336] = {0};  /* list of master lines in DS3/E3 max 3 lines */
   WP_U8 spe_ja_index[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}; /*sets the jitter attenuator per
                                                                    each SPE. UFE board supports
                                                                    jitter attenuator #0 ONLY!!!*/

   /* verify configuration */
   if((global_active_cr_async_mode<1)||(global_active_cr_async_mode>12))
   {

      printf("ERROR: In this test global_active_cr_async_mode must be 1-12 \n");
      return;
   }

   CLI_F_MapJatToLine(spe_ja_index);
#endif

#if (WTI_CESOP_RX_TIMING_ENABLE || WTI_CESOP_CLOCK_RECOVERY_ENABLE)
   for (i=0; i< global_active_cr_async_mode; i++)
   {
      clock_rec_lines[i*WTI_T1_LINES_PER_SPE] = 1;         /*lines to be CR master*/
   }
#endif

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 3",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* SBI loopback mode [0-NORMAL, 1-LINE LOOPBACK, 2-SYSTEM LOOKPACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE||WTI_CESOP_RX_TIMING_ENABLE)
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */

   /* UFE line configuration */
   for (i=0;i<WTI_NUMBER_OF_SPE_DS3_E3;++i)
   {

      line_index = i*WTI_T1_LINES_PER_SPE;

      /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
      /* Transfer_mode 1-T1_FRM,2-T1_UNFRM,3-E1_FRM,4-E1_UNFRM,5-DS3_FR,6-DS3_UNFR,7-E3_FR,8-E3_UNFR */
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */
#if WTI_CESOP_RX_TIMING_ENABLE

      /* set ufe Tx and Rx direction */
      if (clock_rec_lines[line_index] == 1) /* line uses CR */
         sprintf(temp_buf, "0 %d 6 3",line_index);
      else
         sprintf(temp_buf, "0 %d 6 0",line_index); /* line doesn't use CR  */
#else
      /* set ufe Tx direction only */
      if (clock_rec_lines[line_index] == 1) /* line uses CR */
         sprintf(temp_buf, "0 %d 6 1",line_index);
      else
         sprintf(temp_buf, "0 %d 6 0",line_index); /* line doesn't use CR  */
#endif

#else

#if WTI_CESOP_RX_TIMING_ENABLE
      /* differential mode timing only set ufe  Rx direction */
      if (clock_rec_lines[line_index] == 1)
      {

         sprintf(temp_buf, "0 %d 6 2",line_index);
      }
      else
      {
         sprintf(temp_buf, "0 %d 6 0",line_index);
      }

#else

      /* no timing or adaptive mode */
      sprintf(temp_buf, "0 %d 6 0",line_index);
#endif

#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */

      CLI_F_UfeTransferMode(temp_buf);

      /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
      sprintf(temp_buf, "0 %d 0",line_index);
      CLI_F_UfeCasMode(temp_buf);

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* match between clock tarnslators and lines for the CR lines*/
      /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
      if (clock_rec_lines[line_index] == 1)
      {
         sprintf(temp_buf, "0 %d %d", line_index, spe_ja_index[i]/* translator ID*/);
      }
      else
         /* conect all others to the first line */
      {
         sprintf(temp_buf, "0 %d 0", line_index);
      }

      CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */


#endif /* end of WTI_CESOP_CLOCK_RECOVERY_ENABLE*/
#if WTI_CESOP_RX_TIMING_ENABLE
      /* match between clock shaper and lines for the CR lines   */
      /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */

      if (clock_rec_lines[line_index] == 1)
      {
         sprintf(temp_buf, "0 %d %d", line_index, i);
      }
      else
      {
         /* conect all others to the first line */
         sprintf(temp_buf, "0 %d 0", line_index);
      }

      CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */

#endif
   }

   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 4");

   CLI_F_UfeChipInitLineSetup("");


#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (j=0; j<WTI_NUMBER_OF_SPE_DS3_E3; j++)
   {
      i = j*WTI_T1_LINES_PER_SPE;

      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
#if WTI_CLOCK_REC_MODE
      /*--- Clock Recovery Parameters ---*/
      /* The number of PSN packets between divisor updates */
      the_system->clock_rec[i].divisor_update_period = 1024;
#else
      the_system->clock_rec[i].direct_factor = 31;
      /* Second  filter factor */
      the_system->clock_rec[i].integration_factor = 35;
#endif
   }
#endif

#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   for (pw_index=0;pw_index<WTI_NUMBER_OF_SPE_DS3_E3;++pw_index)
   {
      /* Each DS3/E3 SPE is maped to one PW */
      line_index = pw_index*WTI_T1_LINES_PER_SPE;

      sprintf(temp_buf, "0 %d 48 48", line_index);/* The line index of this PW */
      CLI_F_PwConfigureUnframed(temp_buf);

      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 384");
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 24");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");


      /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
      CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
      CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 198 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* Rx timing is used and differential mode */
      if (pw_index < global_active_cr_async_mode)
         sprintf(temp_buf, "0 1 1 %d",pw_index);
      else
         sprintf(temp_buf, "0 0 1 %d",pw_index);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
      /* Rx timing is not used */
      sprintf(temp_buf, "0 0 1 %d",pw_index);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

      /**************** PSN --> TDM IW *****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* if clock recovery is set -> Tx timing is used */
      if (pw_index < global_active_cr_async_mode)  /* the first PWs use CR, all other don't */
         CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
      else
         CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#else
      /* if clock recovery is disable -> Tx timing is not used */
      CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#endif
      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

      /**************** PSN --> TDM Tx binding*****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE

#if WTI_CESOP_RX_TIMING_ENABLE
      /* CR master Rx and Tx direction */
      if (pw_index < global_active_cr_async_mode)   /* PW 0-.. use CR, all other don't */
         CLI_F_PwCreate("0 0 1 1"); /* CR master */
      else
         CLI_F_PwCreate("0 0 0 0"); /* CR slave */
#else /* Not WTI_CESOP_RX_TIMING_ENABLE */
      /* CR master Tx direction */
      if (pw_index < global_active_cr_async_mode)   /* PW 0-.. CR, all other don't */
         CLI_F_PwCreate("0 0 0 1"); /* CR master */
      else
         CLI_F_PwCreate("0 0 0 0"); /* CR slave */
#endif
      if (pw_index < global_active_cr_async_mode)
         sprintf(temp_buf, "0 %d 1",pw_index); /* pw 0-.. is the master, all other slaves */
      else
         sprintf(temp_buf, "0 %d 0",pw_index);
      CLI_F_PwEnable(temp_buf);
#else /* not  WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
      /* CR master Rx  direction only */
      if (pw_index < global_active_cr_async_mode)   /* PW 0-7 use CR, all other don't */
         CLI_F_PwCreate("0 0 1 0"); /* CR master */
      else
         CLI_F_PwCreate("0 0 0 0"); /* CR slave */
#else
      /* no CR in any directions */
      CLI_F_PwCreate("0 0 0 0"); /* no master */
#endif

#if WTI_CESOP_RX_TIMING_ENABLE
      if (pw_index < global_active_cr_async_mode)
         sprintf(temp_buf, "0 %d 1",pw_index); /* pw 0-7 is the master, all other slaves */
      else
         sprintf(temp_buf, "0 %d 0",pw_index);
#else
      sprintf(temp_buf, "0 %d 0",pw_index);
#endif
      CLI_F_PwEnable(temp_buf);

#endif

   }
}

/********************************************************************************************
 * Description:
 *
 * TDM2PSN :  The test uses 3xDS3 freamed PWs each on different CD.
 *            each CD uses different shaper.
 *            The DS3 clock is recovered by the TEMUX PLLs and used by the clock generators logic
 *            The CG is dividing the clock by 8 before used by the RX TS logic (in DCR).

 *
 * PSN2TDM :  The DCO output is set to DS3/4,the UFE divide the (DS3/4)/(1398) = 8KHz
 *            The 8KHz clock is feed to the jitter attenuator (FX-700) that genarate recovered DS3 clock
 *            The DS3 clock is feed to the temux as recovered clock and also to ufe that divide
 *            the clock by 4 and inject the recovered DS3/4 clock to the TX TS logic
 *
 * The test can run upto 3 lines on 3 SPE (all use same PS and DUS)
 *
 *******************************************************************************************/
void CLI_F_109_SBI_DS3_F_CR_NoCas_Two_Boards_3_CD_1_JAT_3_Line_3_PW(char *StrPrm)
{
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 i, line_index, spe_index, pw_index;
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];

#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE)
   WP_U32 j;
   WP_U8 clock_rec_lines[336] = {0}; /* list of master lines in DS3/E3 max 3 lines */
   WP_U8 spe_ja_index[] = {0,1,2,3,4,5,6,7,8,9,10,11};  /*sets the jitter attenuator per each SPE
                                                          UFE board supports jitter attenuator
                                                          #0 ONLY!!!*/




   /* verify configuration */
   if((global_active_cr_async_mode<1)||(global_active_cr_async_mode>12))
   {

      printf("ERROR: In this test global_active_cr_async_mode must be 1-12 \n");
      return;
   }
   CLI_F_MapJatToLine(spe_ja_index);
#endif

#if (WTI_CESOP_RX_TIMING_ENABLE || WTI_CESOP_CLOCK_RECOVERY_ENABLE)
   for (i=0; i< global_active_cr_async_mode; i++)
   {
      clock_rec_lines[i*WTI_T1_LINES_PER_SPE] = 1;
   }
#endif
   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 3",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE||WTI_CESOP_RX_TIMING_ENABLE)
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */

   /* UFE line configuration */
   for (i=0;i<WTI_NUMBER_OF_SPE_DS3_E3;++i)
   {
      line_index = i*WTI_T1_LINES_PER_SPE;

      /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
      /* Transfer_mode 1-T1_FRM,2-T1_UNFRM,3-E1_FRM,4-E1_UNFRM,5-DS3_FR,6-DS3_UNFR,7-E3_FR,8-E3_UNFR */
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */
#if WTI_CESOP_RX_TIMING_ENABLE

      /* set ufe Tx and Rx direction */
      if (clock_rec_lines[line_index] == 1) /* line uses CR */
         sprintf(temp_buf, "0 %d 5 3",line_index);
      else
         sprintf(temp_buf, "0 %d 5 0",line_index); /* line doesn't use CR  */
#else
      /* set ufe Tx direction only */
      if (clock_rec_lines[line_index] == 1) /* line uses CR */
         sprintf(temp_buf, "0 %d 5 1",line_index);
      else
         sprintf(temp_buf, "0 %d 5 0",line_index); /* line doesn't use CR  */
#endif

#else

#if WTI_CESOP_RX_TIMING_ENABLE
      /* differential mode timing only set ufe  Rx direction */
      if (clock_rec_lines[line_index] == 1)
      {

         sprintf(temp_buf, "0 %d 5 2",line_index);
      }
      else
      {
         sprintf(temp_buf, "0 %d 5 0",line_index);
      }

#else

      /* no timing or adaptive mode */
      sprintf(temp_buf, "0 %d 5 0",line_index);
#endif

#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */

      CLI_F_UfeTransferMode(temp_buf);

      /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
      sprintf(temp_buf, "0 %d 0",line_index);
      CLI_F_UfeCasMode(temp_buf);

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* match between clock tarnslators and lines for the CR lines*/
      /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
      if (clock_rec_lines[line_index] == 1)
      {
         sprintf(temp_buf, "0 %d %d", line_index, spe_ja_index[i]/* translator ID*/);

      }
      else
         /* conect all others to the first line */
      {
         sprintf(temp_buf, "0 %d 0", line_index);
      }

      CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */

#endif /* end of WTI_CESOP_CLOCK_RECOVERY_ENABLE*/
#if WTI_CESOP_RX_TIMING_ENABLE
      /* match between clock shaper and lines for the CR lines   */
      /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */

      if (clock_rec_lines[line_index] == 1)
      {
         sprintf(temp_buf, "0 %d %d", line_index, i);
      }
      else
      {
         /* conect all others to the first line */
         sprintf(temp_buf, "0 %d 0", line_index);
      }

      CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
#endif
   }

   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 5");

   CLI_F_UfeChipInitLineSetup("");


#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (j=0; j<WTI_NUMBER_OF_SPE_DS3_E3; j++)
   {
      i = j*WTI_T1_LINES_PER_SPE;

      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
#if WTI_CLOCK_REC_MODE
      /*--- Clock Recovery Parameters ---*/
      /* The number of PSN packets between divisor updates */
      the_system->clock_rec[i].divisor_update_period = 1024;
#else
      the_system->clock_rec[i].direct_factor = 31;
      /* Second  filter factor */
      the_system->clock_rec[i].integration_factor = 35;
#endif
   }
#endif

#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   for (pw_index=0;pw_index<WTI_NUMBER_OF_SPE_DS3_E3;++pw_index)
   {
      /* Each DS3/E3 SPE is maped to one PW */
      line_index = pw_index*WTI_T1_LINES_PER_SPE;

      /* for DS3 framed, configure as unframed */
      sprintf(temp_buf, "0 %d 48 48", line_index);/* The line index of this PW */
      CLI_F_PwConfigureUnframed(temp_buf);


      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 384");
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 1");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 2");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");


      /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
      CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
      CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 198 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
      /* Rx timing is used and differential mode */
      if (pw_index < global_active_cr_async_mode)
         sprintf(temp_buf, "0 1 1 %d",pw_index);
      else
         sprintf(temp_buf, "0 0 1 %d",pw_index);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
      /* Rx timing is not used */
      sprintf(temp_buf, "0 0 1 %d",pw_index);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

      /**************** PSN --> TDM IW *****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
      /* if clock recovery is set -> Tx timing is used */
      if (pw_index < global_active_cr_async_mode)  /* the first PWs use CR, all other don't */
         CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
      else
         CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#else
      /* if clock recovery is disable -> Tx timing is not used */
      CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#endif
      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

      /**************** PSN --> TDM Tx binding*****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE

#if WTI_CESOP_RX_TIMING_ENABLE
      /* CR master Rx and Tx direction */
      if (pw_index < global_active_cr_async_mode)
         CLI_F_PwCreate("0 0 1 1"); /* CR master */
      else
         CLI_F_PwCreate("0 0 0 0"); /* CR slave */
#else /* Not WTI_CESOP_RX_TIMING_ENABLE */
      /* CR master Tx direction */
      if (pw_index < global_active_cr_async_mode)
         CLI_F_PwCreate("0 0 0 1"); /* CR master */
      else
         CLI_F_PwCreate("0 0 0 0"); /* CR slave */
#endif
      if (pw_index < global_active_cr_async_mode)
         sprintf(temp_buf, "0 %d 1",pw_index);
      else
         sprintf(temp_buf, "0 %d 0",pw_index);
      CLI_F_PwEnable(temp_buf);
#else /* not  WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
      /* CR master Rx  direction only */
      if (pw_index < global_active_cr_async_mode)
         CLI_F_PwCreate("0 0 1 0"); /* CR master */
      else
         CLI_F_PwCreate("0 0 0 0"); /* CR slave */
#else
      /* no CR in any directions */
      CLI_F_PwCreate("0 0 0 0"); /* no master */
#endif

#if WTI_CESOP_RX_TIMING_ENABLE
      if (pw_index < global_active_cr_async_mode)
         sprintf(temp_buf, "0 %d 1",pw_index);
      else
         sprintf(temp_buf, "0 %d 0",pw_index);
#else
      sprintf(temp_buf, "0 %d 0",pw_index);
#endif
      CLI_F_PwEnable(temp_buf);

#endif

   }
}

/*-----------------------------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------------------------*/
/*----------------------------- End of Clock recovery tests section 6 ---------------------------*/
/*-----------------------------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------*/
/*-----------------------------  Clock recovery tests section 7 -------------------------------------*/
/* All following Clock Recovery SBI E1/T1 Over UFE tests can work with RX,TX,BOTH,NON Timing options */
/*---------------------------------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------------------------------*/
/********************************************************************************************
 * Description:
 *            N = "global_active_cr_async_mode"
 * TDM2PSN :  The test uses N CD for the first N PWs (in this case PW = line)
 *            each CD uses different shaper. All pws > N are using the first shaper.
 * PSN2TDM :  The first  lines -  0...N-1 are conected to CT#0..N-1
 *            Line N...63 are conected to CT#0
 *
 * The test can run upto 63 lines (all use same PS and DUS)
 *
 *******************************************************************************************/
void CLI_F_112_SBI_E1_F_30DS0_CR_Cas_Two_Boards_N_CD_N_CT_max_Lines_max_PW(char *StrPrm)
{
   WP_U32 i, j, line_index, spe_index, timing_index, pw_index;
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U8   clock_rec_lines[336] = {0}; /* list of master lines */

   /* Set the CR lines (both for RX and TX direction */
#if (WTI_CESOP_RX_TIMING_ENABLE || WTI_CESOP_CLOCK_RECOVERY_ENABLE)
   for (i=0; i< global_active_cr_async_mode; i++)
   {/* Set lines to be CR master */
      if (i < 21) /* first SPE */
         clock_rec_lines[i] = 1;
      else
         clock_rec_lines[i+7] = 1;
   }
#endif

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }


   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE||WTI_CESOP_RX_TIMING_ENABLE)
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE || WTI_CESOP_RX_TIMING_ENABLE */

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         timing_index = i*WTI_E1_LINES_PER_SPE + j;

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 3 3",line_index);
#else
            /* set ufe Tx direction only */
            sprintf(temp_buf, "0 %d 3 1",line_index);
#endif

#else /* Not WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Rx direction only */
            sprintf(temp_buf, "0 %d 3 2",line_index);
#endif

#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */
         }
         else
         {
#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Rx direction only - for all lines */
            sprintf(temp_buf, "0 %d 3 2",line_index);
#else
            sprintf(temp_buf, "0 %d 3 0",line_index); /* line doesn't use CR on any direction */
#endif
         }
         CLI_F_UfeTransferMode(temp_buf);

         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 1",line_index);
         CLI_F_UfeCasMode(temp_buf);

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, timing_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */
#endif /* end of WTI_CESOP_CLOCK_RECOVERY_ENABLE*/
#if WTI_CESOP_RX_TIMING_ENABLE
         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, timing_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
#endif

      }
   }


   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 9");

   CLI_F_UfeChipInitLineSetup("");

   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }
#endif
   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_E1_LINES_PER_SPE + j;

         sprintf(temp_buf, "0 %d 30 30 30 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31", line_index);/* The line index of this PW */
         CLI_F_PwConfigureFramed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 240");/* 240=16*30/2 */
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 0 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
         /* Rx timing is used in differential mode */
         /* first global_active_cr_async_mode related to different CDs */
         if (pw_index < global_active_cr_async_mode)
         {
            sprintf(temp_buf, "0 1 1 %d",pw_index);
         }
         else
         {
            /* In differential mode all other pw (not first ones) uses CD#0 */
            sprintf(temp_buf, "0 1 1 0");
         }

         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
         /* Rx timing is not used */
         sprintf(temp_buf, "0 0 1 %d",pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

         /**************** PSN --> TDM IW *****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* if clock recovery is set -> Tx timing is used */
         if (pw_index < global_active_cr_async_mode)  /* PW 0-7 use CR, all other don't */
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#else
         /* if clock recovery is disable -> Tx timing is not used */
         CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#endif
         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/
         /* ------------------------------- Create and Enable all PWs  --------------------------------------- */
         /* The First global_active_cr_async_mode PWs use CR, all other don't */

         if (pw_index < global_active_cr_async_mode)
         {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE

#if WTI_CESOP_RX_TIMING_ENABLE
            /* CR master Rx and Tx direction */
            CLI_F_PwCreate("0 0 1 1"); /* CR master */
#else
            /* CR master Tx direction */
            CLI_F_PwCreate("0 0 0 1"); /* CR master */
#endif

#else /* not  WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
            /* CR master Rx  direction only */
            CLI_F_PwCreate("0 0 1 0"); /* CR master */
#endif
#endif
            sprintf(temp_buf, "0 %d 1",pw_index);
         }
         else
         {  /* Not TX CR PW */
#if WTI_CESOP_RX_TIMING_ENABLE
            /* Set all PW IN rx to work in shapping mode */
            CLI_F_PwCreate("0 0 1 0"); /* CR master */
#else
            CLI_F_PwCreate("0 0 0 0");
#endif

            sprintf(temp_buf, "0 %d 0",pw_index);
         }
         CLI_F_PwEnable(temp_buf);
      } /* end for (configure each line) */
   }
}
/********************************************************************************************
 * Description:
 *            N = "global_active_cr_async_mode"
 * TDM2PSN :  The test uses N CD for the first N PWs (in this case PW = line)
 *            each CD uses different shaper. All pws > N are using the first shaper.
 * PSN2TDM :  The first  lines -  0...N-1 are conected to CT#0..N-1
 *            Line N...84 are conected to CT#0
 *
 * The test can run upto 84 lines (all use same PS and DUS)
 *
 *******************************************************************************************/
void CLI_F_112_SBI_T1_F_24DS0_CR_Cas_Two_Boards_N_CD_N_CT_max_Lines_max_PW(char *StrPrm)
{
   WP_U32 i, j, line_index, spe_index, pw_index;
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U8   clock_rec_lines[336] = {0}; /* list of master lines */

   /* Set the CR lines (both for RX and TX direction */
#if (WTI_CESOP_RX_TIMING_ENABLE || WTI_CESOP_CLOCK_RECOVERY_ENABLE)
   for (i=0; i< global_active_cr_async_mode; i++)
   {
      clock_rec_lines[i] = 1;         /* Set lines to be CR master */
   }
#endif

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }


   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE||WTI_CESOP_RX_TIMING_ENABLE)
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE || WTI_CESOP_RX_TIMING_ENABLE */

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 1 3",line_index);
#else
            /* set ufe Tx direction only */
            sprintf(temp_buf, "0 %d 1 1",line_index);
#endif

#else /* Not WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Rx direction only */
            sprintf(temp_buf, "0 %d 1 2",line_index);
#endif

#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */
         }
         else
         {
#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Rx direction only - for all lines */
            sprintf(temp_buf, "0 %d 1 2",line_index);
#else
            sprintf(temp_buf, "0 %d 1 0",line_index); /* line doesn't use CR on any direction */
#endif
         }

         CLI_F_UfeTransferMode(temp_buf);

         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 1",line_index);
         CLI_F_UfeCasMode(temp_buf);

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, line_index);
         }
         else
            /* conect all others to the first line */
         {
            if (line_index < 168)
               sprintf(temp_buf, "0 %d 0", line_index);
            else
               sprintf(temp_buf, "0 %d 1", line_index);
         }

         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */
#endif /* end of WTI_CESOP_CLOCK_RECOVERY_ENABLE*/
#if WTI_CESOP_RX_TIMING_ENABLE
         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, line_index);
         }
         else
            /* conect all others to the first line */
         {
            if (line_index < 168)
               sprintf(temp_buf, "0 %d 0", line_index);
            else
               sprintf(temp_buf, "0 %d 1", line_index);
         }

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
#endif

      }
   }


   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 8");

   CLI_F_UfeChipInitLineSetup("");
   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }
#endif

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */


#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_T1_LINES_PER_SPE + j;

         sprintf(temp_buf, "0 %d 48 48 24 0-23", line_index);/* The line index of this PW */
         CLI_F_PwConfigureFramed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 576");/* 576=48*24/2 */
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 0 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
         /* Rx timing is used in differential mode */
         /* first global_active_cr_async_mode related to different CDs */
         if (pw_index < global_active_cr_async_mode)
         {
            sprintf(temp_buf, "0 1 1 %d",pw_index);
         }
         else
         {
            /* In differential mode all other pw (not first ones) uses CD#0 */
            sprintf(temp_buf, "0 1 1 0");
         }

         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
         /* Rx timing is not used */
         sprintf(temp_buf, "0 0 1 %d",pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

         /**************** PSN --> TDM IW *****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* if clock recovery is set -> Tx timing is used */
         if (pw_index < global_active_cr_async_mode)  /* PW 0-7 use CR, all other don't */
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#else
         /* if clock recovery is disable -> Tx timing is not used */
         CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#endif
         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/

         /* The First global_active_cr_async_mode PWs use CR, all other don't */

         if (pw_index < global_active_cr_async_mode)
         {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE

#if WTI_CESOP_RX_TIMING_ENABLE
            /* CR master Rx and Tx direction */
            CLI_F_PwCreate("0 0 1 1"); /* CR master */
#else
            /* CR master Tx direction */
            CLI_F_PwCreate("0 0 0 1"); /* CR master */
#endif

#else /* not  WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
            /* CR master Rx  direction only */
            CLI_F_PwCreate("0 0 1 0"); /* CR master */
#endif
#endif
            sprintf(temp_buf, "0 %d 1",pw_index);
         }
         else
         {  /* Not TX CR PW */
#if WTI_CESOP_RX_TIMING_ENABLE
            /* Set all PW IN rx to work in shapping mode */
            CLI_F_PwCreate("0 0 1 0"); /* CR master */
#else
            CLI_F_PwCreate("0 0 0 0");
#endif

            sprintf(temp_buf, "0 %d 0",pw_index);
         }
         CLI_F_PwEnable(temp_buf);

      } /* end for (configure each line) */
   }
}

#if WTI_CESOP_TO_MPLS_FA_CASCADING
void CLI_F_103_SBI_E1_U_CR_NoCas_Mpls_Cascading(char *StrPrm)
{
   WP_U32 i, j, line_index, spe_index, timing_index, pw_index;
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];

   WP_U8   clock_rec_lines[336] = {0}; /* list of master lines */



   /* Set the CR lines (both for RX and TX direction */
#if (WTI_CESOP_RX_TIMING_ENABLE || WTI_CESOP_CLOCK_RECOVERY_ENABLE)
   for (i=0; i< global_active_cr_async_mode; i++)
   {/* Set lines to be CR master */
      clock_rec_lines[CLI_F_AttacheLineToPwNumber(i)] = 1;
   }
#endif

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential)*/
#if (WTI_CESOP_CLOCK_RECOVERY_ENABLE||WTI_CESOP_RX_TIMING_ENABLE)
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */
#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE || WTI_CESOP_RX_TIMING_ENABLE */

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)

      {
         line_index = i*28 + j;
         timing_index = i*WTI_E1_LINES_PER_SPE + j;

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 4 3",line_index);
#else
            /* set ufe Tx direction only */
            sprintf(temp_buf, "0 %d 4 1",line_index);
#endif

#else /* Not WTI_CESOP_CLOCK_RECOVERY_ENABLE */

#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Rx direction only */
            sprintf(temp_buf, "0 %d 4 2",line_index);
#endif

#endif /* WTI_CESOP_CLOCK_RECOVERY_ENABLE */
         }
         else
         {
#if WTI_CESOP_RX_TIMING_ENABLE
            /* set ufe Rx direction only - for all lines */
            sprintf(temp_buf, "0 %d 4 2",line_index);
#else
            sprintf(temp_buf, "0 %d 4 0",line_index); /* line doesn't use CR on any direction */
#endif
         }

         CLI_F_UfeTransferMode(temp_buf);

         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, timing_index);
         }
         else
            /* conect all others to the first line */
         {
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */
#endif /* end of WTI_CESOP_CLOCK_RECOVERY_ENABLE*/
#if WTI_CESOP_RX_TIMING_ENABLE
         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, timing_index);
         }
         else
         {
            /* conect all others to the first line */
            sprintf(temp_buf, "0 %d 0", line_index);
         }

         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */

#endif
      }
   }
   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 2");

   CLI_F_UfeChipInitLineSetup("");
   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }
#endif

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   /* ------------------- Creating the MPLS L2 router flow aggregations in both directions */
   for (i=0;i<WTI_MAX_NUM_OF_MPLS_FA;++i)
   {
#if WTI_CESOP_MPLS_OVER_ENET
      /* create the l2 router MPLS flow aggregations */
      CLI_F_Tdm2PsnFlowAggEnetHeaderMpls("0 aa aa aa aa aa aa bb bb bb bb bb bb 8847");
      CLI_F_MplsFlowAggPrefixLength("0 14");
      sprintf(temp_buf,
              "0 %x %x %x %x %x %x",
              3*i,
              3*i+1,
              3*i+2,
              (0x88470000 | ((((WTI_MPLS_LABEL) >> 12) + WTI_MAX_PW + 1 + i) >> 4)),
              ((((((WTI_MPLS_LABEL) >> 12)  + WTI_MAX_PW + 1 + i) & 0xff) << 28) | 0x00ff0000),
              0);
      /*                              [mac destination] [mac source] [vlan] [type] [mpls header] */
      CLI_F_MplsFlowAggPrefixHeaderMpls(temp_buf);

      mpls_layer2_agg_cfg.txfunc = the_system->tx_enet_channel;

      sprintf(temp_buf, "0 %d", 0); /* remark offsets for VLAN priority and PSN tunnel EXP bits */

      CLI_F_MplsFlowAggRemarkingOffsets(temp_buf);
      sprintf(temp_buf, "0 %d", i);
      CLI_F_MplsFlowAggCreate(temp_buf);
#else
#if WTI_CESOP_NATIVE_MPLS_IW
      /* create the l2 router MPLS flow aggregations */
      CLI_F_MplsFlowAggPrefixLength("0 0");
      sprintf(temp_buf,
              "0 %x",
              (((((WTI_MPLS_LABEL) >> 12) + WTI_MAX_PW + 1 + i) << 12) | 0xff));
      /*                              [mpls header] */
      CLI_F_MplsFlowAggPrefixHeaderMpls(temp_buf);
      sprintf(temp_buf, "0 %d %d", 1, 5); /* remark offsets for PSN tunnel EXP bits */

      CLI_F_MplsFlowAggRemarkingOffsets(temp_buf);
      sprintf(temp_buf, "0 %d", i);
      CLI_F_MplsFlowAggCreate(temp_buf);
#else
      /* create the l2 router MPLS flow aggregations */
      CLI_F_MplsFlowAggPrefixLength("0 4");
      sprintf(temp_buf,
              "0 %x %x",
              WTI_MPLSoPPP,
              (((((WTI_MPLS_LABEL) >> 12) + WTI_MAX_PW + 1 + i) << 12) | 0xff));
      /*                              [ppp] [mpls header] */
      CLI_F_MplsFlowAggPrefixHeaderMpls(temp_buf);
      sprintf(temp_buf, "0 %d %d", 1, 13); /* remark offsets for PSN tunnel EXP bits */

      CLI_F_MplsFlowAggRemarkingOffsets(temp_buf);
      sprintf(temp_buf, "0 %d", i);
      CLI_F_MplsFlowAggCreate(temp_buf);
#endif /* WTI_CESOP_NATIVE_MPLS_IW */
#endif /* WTI_CESOP_MPLS_OVER_ENET */
   }



   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_E1_LINES_PER_SPE + j;

         sprintf(temp_buf, "0 %d 32 32", line_index);/* The line index of this PW */
         CLI_F_PwConfigureUnframed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 256");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

#if WTI_CESOP_RX_TIMING_ENABLE & WTI_CLOCK_REC_MODE
         /* Rx timing is used in differential mode */
         /* first global_active_cr_async_mode related to different CDs */
         if (pw_index < global_active_cr_async_mode)
         {
            sprintf(temp_buf, "0 1 1 %d",pw_index);
         }
         else
         {
            /* In differential mode all other pw (not first ones) uses CD#0 */
            sprintf(temp_buf, "0 1 1 0");
         }

         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#else
         /* Rx timing is not used */
         sprintf(temp_buf, "0 0 1 %d",pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);/* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */
#endif

         /**************** PSN --> TDM IW *****************/
#if WTI_CESOP_CLOCK_RECOVERY_ENABLE
         /* if clock recovery is set -> Tx timing is used */
         if (pw_index < global_active_cr_async_mode)  /* PW 0-7 use CR, all other don't */
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#else
         /* if clock recovery is disable -> Tx timing is not used */
         CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
#endif
         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/

         /* The First global_active_cr_async_mode PWs use CR, all other don't */

         if (pw_index < global_active_cr_async_mode)
         {
            /* CR master Rx and Tx direction */
            sprintf(temp_buf, "0 %d %d %d %d %d", 0,1,1,0,pw_index);
            CLI_F_PwCreateCascaded(temp_buf);

            sprintf(temp_buf, "0 %d 1",pw_index);
         }
         else
         {  /* Not TX CR PW */
            /* Set all PW IN rx to work in shapping mode */
            sprintf(temp_buf, "0 %d %d %d %d %d", 0,1,0,0,pw_index);
            CLI_F_PwCreateCascaded(temp_buf);

            sprintf(temp_buf, "0 %d 0",pw_index);
         }
         CLI_F_PwEnable(temp_buf);

      } /* end for (configure each line) */
   }


}
#endif

/*-----------------------------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------------------------*/
/*----------------------------- End of Clock recovery tests section 7 ---------------------------*/
/*-----------------------------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------------------------*/




#if WTI_CESOP_CLOCK_RECOVERY_ENABLE && WTI_CESOP_RX_TIMING_ENABLE && WTI_EXT_DIFF_MODE_ACTIVE
/*---------------------------------------------------------------------------------------------------*/
/*-----------------------------  Clock recovery tests section 8 -------------------------------------*/
/* All following Clock Recovery SBI E1/T1 Over UFE tests can work with RX,TX,BOTH Timing options     */
/* All tests are for extended differential mode (336CD) and combined CR tests (336 ext.diff.+32 reg  */
/* In order to active those tests, one must enable: CR, RX_TIMING, CLOCK_REC_MODE(diff) and EXT_DIFF */
/*---------------------------------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------------------------------*/
/*****************************************************************************************************/

/********************************************************************************************
 * Description:
 *            This test generates full OC12 lines and PWs and check the Extended Differential
 *            mode, where N = "global_active_cr_extdiff_mode"
 * TDM2PSN :  The test uses N CD for the first N PWs (in this case PW = line)
 *            each CD connected to different line.
 * PSN2TDM :  Each line is connected to different CT.
 *
 * The test can run upto 252 lines (all use same PS and DUS)
 *
 *******************************************************************************************/
void CLI_F_130_SBI_E1_U_CR_EXTENDED_DIFF_NoCas_Two_Boards_252CD_252Lines_252Pw (char *StrPrm)
{ /* test case 3.3.2.1, 3.3.2.9 */
   WP_U32 i, j, line_index, spe_index, timing_index, pw_index;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 cr_number_offset = WTI_CESOP_MAX_CLOCK_REC_INTERFACES; /* first CD in ext_diff mode */
   int num_of_active_ext_diff_cd =
      ((global_active_cr_extdiff_mode <= 252) ? global_active_cr_extdiff_mode : 252);
   WP_U8  clock_rec_lines[336] = {0}; /* list of master lines */
   WP_U32 res, cmd, du_size, ps;


   /* Set the CR lines (both for RX and TX direction */
   for (i=0; i<num_of_active_ext_diff_cd; i++)
   {
      clock_rec_lines[CLI_F_AttacheLineToPwNumber(i)] = 1;
   }

   /* when available, read parameters from user */
   res = sscanf(StrPrm, "%d %d %d", &cmd, &du_size, &ps);
   if (res == 1)
   {
      du_size = 64; /* use default setup */
      ps = 256;
   }
   else if (res == 2)
      ps = 256; /* use default setup */
   else if (res > 3)
   {
      WTI_TerminatePrintError("Invalid number of parameters", __LINE__);
      return;
   }
   printf("Test run with DU size %d, Packet Size %d\n", du_size, ps);

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
      CLI_F_UfeClockMode("0 0");
   else
      CLI_F_UfeClockMode("0 1");

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential) for regular mode */
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)

      {
         line_index = i*28 + j;
         timing_index = i*WTI_E1_LINES_PER_SPE + j;

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 4 3",line_index);
            CLI_F_UfeTransferMode(temp_buf);
         }
         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+timing_index);
            CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */
         }

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+timing_index);
            CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
         }
      }
   }

   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();

   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/
   CLI_F_UfeTemuxSetup("0 2");

   CLI_F_UfeChipInitLineSetup("");

   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_E1_LINES_PER_SPE + j;

         /* By default, the DU size is 64 unless test gets different parameters */
         sprintf(temp_buf, "0 %d %d %d", line_index, du_size, du_size);/* The line index of this PW */
         CLI_F_PwConfigureUnframed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         /* By default, the PS in 256, unless test gets different parameters */
         sprintf(temp_buf, "0 %d", ps);
         CLI_F_Pwe3ChannelRxBufferSize(temp_buf);
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 0 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

         /* Rx timing is used in differential mode */
         sprintf(temp_buf, "0 1 1 %d",cr_number_offset+pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */

         /**************** PSN --> TDM IW *****************/
         /* if clock recovery is set -> Tx timing is used */
         CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/
         CLI_F_PwCreate("0 0 1 1"); /* CR master */

         sprintf(temp_buf, "0 %d 1",pw_index);
         CLI_F_PwEnable(temp_buf);
      } /* end for (configure each line) */
   }
}

/********************************************************************************************
 * Description:
 *            This test generates full OC12 lines and PWs and check the Extended Differential
 *            mode, where N = "global_active_cr_extdiff_mode"
 * TDM2PSN :  The test uses N CD for the first N PWs (in this case PW = line)
 *            each CD connected to different line.
 * PSN2TDM :  Each line is connected to different CT.
 *
 * The test can run upto 336 lines (all use same PS and DUS)
 *
 *******************************************************************************************/
void CLI_F_130_SBI_T1_U_CR_EXTENDED_DIFF_NoCas_Two_Boards_336CD_336Lines_336Pw (char *StrPrm)
{ /* test case 3.3.2.2 */
   WP_U32 i, j, line_index, spe_index, pw_index;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 cr_number_offset = WTI_CESOP_MAX_CLOCK_REC_INTERFACES; /* first CD in ext_diff mode */
   int num_of_active_ext_diff_cd = global_active_cr_extdiff_mode;
   WP_U8  clock_rec_lines[336] = {0}; /* list of master lines */
   WP_U32 res, cmd, du_size, ps;


   /* Set the CR lines (both for RX and TX direction */
   for (i=0; i<num_of_active_ext_diff_cd; i++)
   {
      clock_rec_lines[i] = 1;
   }

   /* when available, read parameters from user */
   res = sscanf(StrPrm, "%d %d %d", &cmd, &du_size, &ps);
   if (res == 1)
   {
      du_size = 48; /* use default setup */
      ps = 384;
   }
   else if (res == 2)
      ps = 384; /* use default setup */
   else if (res > 3)
   {
      WTI_TerminatePrintError("Invalid number of parameters", __LINE__);
      return;
   }
   printf("Test run with DU size %d, Packet Size %d\n", du_size, ps);

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
      CLI_F_UfeClockMode("0 0");
   else
      CLI_F_UfeClockMode("0 1");

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential) for regular mode */
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)

      {
         line_index = i*28 + j;

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 2 3",line_index);
            CLI_F_UfeTransferMode(temp_buf);
         }
         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+line_index);
            CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */
         }

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+line_index);
            CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
         }
      }
   }

   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();

   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/
   CLI_F_UfeTemuxSetup("0 0");

   CLI_F_UfeChipInitLineSetup("");

   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_T1_LINES_PER_SPE + j;

         /* By default, the DU size is 48 unless test gets different parameters */
         sprintf(temp_buf, "0 %d %d %d", line_index, du_size, du_size);/* The line index of this PW */
         CLI_F_PwConfigureUnframed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         /* By default, the PS in 256, unless test gets different parameters */
         sprintf(temp_buf, "0 %d", ps);
         CLI_F_Pwe3ChannelRxBufferSize(temp_buf);
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 0 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

         /* Rx timing is used in differential mode */
         sprintf(temp_buf, "0 1 1 %d",cr_number_offset+pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */

         /**************** PSN --> TDM IW *****************/
         /* if clock recovery is set -> Tx timing is used */
         CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/
         CLI_F_PwCreate("0 0 1 1"); /* CR master */

         sprintf(temp_buf, "0 %d 1",pw_index);
         CLI_F_PwEnable(temp_buf);
      } /* end for (configure each line) */
   }
}

void CLI_F_130_SBI_E1_F_CR_EXTENDED_DIFF_NoCas_Two_Boards_252CD_252Lines_252Pw (char *StrPrm)
{ /* test case 3.3.2.3 */
   WP_U32 i, j, line_index, spe_index, timing_index, pw_index;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 cr_number_offset = WTI_CESOP_MAX_CLOCK_REC_INTERFACES; /* first CD in ext_diff mode */
   int num_of_active_ext_diff_cd =
      ((global_active_cr_extdiff_mode <= 252) ? global_active_cr_extdiff_mode : 252);
   WP_U8  clock_rec_lines[336] = {0}; /* list of master lines */
   WP_U32 res, cmd, du_size, ps;


   /* Set the CR lines (both for RX and TX direction */
   for (i=0; i<num_of_active_ext_diff_cd; i++)
   {
      clock_rec_lines[CLI_F_AttacheLineToPwNumber(i)] = 1;
   }

   /* when available, read parameters from user */
   res = sscanf(StrPrm, "%d %d %d", &cmd, &du_size, &ps);
   if (res == 1)
   {
      du_size = 64; /* use default setup */
      ps = 256;
   }
   else if (res == 2)
      ps = 256; /* use default setup */
   else if (res > 3)
   {
      WTI_TerminatePrintError("Invalid number of parameters", __LINE__);
      return;
   }
   printf("Test run with DU size %d, Packet Size %d\n", du_size, ps);

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
      CLI_F_UfeClockMode("0 0");
   else
      CLI_F_UfeClockMode("0 1");

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential) for regular mode */
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)

      {
         line_index = i*28 + j;
         timing_index = i*WTI_E1_LINES_PER_SPE + j;

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 3 3",line_index);
            CLI_F_UfeTransferMode(temp_buf);
         }
         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+timing_index);
            CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */
         }

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+timing_index);
            CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
         }
      }
   }

   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();

   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/
   CLI_F_UfeTemuxSetup("0 3");

   CLI_F_UfeChipInitLineSetup("");

   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_E1_LINES_PER_SPE + j;

         /* By default, the DU size is 64 unless test gets different parameters */
         sprintf(temp_buf, "0 %d %d %d 32 0-31", line_index, du_size, du_size);/* The line index of this PW */
         CLI_F_PwConfigureFramed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         /* By default, the PS in 256, unless test gets different parameters */
         sprintf(temp_buf, "0 %d", ps);
         CLI_F_Pwe3ChannelRxBufferSize(temp_buf);
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 0 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

         /* Rx timing is used in differential mode */
         sprintf(temp_buf, "0 1 1 %d",cr_number_offset+pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */

         /**************** PSN --> TDM IW *****************/
         /* if clock recovery is set -> Tx timing is used */
         CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/
         CLI_F_PwCreate("0 0 1 1"); /* CR master */

         sprintf(temp_buf, "0 %d 1",pw_index);
         CLI_F_PwEnable(temp_buf);
      } /* end for (configure each line) */
   }
}

void CLI_F_130_SBI_T1_F_CR_EXTENDED_DIFF_NoCas_Two_Boards_336CD_336Lines_336Pw (char *StrPrm)
{
   /* test case 3.3.2.4 */
   WP_U32 i, j, line_index, spe_index, pw_index;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 cr_number_offset = WTI_CESOP_MAX_CLOCK_REC_INTERFACES; /* first CD in ext_diff mode */
   int num_of_active_ext_diff_cd = global_active_cr_extdiff_mode;
   WP_U8  clock_rec_lines[336] = {0}; /* list of master lines */
   WP_U32 res, cmd, du_size, ps;


   /* Set the CR lines (both for RX and TX direction */
   for (i=0; i<num_of_active_ext_diff_cd; i++)
   {
      clock_rec_lines[i] = 1;
   }

   /* when available, read parameters from user */
   res = sscanf(StrPrm, "%d %d %d", &cmd, &du_size, &ps);
   if (res == 1)
   {
      du_size = 48; /* use default setup */
      ps = 384;
   }
   else if (res == 2)
      ps = 384; /* use default setup */
   else if (res > 3)
   {
      WTI_TerminatePrintError("Invalid number of parameters", __LINE__);
      return;
   }
   printf("Test run with DU size %d, Packet Size %d\n", du_size, ps);

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
      CLI_F_UfeClockMode("0 0");
   else
      CLI_F_UfeClockMode("0 1");

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential) for regular mode */
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)

      {
         line_index = i*28 + j;

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 1 3",line_index);
            CLI_F_UfeTransferMode(temp_buf);
         }
         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+line_index);
            CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */
         }

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+line_index);
            CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
         }
      }
   }

   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();

   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/
   CLI_F_UfeTemuxSetup("0 1");

   CLI_F_UfeChipInitLineSetup("");

   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_T1_LINES_PER_SPE + j;

         /* By default, the DU size is 48 unless test gets different parameters */
         sprintf(temp_buf, "0 %d %d %d 24 0-23", line_index, du_size, du_size);/* The line index of this PW */
         CLI_F_PwConfigureFramed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         /* By default, the PS in 256, unless test gets different parameters */
         sprintf(temp_buf, "0 %d", ps);
         CLI_F_Pwe3ChannelRxBufferSize(temp_buf);
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 0 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

         /* Rx timing is used in differential mode */
         sprintf(temp_buf, "0 1 1 %d",cr_number_offset+pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */

         /**************** PSN --> TDM IW *****************/
         /* if clock recovery is set -> Tx timing is used */
         CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/
         CLI_F_PwCreate("0 0 1 1"); /* CR master */

         sprintf(temp_buf, "0 %d 1",pw_index);
         CLI_F_PwEnable(temp_buf);
      } /* end for (configure each line) */
   }
}

void CLI_F_130_SBI_E1_F_1DS0_CR_EXTENDED_DIFF_NoCas_Two_Boards_252CD_252Lines_252Pw (char *StrPrm)
{ /* test case 3.3.2.3 */
   /* This test should run in intensive mode: 1 slot per frame, max DU size (64) and max packet size (672) */
   WP_U32 i, j, line_index, spe_index, timing_index, pw_index;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 cr_number_offset = WTI_CESOP_MAX_CLOCK_REC_INTERFACES; /* first CD in ext_diff mode */
   int num_of_active_ext_diff_cd =
      ((global_active_cr_extdiff_mode <= 252) ? global_active_cr_extdiff_mode : 252);
   WP_U8  clock_rec_lines[336] = {0}; /* list of master lines */
   WP_U32 res, cmd, du_size, ps;


   /* Set the CR lines (both for RX and TX direction */
   for (i=0; i<num_of_active_ext_diff_cd; i++)
   {
      clock_rec_lines[CLI_F_AttacheLineToPwNumber(i)] = 1;
   }

   /* when available, read parameters from user */
   res = sscanf(StrPrm, "%d %d %d", &cmd, &du_size, &ps);
   if (res == 1)
   {
      du_size = 64; /* use default setup */
      ps = 448;
   }
   else if (res == 2)
      ps = 448; /* use default setup */
   else if (res > 3)
   {
      WTI_TerminatePrintError("Invalid number of parameters", __LINE__);
      return;
   }
   printf("Test run with DU size %d, Packet Size %d\n", du_size, ps);

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
      CLI_F_UfeClockMode("0 0");
   else
      CLI_F_UfeClockMode("0 1");

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential) for regular mode */
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)

      {
         line_index = i*28 + j;
         timing_index = i*WTI_E1_LINES_PER_SPE + j;

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 3 3",line_index);
            CLI_F_UfeTransferMode(temp_buf);
         }
         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+timing_index);
            CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */
         }

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+timing_index);
            CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
         }
      }
   }

   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();

   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/
   CLI_F_UfeTemuxSetup("0 3");

   CLI_F_UfeChipInitLineSetup("");

   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      /* due to the big number of frames in packet (and the packet size itself) set the update period to the minimum. */
      the_system->clock_rec[i].divisor_update_period = 1;
   }

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_E1_LINES_PER_SPE + j;

         /* By default, the DU size is 64 unless test gets different parameters */
         sprintf(temp_buf, "0 %d %d %d 1 31", line_index, du_size, du_size);/* The line index of this PW */
         CLI_F_PwConfigureFramed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         /* By default, the PS in 256, unless test gets different parameters */
         sprintf(temp_buf, "0 %d", ps);
         CLI_F_Pwe3ChannelRxBufferSize(temp_buf);
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 0 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

         /* Rx timing is used in differential mode */
         sprintf(temp_buf, "0 1 1 %d",cr_number_offset+pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */

         /**************** PSN --> TDM IW *****************/
         /* if clock recovery is set -> Tx timing is used */
         CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/
         CLI_F_PwCreate("0 0 1 1"); /* CR master */

         sprintf(temp_buf, "0 %d 1",pw_index);
         CLI_F_PwEnable(temp_buf);
      } /* end for (configure each line) */
   }
}
void CLI_F_130_SBI_T1_F_1DS0_CR_EXTENDED_DIFF_NoCas_Two_Boards_336CD_336Lines_336Pw (char *StrPrm)
{
   /* test case 3.3.2.4 */
   /* This test should run in intensive mode: 1 slot per frame, max DU size (48) and max packet size (576) */
   WP_U32 i, j, line_index, spe_index, pw_index;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 cr_number_offset = WTI_CESOP_MAX_CLOCK_REC_INTERFACES; /* first CD in ext_diff mode */
   int num_of_active_ext_diff_cd = global_active_cr_extdiff_mode;
   WP_U8  clock_rec_lines[336] = {0}; /* list of master lines */
   WP_U32 res, cmd, du_size, ps;


   /* Set the CR lines (both for RX and TX direction */
   for (i=0; i<num_of_active_ext_diff_cd; i++)
   {
      clock_rec_lines[i] = 1;
   }

   /* when available, read parameters from user */
   res = sscanf(StrPrm, "%d %d %d", &cmd, &du_size, &ps);
   if (res == 1)
   {
      du_size = 48; /* use default setup */
      ps = 432;
   }
   else if (res == 2)
      ps = 432; /* use default setup */
   else if (res > 3)
   {
      WTI_TerminatePrintError("Invalid number of parameters", __LINE__);
      return;
   }
   printf("Test run with DU size %d, Packet Size %d\n", du_size, ps);

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
      CLI_F_UfeClockMode("0 0");
   else
      CLI_F_UfeClockMode("0 1");

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential) for regular mode */
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)

      {
         line_index = i*28 + j;

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 1 3",line_index);
            CLI_F_UfeTransferMode(temp_buf);
         }
         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+line_index);
            CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */
         }

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+line_index);
            CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
         }
      }
   }

   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();

   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/
   CLI_F_UfeTemuxSetup("0 1");

   CLI_F_UfeChipInitLineSetup("");

   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      /* due to the big number of frames in packet (and the packet size itself) set the update period to the minimum. */
      the_system->clock_rec[i].divisor_update_period = 1;
   }

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_T1_LINES_PER_SPE + j;

         /* By default, the DU size is 48 unless test gets different parameters */
         sprintf(temp_buf, "0 %d %d %d 1 2", line_index, du_size, du_size);/* The line index of this PW */
         CLI_F_PwConfigureFramed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         /* By default, the PS in 256, unless test gets different parameters */
         sprintf(temp_buf, "0 %d", ps);
         CLI_F_Pwe3ChannelRxBufferSize(temp_buf);
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 0 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

         /* Rx timing is used in differential mode */
         sprintf(temp_buf, "0 1 1 %d",cr_number_offset+pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */

         /**************** PSN --> TDM IW *****************/
         /* if clock recovery is set -> Tx timing is used */
         CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/
         CLI_F_PwCreate("0 0 1 1"); /* CR master */

         sprintf(temp_buf, "0 %d 1",pw_index);
         CLI_F_PwEnable(temp_buf);
      } /* end for (configure each line) */
   }
}
void CLI_F_131_SBI_E1_F_CR_EXTENDED_DIFF_NoCas_Two_Boards_252CD_252Lines_1008Pw (char *StrPrm)
{
   /* test case 3.3.2.5 */
   int recover_by_pw = 0;
   WP_U32 i, j, line_index, spe_index, timing_index, pw_index, pw_per_line = 4;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 cr_number_offset = WTI_CESOP_MAX_CLOCK_REC_INTERFACES; /* first CD in ext_diff mode */
   int num_of_active_ext_diff_cd =
      ((global_active_cr_extdiff_mode <= 252) ? global_active_cr_extdiff_mode : 252);
   WP_U8 clock_rec_lines[336] = {0}; /* list of master lines */
   WP_U8 clock_rec_pw_psn2tdm[252*32] = {0}; /* list of active CR PWs in the TX direction */
   WP_U32 res, cmd, du_size, ps;


   if (recover_by_pw >= pw_per_line)
   {
      printf("WORNING! recover PW (%d) is bigger than number of PW per line (%d). Recover by the first PW on each line\n", recover_by_pw, pw_per_line);
      recover_by_pw = 0;
   }

   /* Set the CR lines (both for RX and TX direction */
   for (i=0; i<num_of_active_ext_diff_cd; i++)
   {
      clock_rec_lines[CLI_F_AttacheLineToPwNumber(i)] = 1;
      clock_rec_pw_psn2tdm[i*pw_per_line+recover_by_pw] = 1; /* select the Pw to recovers the clock on */
   }

   /* when available, read parameters from user */
   res = sscanf(StrPrm, "%d %d %d", &cmd, &du_size, &ps);
   if (res == 1)
   {
      du_size = 64; /* use default setup */
      ps = 256;
   }
   else if (res == 2)
      ps = 256; /* use default setup */
   else if (res > 3)
   {
      WTI_TerminatePrintError("Invalid number of parameters", __LINE__);
      return;
   }
   printf("Test run with DU size %d, Packet Size %d\n", du_size, ps);

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
      CLI_F_UfeClockMode("0 0");
   else
      CLI_F_UfeClockMode("0 1");

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential) for regular mode */
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)

      {
         line_index = i*28 + j;
         timing_index = i*WTI_E1_LINES_PER_SPE + j;

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 3 3",line_index);
            CLI_F_UfeTransferMode(temp_buf);
         }
         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+timing_index);
            CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */
         }

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+timing_index);
            CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
         }
      }
   }

   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();

   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/
   CLI_F_UfeTemuxSetup("0 3");

   CLI_F_UfeChipInitLineSetup("");

   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<(WTI_E1_LINES_PER_SPE*pw_per_line); j++)
      {
         line_index = i*28 + j/pw_per_line;
         pw_index = i*WTI_E1_LINES_PER_SPE*pw_per_line + j;

         /* By default, the DU size is 64 unless test gets different parameters */
         sprintf(temp_buf, "0 %d %d %d %d %d-%d",
                 line_index, du_size, du_size, 32/pw_per_line,
                 32/pw_per_line*(pw_index%pw_per_line),
                 32/pw_per_line*(pw_index%pw_per_line)+(32/pw_per_line-1));/* Line index of this PW, RX DUS, TX DUS, number of slots, slots ID (from-to) */
         CLI_F_PwConfigureFramed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         /* By default, the PS in 256, unless test gets different parameters */
         sprintf(temp_buf, "0 %d", ps);
         CLI_F_Pwe3ChannelRxBufferSize(temp_buf);
         CLI_F_Pwe3ChannelStatmode("0 1");
         if (pw_per_line == 1)
         {
            CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
            CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
         }
         else if (pw_per_line == 2)
         {
            CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15");
            CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39");
         }
         else if (pw_per_line == 3)
         {
            CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11");
            CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35");
         }
         else
         {
            CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7");
            CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31");
         }
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 0 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

         /* Rx timing is used in differential mode */
         sprintf(temp_buf, "0 1 1 %d",cr_number_offset+(pw_index/pw_per_line));
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */

         /**************** PSN --> TDM IW *****************/
         /* if clock recovery is set -> Tx timing is used */
         if (clock_rec_pw_psn2tdm[pw_index] == 1)
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/
         if (clock_rec_pw_psn2tdm[pw_index] == 1)
         {
            CLI_F_PwCreate("0 0 1 1"); /* CR master */
            sprintf(temp_buf, "0 %d 1",pw_index);
         }
         else
         {
            CLI_F_PwCreate("0 0 1 0"); /* if PW is not master CR, active only RX, no TX */
            sprintf(temp_buf, "0 %d 0",pw_index);
         }
         CLI_F_PwEnable(temp_buf);
      } /* end for (configure each line) */
   }
}

void CLI_F_131_SBI_T1_F_CR_EXTENDED_DIFF_NoCas_Two_Boards_336CD_336Lines_1344Pw (char *StrPrm)
{  /* test case 3.3.2.6 */
   int recover_by_pw = 0;
   WP_U32 i, j, line_index, spe_index, pw_index, pw_per_line = 4;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 cr_number_offset = WTI_CESOP_MAX_CLOCK_REC_INTERFACES; /* first CD in ext_diff mode */
   int num_of_active_ext_diff_cd = global_active_cr_extdiff_mode;
   WP_U8 clock_rec_lines[336] = {0}; /* list of master lines */
   WP_U8 clock_rec_pw_psn2tdm[336*24] = {0}; /* list of active CR PWs in the TX direction */
   WP_U32 res, cmd, du_size, ps;


   if (recover_by_pw >= pw_per_line)
   {
      printf("WORNING! recover PW (%d) is bigger than number of PW per line (%d). Recover by the first PW on each line\n", recover_by_pw, pw_per_line);
      recover_by_pw = 0;
   }

   /* Set the CR lines (both for RX and TX direction */
   for (i=0; i<num_of_active_ext_diff_cd; i++)
   {
      clock_rec_lines[i] = 1;
      clock_rec_pw_psn2tdm[i*pw_per_line+recover_by_pw] = 1; /* select the Pw to recovers the clock on */
   }

   /* when available, read parameters from user */
   res = sscanf(StrPrm, "%d %d %d", &cmd, &du_size, &ps);
   if (res == 1)
   {
      du_size = 48; /* use default setup */
      ps = 384;
   }
   else if (res == 2)
      ps = 384; /* use default setup */
   else if (res > 3)
   {
      WTI_TerminatePrintError("Invalid number of parameters", __LINE__);
      return;
   }
   printf("Test run with DU size %d, Packet Size %d\n", du_size, ps);

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
      CLI_F_UfeClockMode("0 0");
   else
      CLI_F_UfeClockMode("0 1");

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential) for regular mode */
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)

      {
         line_index = i*28 + j;

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 1 3",line_index);
            CLI_F_UfeTransferMode(temp_buf);
         }
         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+line_index);
            CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */
         }

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+line_index);
            CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
         }
      }
   }

   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();

   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/
   CLI_F_UfeTemuxSetup("0 1");

   CLI_F_UfeChipInitLineSetup("");

   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE*pw_per_line; j++)
      {
         line_index = i*28 + j/pw_per_line;
         pw_index = i*WTI_T1_LINES_PER_SPE*pw_per_line + j;

         /* By default, the DU size is 48 unless test gets different parameters */
         sprintf(temp_buf, "0 %d %d %d %d %d-%d",
                 line_index, du_size, du_size, 24/pw_per_line,
                 24/pw_per_line*(pw_index%pw_per_line),
                 24/pw_per_line*(pw_index%pw_per_line)+(24/pw_per_line-1));/* The line index of this PW, RX DUS, TX DUS, number of slots, slots ID (from-to) */
         CLI_F_PwConfigureFramed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         /* By default, the PS in 256, unless test gets different parameters */
         sprintf(temp_buf, "0 %d", ps);
         CLI_F_Pwe3ChannelRxBufferSize(temp_buf);
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 0 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

         sprintf(temp_buf, "0 1 1 %d",cr_number_offset+line_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */

         /**************** PSN --> TDM IW *****************/
         /* if clock recovery is set -> Tx timing is used */
         if (clock_rec_pw_psn2tdm[pw_index] == 1)
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/
         if (clock_rec_pw_psn2tdm[pw_index] == 1)
         {
            CLI_F_PwCreate("0 0 1 1"); /* CR master */
            sprintf(temp_buf, "0 %d 1",pw_index);
         }
         else
         {
            CLI_F_PwCreate("0 0 1 0"); /* if PW is not master CR, active only RX, no TX */
            sprintf(temp_buf, "0 %d 0",pw_index);
         }
         CLI_F_PwEnable(temp_buf);
      }

   } /* end for (configure each line) */
}

void CLI_F_132_SBI_T1_F_CR_EXTENDED_DIFF_NoCas_Two_Boards_336CD_336Lines_672Pw_1DS0 (char *StrPrm)
{
   /* test case 3.3.2.7 */
   int recover_by_pw = 0;
   WP_U32 i, j, line_index, spe_index, pw_index, pw_per_line = 2;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 cr_number_offset = WTI_CESOP_MAX_CLOCK_REC_INTERFACES; /* first CD in ext_diff mode */
   int num_of_active_ext_diff_cd = global_active_cr_extdiff_mode;
   WP_U8 clock_rec_lines[336] = {0}; /* list of master lines */
   WP_U8 clock_rec_pw_psn2tdm[336*24] = {0}; /* list of active CR PWs in the TX direction */


   if (recover_by_pw >= pw_per_line)
   {
      printf("WORNING! recover PW (%d) is bigger than number of PW per line (%d). Recover by the first PW on each line\n", recover_by_pw, pw_per_line);
      recover_by_pw = 0;
   }

   /* Set the CR lines (both for RX and TX direction */
   for (i=0; i<num_of_active_ext_diff_cd; i++)
   {
      clock_rec_lines[i] = 1;
      clock_rec_pw_psn2tdm[i*pw_per_line+recover_by_pw] = 1; /* select the Pw to recovers the clock on */
   }

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
      CLI_F_UfeClockMode("0 0");
   else
      CLI_F_UfeClockMode("0 1");

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential) for regular mode */
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)

      {
         line_index = i*28 + j;

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 1 3",line_index);
            CLI_F_UfeTransferMode(temp_buf);
         }
         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+line_index);
            CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */
         }

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+line_index);
            CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
         }
      }
   }

   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();

   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/
   CLI_F_UfeTemuxSetup("0 1");

   CLI_F_UfeChipInitLineSetup("");

   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE*pw_per_line; j++)
      {
         line_index = i*28 + j/pw_per_line;
         pw_index = i*WTI_T1_LINES_PER_SPE*pw_per_line + j;

         sprintf(temp_buf, "0 %d 40 40 1 %d", line_index, (pw_index % 2));/* The line index of this PW */
         CLI_F_PwConfigureFramed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 40");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 0 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

         /* Rx timing is used in differential mode */
         sprintf(temp_buf, "0 1 1 %d",cr_number_offset+(pw_index/pw_per_line));
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */

         /**************** PSN --> TDM IW *****************/
         /* if clock recovery is set -> Tx timing is used */
         if (clock_rec_pw_psn2tdm[pw_index] == 1)
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/
         if (clock_rec_pw_psn2tdm[pw_index] == 1)
         {
            CLI_F_PwCreate("0 0 1 1"); /* CR master */
            sprintf(temp_buf, "0 %d 1",pw_index);
         }
         else
         {
            CLI_F_PwCreate("0 0 1 0"); /* if PW is not master CR, active only RX, no TX */
            sprintf(temp_buf, "0 %d 0",pw_index);
         }
         CLI_F_PwEnable(temp_buf);
      } /* end for (configure each line) */
   }
}

void CLI_F_132_SBI_E1_F_CR_EXTENDED_DIFF_NoCas_Two_Boards_1CD_1Lines_32Pw_1DS0 (char *StrPrm)
{
   /* test case 3.3.2.8 */
   int recover_by_pw = 20;
   WP_U32 i, j, line_index, spe_index, timing_index, pw_index, pw_per_line = 32;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 cr_number_offset = WTI_CESOP_MAX_CLOCK_REC_INTERFACES; /* first CD in ext_diff mode */
   int num_of_active_ext_diff_cd = 1; /* this test works with 1 line/CR/CT */
   WP_U8 clock_rec_lines[336] = {0}; /* list of master lines */
   WP_U8 clock_rec_pw_psn2tdm[252*32] = {0}; /* list of active CR PWs in the TX direction */


   if (recover_by_pw >= pw_per_line)
   {
      printf("WORNING! recover PW (%d) is bigger than number of PW per line (%d). Recover by the first PW on each line\n", recover_by_pw, pw_per_line);
      recover_by_pw = 0;
   }

   /* Set the CR lines (both for RX and TX direction */
   for (i=0; i<num_of_active_ext_diff_cd; i++)
   {
      clock_rec_lines[CLI_F_AttacheLineToPwNumber(i)] = 1;
      clock_rec_pw_psn2tdm[i*pw_per_line+recover_by_pw] = 1; /* select the Pw to recovers the clock on */
   }

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
      CLI_F_UfeClockMode("0 0");
   else
      CLI_F_UfeClockMode("0 1");

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential) for regular mode */
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)

      {
         line_index = i*28 + j;
         timing_index = i*WTI_E1_LINES_PER_SPE + j;

         if (line_index >= num_of_active_ext_diff_cd)
            continue;

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 3 3",line_index);
            CLI_F_UfeTransferMode(temp_buf);
         }
         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+timing_index);
            CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */
         }

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+timing_index);
            CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
         }
      }
   }

   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();

   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/
   CLI_F_UfeTemuxSetup("0 3");

   CLI_F_UfeChipInitLineSetup("");

   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<(WTI_E1_LINES_PER_SPE*pw_per_line); j++)
      {
         line_index = i*28 + j/pw_per_line;
         pw_index = i*WTI_E1_LINES_PER_SPE*pw_per_line + j;

         if (line_index >= num_of_active_ext_diff_cd)
            continue;

         sprintf(temp_buf, "0 %d 40 40 1 %d", line_index, pw_index);/* Line index of this PW */
         CLI_F_PwConfigureFramed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 40");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 0 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

         /* Rx timing is used in differential mode */
         sprintf(temp_buf, "0 1 1 %d",cr_number_offset+(pw_index/pw_per_line));
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */

         /**************** PSN --> TDM IW *****************/
         /* if clock recovery is set -> Tx timing is used */
         if (clock_rec_pw_psn2tdm[pw_index] == 1)
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/
         if (clock_rec_pw_psn2tdm[pw_index] == 1)
         {
            CLI_F_PwCreate("0 0 1 1"); /* CR master */
            sprintf(temp_buf, "0 %d 1",pw_index);
         }
         else
         {
            CLI_F_PwCreate("0 0 1 0"); /* if PW is not master CR, active only RX, no TX */
            sprintf(temp_buf, "0 %d 0",pw_index);
         }
         CLI_F_PwEnable(temp_buf);
      } /* end for (configure each line) */
   }
}

void CLI_F_133_SBI_E1_F_CR_EXTENDED_DIFF_NoCas_Two_Boards_252CD_252Lines_1008Pw_AddRemoveLinesPw (char *StrPrm)
{
   /* test case 3.3.2.10 */
   int recover_by_pw = 1;
   WP_U32 i, j, line_index, spe_index, timing_index, pw_index, pw_per_line = 1;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 cr_number_offset = WTI_CESOP_MAX_CLOCK_REC_INTERFACES; /* first CD in ext_diff mode */
   int num_of_active_ext_diff_cd =
      ((global_active_cr_extdiff_mode <= 252) ? global_active_cr_extdiff_mode : 252);
   WP_U8 clock_rec_lines[336] = {0}; /* list of master lines */
   WP_U8 clock_rec_pw_psn2tdm[252*32] = {0}; /* list of active CR PWs in the TX direction */
   WP_U32 exit_factor = '0', total_num_of_pws = N_ACTIVE_UFE_SBI_SPE*WTI_E1_LINES_PER_SPE*pw_per_line;
   WP_U32 res, cmd, du_size, ps;


   if (recover_by_pw >= pw_per_line)
   {
      printf("WORNING! recover PW (%d) is bigger than number of PW per line (%d). Recover by the first PW on each line\n", recover_by_pw, pw_per_line);
      recover_by_pw = 0;
   }

   /* Set the CR lines (both for RX and TX direction */
   for (i=0; i<num_of_active_ext_diff_cd; i++)
   {
      clock_rec_lines[CLI_F_AttacheLineToPwNumber(i)] = 1;
      clock_rec_pw_psn2tdm[i*pw_per_line+recover_by_pw] = 1; /* select the Pw to recovers the clock on */
   }

   /* when available, read parameters from user */
   res = sscanf(StrPrm, "%d %d %d", &cmd, &du_size, &ps);
   if (res == 1)
   {
      du_size = 64; /* use default setup */
      ps = 256;
   }
   else if (res == 2)
      ps = 256; /* use default setup */
   else if (res > 3)
   {
      WTI_TerminatePrintError("Invalid number of parameters", __LINE__);
      return;
   }
   printf("Test run with DU size %d, Packet Size %d\n", du_size, ps);

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
      CLI_F_UfeClockMode("0 0");
   else
      CLI_F_UfeClockMode("0 1");

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential) for regular mode */
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)

      {
         line_index = i*28 + j;
         timing_index = i*WTI_E1_LINES_PER_SPE + j;

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 3 3",line_index);
            CLI_F_UfeTransferMode(temp_buf);
         }
         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+timing_index);
            CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */
         }

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+timing_index);
            CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
         }
      }
   }

   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();

   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/
   CLI_F_UfeTemuxSetup("0 3");

   CLI_F_UfeChipInitLineSetup("");

   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<(WTI_E1_LINES_PER_SPE*pw_per_line); j++)
      {
         line_index = i*28 + j/pw_per_line;
         pw_index = i*WTI_E1_LINES_PER_SPE*pw_per_line + j;

         /* By default, the DU size is 64 unless test gets different parameters */
         sprintf(temp_buf, "0 %d %d %d %d %d-%d",
                 line_index, du_size, du_size, 32/pw_per_line,
                 32/pw_per_line*(pw_index%pw_per_line),
                 32/pw_per_line*(pw_index%pw_per_line)+(32/pw_per_line-1));/* Line index of this PW, RX DUS, TX DUS, number of slots, slots ID (from-to) */
         CLI_F_PwConfigureFramed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         /* By default, the PS in 256, unless test gets different parameters */
         sprintf(temp_buf, "0 %d", ps);
         CLI_F_Pwe3ChannelRxBufferSize(temp_buf);
         CLI_F_Pwe3ChannelStatmode("0 1");
         if (pw_per_line == 2)
         {
            CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15");
            CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39");
         }
         else if (pw_per_line == 4)
         {
            CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7");
            CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31");
         }
         else
         {
            CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
            CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
         }

         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 0 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

         /* Rx timing is used in differential mode */
         sprintf(temp_buf, "0 1 1 %d",cr_number_offset+(pw_index/pw_per_line));
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */

         /**************** PSN --> TDM IW *****************/
         /* if clock recovery is set -> Tx timing is used */
         if (clock_rec_pw_psn2tdm[pw_index] == 1)
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/
         if (clock_rec_pw_psn2tdm[pw_index] == 1)
         {
            CLI_F_PwCreate("0 0 1 1"); /* CR master */
            sprintf(temp_buf, "0 %d 1",pw_index);
         }
         else
         {
            CLI_F_PwCreate("0 0 1 0"); /* if PW is not master CR, active only RX, no TX */
            sprintf(temp_buf, "0 %d 0",pw_index);
         }
         CLI_F_PwEnable(temp_buf);
      } /* end for (configure each line) */
   }

   /* run test in loop mode */
   while (exit_factor != '9')
   {
      printf("Test running.\nType 's' to see statistics, 'c' to clean statistics, '9' to quit or any other key to remove PWs and lines.\n");
      exit_factor = getchar();
      if (exit_factor == '9')
      {
         printf("Exit test\n");
      }
      else if (exit_factor == 's')
      {
         printf("Check statistics:\n");
         sprintf(temp_buf, "0 %d", total_num_of_pws);
         CLI_F_Pwe3StatisticsCheck(temp_buf);
         CLI_F_ClockRecSystemsStatisticsStatus("0");
         CLI_F_UfeDisplayEvents("0");
      }
      else if (exit_factor == 'c')
      {
         printf("Clear statistics\n");
         sprintf(temp_buf, "0 %d", total_num_of_pws);
         CLI_F_Pwe3StatisticsClear(temp_buf);
         CLI_F_ClockRecSystemsStatisticsReset("0");
         CLI_F_UfeDisplayEvents("0");
      }
      else
      {

         /* remove PWs */
         printf("..:: Removing PW.\n");
         WP_Delay(100000); /*time in usec*/

         for (i=N_ACTIVE_UFE_SBI_SPE; i>0; i--)
         {
            for (j=(WTI_E1_LINES_PER_SPE*pw_per_line); j>0; j--)
            {
               pw_index = (i-1)*WTI_E1_LINES_PER_SPE*pw_per_line + (j-1);
               sprintf(temp_buf, "0 %d", pw_index);
               CLI_F_PwRemove(temp_buf);
            }
         }

         /* remove lines */
         for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
         {
            for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
            {
               line_index = i*28 + j;

               /* this do line disable and line delete */
               WT_UfeLineDelete(&the_system->ufe, line_index);
            }
         }
         printf("PWs and lines removed. Type any key to Recreate...\n");
         exit_factor = getchar();
         if (exit_factor == '9')
            break;

         /* UFE line configuration */
         for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
         {
            for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
            {
               line_index = i*28 + j;
               timing_index = i*WTI_E1_LINES_PER_SPE + j;

               /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
               /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */

               /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */
               /* set ufe Tx and Rx direction */
               if (clock_rec_lines[line_index] == 1)
               {
                  sprintf(temp_buf, "0 %d 3 3",line_index);
                  CLI_F_UfeTransferMode(temp_buf);
               }

               /* match between clock tarnslators and lines for the CR lines   */
               /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
               if (clock_rec_lines[line_index] == 1)
               {
                  sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+timing_index);
                  CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, clock_trans_id */
               }

               /* match between clock shaper and lines for the CR lines   */
               /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
               if (clock_rec_lines[line_index] == 1)
               {
                  sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+timing_index);
                  CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
               }
            }
         }
         /* create line second time */
         CLI_F_UfeChipInitLineSetup("");
         /* recreate PW  */
         for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
         {
            for (j=0; j<(WTI_E1_LINES_PER_SPE*pw_per_line); j++)
            {
               line_index = i*28 + j/pw_per_line;
               pw_index = i*WTI_E1_LINES_PER_SPE*pw_per_line + j;

               sprintf(temp_buf, "0 %d %d %d %d %d %d-%d",
                       line_index, pw_index, du_size, du_size, 32/pw_per_line,
                       32/pw_per_line*(pw_index%pw_per_line),
                       32/pw_per_line*(pw_index%pw_per_line)+(32/pw_per_line-1));/* Line index of this PW, RX DUS, TX DUS, number of slots, slots ID (from-to) */
               CLI_F_PwConfigureFramed(temp_buf);

               /* PWE3 channel configuration */
               CLI_F_Pwe3ChannelJitterBufferSize("0 32");
               sprintf(temp_buf, "0 %d", ps);
               CLI_F_Pwe3ChannelRxBufferSize(temp_buf);
               CLI_F_Pwe3ChannelStatmode("0 1");
               CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
               CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
               CLI_F_Pwe3ChannelUdpDummyMode("0 1");
               CLI_F_Pwe3ChannelTxUdcas("0 f");

               /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
               CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
               CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
               sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
               CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
               sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
               CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
               CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 0 0");
               CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
               CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

               /* Rx timing is used in differential mode */
               /* first global_active_cr_async_mode related to different CDs */
               sprintf(temp_buf, "0 1 1 %d",cr_number_offset+(pw_index/pw_per_line));
               CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */

               /**************** PSN --> TDM IW *****************/
               /* if clock recovery is set -> Tx timing is used */
               if (clock_rec_pw_psn2tdm[pw_index] == 1)    /* lines 0-(N-1) use CR, all other don't */
                  CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
               else
                  CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
               CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
               CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

               /**************** PSN --> TDM Tx binding*****************/
               /* CR Rx and Tx direction */
               if (clock_rec_pw_psn2tdm[pw_index] == 1)   /* pw 0-(N-1) use CR, all other don't */
                  sprintf(temp_buf,"0 0 1 1 %d", pw_index); /* CR master */
               else
                  sprintf(temp_buf,"0 0 1 0 %d", pw_index); /* CR slave */
               CLI_F_PwCreate(temp_buf);

               if (clock_rec_pw_psn2tdm[pw_index] == 1)
                  sprintf(temp_buf, "0 %d 1",pw_index); /* line 1 is the master, all other slaves */
               else
                  sprintf(temp_buf, "0 %d 0",pw_index);
               CLI_F_PwEnable(temp_buf);


            } /* end for (configure each line) */
         }
      } /*if exit_factor */
   }
}

void CLI_F_133_SBI_T1_F_CR_EXTENDED_DIFF_NoCas_Two_Boards_336CD_336Lines_1344Pw_AddRemoveLinesPw (char *StrPrm)
{
   /* test case 3.3.2.10 */
}

void CLI_F_134_SBI_E3_U_CR_EXTENDED_DIFF_NoCas_Two_Boards_12CD_12Lines_12Pw (char *StrPrm)
{
   /* test case 3.3.2.13 */
}

void CLI_F_134_SBI_DS3_U_CR_EXTENDED_DIFF_NoCas_Two_Boards_12CD_12Lines_12Pw (char *StrPrm)
{
   /* test case 3.3.2.11 */
}

void CLI_F_134_SBI_E3_F_CR_EXTENDED_DIFF_NoCas_Two_Boards_12CD_12Lines_12Pw (char *StrPrm)
{
   /* test case 3.3.2.14 */
}

void CLI_F_134_SBI_DS3_F_CR_EXTENDED_DIFF_NoCas_Two_Boards_12CD_12Lines_12Pw (char *StrPrm)
{
   /* test case 3.3.2.12 */
}

void CLI_F_135_SBI_DS3_U_CR_EXTENDED_DIFF_NoCas_Two_Boards_309CD_1DS3_Lines_308T1_Lines_309Pw (char *StrPrm)
{
   /* test case 3.3.2.15 */
}

void CLI_F_136_SBI_E1_F_30xDS0_CR_EXTENDED_DIFF_Cas_Unrg_Two_Boards_252CD_252Lines_252Pw (char *StrPrm)
{
   /* test case 3.3.x.x */
   WP_U32 i, j, line_index, spe_index, timing_index, pw_index;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 cr_number_offset = WTI_CESOP_MAX_CLOCK_REC_INTERFACES; /* first CD in ext_diff mode */
   int num_of_active_ext_diff_cd =
      ((global_active_cr_extdiff_mode <= 252) ? global_active_cr_extdiff_mode : 252);
   WP_U8  clock_rec_lines[336] = {0}; /* list of master lines */


   /* Set the CR lines (both for RX and TX direction */
   for (i=0; i<num_of_active_ext_diff_cd; i++)
   {
      clock_rec_lines[CLI_F_AttacheLineToPwNumber(i)] = 1;
   }

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
      CLI_F_UfeClockMode("0 0");
   else
      CLI_F_UfeClockMode("0 1");

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential) for regular mode */
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)

      {
         line_index = i*28 + j;
         timing_index = i*WTI_E1_LINES_PER_SPE + j;

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 3 3",line_index);
            CLI_F_UfeTransferMode(temp_buf);
         }
         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 1",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+timing_index);
            CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */
         }

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+timing_index);
            CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
         }
      }
   }

   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();

   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/
   CLI_F_UfeTemuxSetup("0 9");

   CLI_F_UfeChipInitLineSetup("");

   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_E1_LINES_PER_SPE + j;

         sprintf(temp_buf, "0 %d 30 30 30 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31", line_index);/* The line index of this PW */
         CLI_F_PwConfigureFramed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 480"); /* 16*30 */
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 0 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

         /* Rx timing is used in differential mode */
         sprintf(temp_buf, "0 1 1 %d",cr_number_offset+pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */

         /**************** PSN --> TDM IW *****************/
         /* if clock recovery is set -> Tx timing is used */
         CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/
         CLI_F_PwCreate("0 0 1 1"); /* CR master */

         sprintf(temp_buf, "0 %d 1",pw_index);
         CLI_F_PwEnable(temp_buf);
      } /* end for (configure each line) */
   }
}

/********************************************************************************************
 * Description:
 *            This test generates full OC12 lines and PWs and check the Extended Differential
 *            mode, where N = "global_active_cr_extdiff_mode"
 * TDM2PSN :  The test uses N CD for the first N PWs (in this case PW = line)
 *            each CD connected to different line.
 * PSN2TDM :  Each line is connected to different CT.
 *
 * The test can run upto 252 lines (all use same PS and DUS)
 *
 *******************************************************************************************/
#if WTI_CESOP_TO_MPLS_FA_CASCADING
void CLI_F_137_SBI_E1_U_CR_EXTENDED_DIFF_NoCas_Mpls_Cascading_Two_Boards_252CD_252Lines_252Pw (char *StrPrm)
{ /* test case  */
   WP_U32 i, j, line_index, spe_index, timing_index, pw_index;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 cr_number_offset = WTI_CESOP_MAX_CLOCK_REC_INTERFACES; /* first CD in ext_diff mode */
   int num_of_active_ext_diff_cd =
      ((global_active_cr_extdiff_mode <= 252) ? global_active_cr_extdiff_mode : 252);
   WP_U8  clock_rec_lines[399] = {0}; /* list of master lines */
   WP_U32 res, cmd, du_size, ps;


   /* Set the CR lines (both for RX and TX direction */
   for (i=0; i<num_of_active_ext_diff_cd; i++)
   {
      clock_rec_lines[CLI_F_AttacheLineToPwNumber(i)] = 1;
   }

   /* when available, read parameters from user */
   res = sscanf(StrPrm, "%d %d %d", &cmd, &du_size, &ps);
   if (res == 1)
   {
      du_size = 64; /* use default setup */
      ps = 256;
   }
   else if (res == 2)
      ps = 256; /* use default setup */
   else if (res > 3)
   {
      WTI_TerminatePrintError("Invalid number of parameters", __LINE__);
      return;
   }
   printf("Test run with DU size %d, Packet Size %d\n", du_size, ps);

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
      CLI_F_UfeClockMode("0 0");
   else
      CLI_F_UfeClockMode("0 1");

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential) for regular mode */
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)

      {
         line_index = i*28 + j;
         timing_index = i*WTI_E1_LINES_PER_SPE + j;

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 4 3",line_index);
            CLI_F_UfeTransferMode(temp_buf);
         }
         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+timing_index);
            CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */
         }

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+timing_index);
            CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
         }
      }
   }

   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();

   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/
   CLI_F_UfeTemuxSetup("0 2");

   CLI_F_UfeChipInitLineSetup("");

   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   /* ------------------- Creating the MPLS L2 router flow aggregations in both directions */
   for (i=0;i<WTI_MAX_NUM_OF_MPLS_FA;++i)
      {
#if WTI_CESOP_MPLS_OVER_ENET
      /* create the l2 router MPLS flow aggregations */
      CLI_F_Tdm2PsnFlowAggEnetHeaderMpls("0 aa aa aa aa aa aa bb bb bb bb bb bb 8847");
      CLI_F_MplsFlowAggPrefixLength("0 14");
      sprintf(temp_buf,
              "0 %x %x %x %x %x %x",
              3*i,
              3*i+1,
              3*i+2,
              (0x88470000 | ((((WTI_MPLS_LABEL) >> 12) + WTI_MAX_PW + 1 + i) >> 4)),
              ((((((WTI_MPLS_LABEL) >> 12)  + WTI_MAX_PW + 1 + i) & 0xff) << 28) | 0x00ff0000),
              0);
      /*                              [mac destination] [mac source] [vlan] [type] [mpls header] */
      CLI_F_MplsFlowAggPrefixHeaderMpls(temp_buf);

      mpls_layer2_agg_cfg.txfunc = the_system->tx_enet_channel;

      sprintf(temp_buf, "0 %d", 0); /* remark offsets for VLAN priority and PSN tunnel EXP bits */

      CLI_F_MplsFlowAggRemarkingOffsets(temp_buf);
      sprintf(temp_buf, "0 %d", i);
      CLI_F_MplsFlowAggCreate(temp_buf);
#else
#if WTI_CESOP_NATIVE_MPLS_IW
      /* create the l2 router MPLS flow aggregations */
      CLI_F_MplsFlowAggPrefixLength("0 0");
      sprintf(temp_buf,
              "0 %x",
              (((((WTI_MPLS_LABEL) >> 12) + WTI_MAX_PW + 1 + i) << 12) | 0xff));
      /*                              [mpls header] */
      CLI_F_MplsFlowAggPrefixHeaderMpls(temp_buf);
      sprintf(temp_buf, "0 %d %d", 1, 5); /* remark offsets for PSN tunnel EXP bits */

      CLI_F_MplsFlowAggRemarkingOffsets(temp_buf);
      sprintf(temp_buf, "0 %d", i);
      CLI_F_MplsFlowAggCreate(temp_buf);
#else
      /* create the l2 router MPLS flow aggregations */
      CLI_F_MplsFlowAggPrefixLength("0 4");
      sprintf(temp_buf,
              "0 %x %x",
              WTI_MPLSoPPP,
              (((((WTI_MPLS_LABEL) >> 12) + WTI_MAX_PW + 1 + i) << 12) | 0xff));
      /*                              [ppp] [mpls header] */
      CLI_F_MplsFlowAggPrefixHeaderMpls(temp_buf);
      sprintf(temp_buf, "0 %d %d", 1, 13); /* remark offsets for PSN tunnel EXP bits */

      CLI_F_MplsFlowAggRemarkingOffsets(temp_buf);
      sprintf(temp_buf, "0 %d", i);
      CLI_F_MplsFlowAggCreate(temp_buf);
#endif /* WTI_CESOP_NATIVE_MPLS_IW */
#endif /* WTI_CESOP_MPLS_OVER_ENET */
   }


   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_E1_LINES_PER_SPE + j;

         /* By default, the DU size is 64 unless test gets different parameters */
         sprintf(temp_buf, "0 %d %d %d", line_index, du_size, du_size);/* The line index of this PW */
         CLI_F_PwConfigureUnframed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         /* By default, the PS in 256, unless test gets different parameters */
         sprintf(temp_buf, "0 %d", ps);
         CLI_F_Pwe3ChannelRxBufferSize(temp_buf);
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 0 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

         /* Rx timing is used in differential mode */
         sprintf(temp_buf, "0 1 1 %d",cr_number_offset+pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */

         /**************** PSN --> TDM IW *****************/
         /* if clock recovery is set -> Tx timing is used */
         CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/
//         CLI_F_PwCreate("0 0 1 1"); /* CR master */
         sprintf(temp_buf, "0 %d %d %d %d %d", 0,1,1,0,pw_index);
         CLI_F_PwCreateCascaded(temp_buf);

         sprintf(temp_buf, "0 %d 1",pw_index);
         CLI_F_PwEnable(temp_buf);
      } /* end for (configure each line) */
   }
}
#endif /* WTI_CESOP_TO_MPLS_FA_CASCADING */

/********************************************************************************************
 * Description:
 *            This test generates full OC12 lines and PWs in extended differential mode and
 *            another 32 lines (and PWs) in adaptive CR mode.
 *            N = "global_active_cr_extdiff_mode"
 *            M = "global_active_cr_async_mode"
 * TDM2PSN :  The ACD uses M CD for adaptive mode (up to 32 CD). The EXT.DIff. uses N CD for
 *            the rest of N PWs (in this case PW = line), up to 252.
 *            Each CD connected to different line.
 * PSN2TDM :  The ACR connects each line to adaptive CT and the ext.diff connects each line
 *            to different CT.
 *
 * The test can run upto 252+32 lines (all use same PS and DUS)
 *
 *******************************************************************************************/
void CLI_F_140_SBI_E1_U_CR_COMBINED_DIFF_ADAP_NoCas_Two_Boards_N_EXT_CD_M_REG_CD_252Lines (char *StrPrm)
{
   /* test case 3.4.2.1 */
   WP_U32 i, j, line_index, spe_index, pw_index;
   WP_U32 adap_timing_index, ext_diff_timing_index;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 cr_number_offset = WTI_CESOP_MAX_CLOCK_REC_INTERFACES; /* first CD in ext_diff mode */
#if WTI_EXT_DIFF_MODE_ACTIVE
   int num_of_active_ext_diff_cd =
      ((global_active_cr_extdiff_mode <= 252) ? global_active_cr_extdiff_mode : 252);
#else
   int num_of_active_ext_diff_cd = 0;
#endif
   WP_U8   clock_rec_lines[399] = {0}; /* list of master lines */
   WP_U8   clock_rec_pw_psn2tdm[399] = {0};
   WP_U8   clock_rec_pw_tdm2psn[399] = {0};

#if WTI_CLOCK_REC_MODE
   printf("WORNING!!! This test is for adaptive + extended differential. Please set WTI_CLOCK_REC_MODE to '0'\n");
   printf("Type '9' to continue with the current configuration or any other key to exit\n");
   i = getchar();
   if (i != '9')
      exit(1);
#endif /* WTI_CLOCK_REC_MODE */

   /* Set the CR lines (both for RX and TX direction */
   for (i=0; i< global_active_cr_async_mode; i++)
   {/* Set lines to be CR master in regular mode*/
      clock_rec_lines[CLI_F_AttacheLineToPwNumber(i)] = WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC;
      clock_rec_pw_psn2tdm[i] = WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC;
      clock_rec_pw_tdm2psn[i] = WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC;
   }
   for (i=global_active_cr_async_mode; i<global_active_cr_async_mode+num_of_active_ext_diff_cd; i++)
   {/* Set lines to be CR master in extended mode*/
      clock_rec_lines[CLI_F_AttacheLineToPwNumber(i)] = WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC;
      clock_rec_pw_psn2tdm[i] = WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC;
      clock_rec_pw_tdm2psn[i] = WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC;
   }

#if WTI_DEBUG_LEVEL
   printf("clock_rec structures:\n");
   for (i=0; i<336; i++)
   {
      if (clock_rec_lines[i] != 0)
         printf(" index %d in clock_rec_lines is %d\n", i, clock_rec_lines[i]);
      if (clock_rec_pw_psn2tdm[i] != 0)
         printf(" index %d in clock_rec_pw_psn2tdm is %d\n", i, clock_rec_pw_psn2tdm[i]);
      if (clock_rec_pw_tdm2psn[i] != 0)
         printf(" index %d in clock_rec_pw_tdm2psn is %d\n", i, clock_rec_pw_tdm2psn[i]);
   }
#endif

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-regular differential) */
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */

   /* Init timing indexes to zero */
   adap_timing_index = 0;
   ext_diff_timing_index = 0;

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         /* verify legal timing values */
         if (adap_timing_index > 64 ||
               ext_diff_timing_index > 336 ||
               (adap_timing_index + ext_diff_timing_index > 336))
         {
            printf("ERROR!! Atempting to initial invalid clock domain index.\n");
            continue;
         }

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-336))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         /* line uses CR RX/TX or both */
         if (clock_rec_lines[line_index] != 0)
         {
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 4 3",line_index);
         }
         else
         {
            /* set ufe Rx direction only */
            sprintf(temp_buf, "0 %d 4 2",line_index);
         }
         CLI_F_UfeTransferMode(temp_buf);
         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-336)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-336), translator ID (0-31/336)] */
         if (clock_rec_lines[line_index] == WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC)
            sprintf(temp_buf, "0 %d %d", line_index, adap_timing_index);
         else if (clock_rec_lines[line_index] == WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC)
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+ext_diff_timing_index);
         else
         {
            /* conect all others to the first line. in normal mode should not happened */
            sprintf(temp_buf, "0 %d 0", line_index);
         }
         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-336), shaper ID (0-31) or extended CD ID (32-335)] */
         if (clock_rec_lines[line_index] == WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC)
            sprintf(temp_buf, "0 %d %d", line_index, adap_timing_index);
         else if (clock_rec_lines[line_index] == WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC)
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+ext_diff_timing_index);
         else
         {
            /* conect all others to the first line. in normal mode should not happened */
            sprintf(temp_buf, "0 %d 0", line_index);
         }
         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, shaper ID / ext. CD ID */

         /* increment CD index */
         if (clock_rec_lines[line_index] == WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC)
            adap_timing_index++;
         else if (clock_rec_lines[line_index] == WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC)
            ext_diff_timing_index++;

      }
   }
   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();

   /* Temux Setup:
     0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas */
   CLI_F_UfeTemuxSetup("0 2");

   CLI_F_UfeChipInitLineSetup("");
   /* ----------------------------- Set Clock Recovery Paramters ------------------------- */
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      if (clock_rec_lines[i] == WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC)
      {
         the_system->clock_rec[i].operation_mode = WP_IW_CLOCK_REC_ADAPTIVE_MODE;
         the_system->clock_rec[i].direct_factor = 28;
         the_system->clock_rec[i].integration_factor = 32;
         the_system->clock_rec[i].divisor_update_period = 4;
         the_system->clock_rec[i].phase_error_threshold = 6000;
         the_system->clock_rec[i].freq_error_rec_period = 128;
         the_system->clock_rec[i].average_divisor_factor = 4;
         the_system->clock_rec[i].allowed_dummy_packets = 16;
         the_system->clock_rec[i].pm_threshold = 2;
         the_system->clock_rec[i].max_pm_threshold = 4;
         the_system->clock_rec[i].pm_error_threshold = 600;
      }
      if (clock_rec_lines[i] == WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC)
      {
         the_system->clock_rec[i].operation_mode = WP_IW_CLOCK_REC_DIFFERENTIAL_MODE;
         the_system->clock_rec[i].direct_factor = 1;
         the_system->clock_rec[i].integration_factor =
            the_system->clock_rec[i].direct_factor + 8;
         the_system->clock_rec[i].divisor_update_period = 32;
         the_system->clock_rec[i].phase_error_threshold = 0;
         the_system->clock_rec[i ].freq_error_rec_period = 0;
         the_system->clock_rec[i ].average_divisor_factor = 10;
         the_system->clock_rec[i ].allowed_dummy_packets = 0;
      }
   }

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   /* Init timing indexes to zero */
   adap_timing_index = 0;
   ext_diff_timing_index = 0;

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_E1_LINES_PER_SPE + j;

         sprintf(temp_buf, "0 %d 64 64", line_index);/* The line index of this PW */
         CLI_F_PwConfigureUnframed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 256");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 198 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

         /* Rx timing is used in differential or ext. differential modes */
         /* set timing according to mode */
         if (clock_rec_pw_tdm2psn[pw_index] == WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC)
            sprintf(temp_buf, "0 1 1 %d", adap_timing_index);
         else if (clock_rec_pw_tdm2psn[pw_index] == WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC)
            sprintf(temp_buf, "0 1 1 %d", cr_number_offset + ext_diff_timing_index);
         else
         {
            /* In differential mode all other pw uses CD#0. In normal mode, this should not happened */
            sprintf(temp_buf, "0 1 1 0");
         }
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-335)] */

         /**************** PSN --> TDM IW *****************/
         /* if clock recovery is set -> Tx timing is used */
         if (clock_rec_pw_psn2tdm[pw_index] != 0)
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/
         if (clock_rec_pw_psn2tdm[pw_index] != 0)
         {
            /* CR master Rx and Tx direction */
            CLI_F_PwCreate("0 0 1 1"); /* CR master */
            sprintf(temp_buf, "0 %d 1",pw_index);
         }
         else
         {  /* Not TX CR PW */
            /* Set all PW in RX to work in shapping mode */
            CLI_F_PwCreate("0 0 1 0"); /* CR master */
            sprintf(temp_buf, "0 %d 0",pw_index);
         }
         CLI_F_PwEnable(temp_buf);

         /* increment CD index */
         if (clock_rec_pw_tdm2psn[pw_index] == WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC)
            adap_timing_index++;
         else if (clock_rec_pw_tdm2psn[pw_index] == WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC)
            ext_diff_timing_index++;

      } /* end for (configure each line) */
   }
}

void CLI_F_140_SBI_T1_U_CR_COMBINED_DIFF_ADAP_NoCas_Two_Boards_N_EXT_CD_M_REG_CD_336Lines (char *StrPrm)
{
   /* test case 3.4.2.2 */
   WP_U32 i, j, line_index, spe_index, pw_index;
   WP_U32 adap_timing_index, ext_diff_timing_index;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 cr_number_offset = WTI_CESOP_MAX_CLOCK_REC_INTERFACES; /* first CD in ext_diff mode */
#if WTI_EXT_DIFF_MODE_ACTIVE
   int num_of_active_ext_diff_cd = global_active_cr_extdiff_mode;
#else
   int num_of_active_ext_diff_cd = 0;
#endif
   WP_U8   clock_rec_lines[399] = {0}; /* list of master lines */
   WP_U8   clock_rec_pw_psn2tdm[399] = {0};
   WP_U8   clock_rec_pw_tdm2psn[399] = {0};

#if WTI_CLOCK_REC_MODE
   printf("WORNING!!! This test is for adaptive + extended differential. Please set WTI_CLOCK_REC_MODE to '0'\n");
   printf("Type '9' to continue with the current configuration or any other key to exit\n");
   i = getchar();
   if (i != '9')
      exit(1);
#endif /* WTI_CLOCK_REC_MODE */

   /* Set the CR lines (both for RX and TX direction */
   for (i=0; i< global_active_cr_async_mode; i++)
   {/* Set lines to be CR master in regular mode*/
      clock_rec_lines[i] = WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC;
      clock_rec_pw_psn2tdm[i] = WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC;
      clock_rec_pw_tdm2psn[i] = WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC;
   }
   for (i=global_active_cr_async_mode; i<global_active_cr_async_mode+num_of_active_ext_diff_cd; i++)
   {/* Set lines to be CR master in extended mode*/
      clock_rec_lines[i] = WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC;
      clock_rec_pw_psn2tdm[i] = WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC;
      clock_rec_pw_tdm2psn[i] = WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC;
   }

#if WTI_DEBUG_LEVEL
   printf("clock_rec structures:\n");
   for (i=0; i<336; i++)
   {
      if (clock_rec_lines[i] != 0)
         printf(" index %d in clock_rec_lines is %d\n", i, clock_rec_lines[i]);
      if (clock_rec_pw_psn2tdm[i] != 0)
         printf(" index %d in clock_rec_pw_psn2tdm is %d\n", i, clock_rec_pw_psn2tdm[i]);
      if (clock_rec_pw_tdm2psn[i] != 0)
         printf(" index %d in clock_rec_pw_tdm2psn is %d\n", i, clock_rec_pw_tdm2psn[i]);
   }
#endif

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-regular differential) */
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */

   /* Init timing indexes to zero */
   adap_timing_index = 0;
   ext_diff_timing_index = 0;

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         /* verify legal timing values */
         if (adap_timing_index > 64 ||
               ext_diff_timing_index > 336 ||
               (adap_timing_index + ext_diff_timing_index > 336))
         {
            printf("ERROR!! Atempting to initial invalid clock domain index.\n");
            continue;
         }

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-336))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         /* line uses CR RX/TX or both */
         if (clock_rec_lines[line_index] != 0)
         {
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 2 3",line_index);
         }
         else
         {
            /* set ufe Rx direction only */
            sprintf(temp_buf, "0 %d 2 2",line_index);
         }
         CLI_F_UfeTransferMode(temp_buf);
         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-336)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-336), translator ID (0-31/336)] */
         if (clock_rec_lines[line_index] == WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC)
            sprintf(temp_buf, "0 %d %d", line_index, adap_timing_index);
         else if (clock_rec_lines[line_index] == WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC)
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+ext_diff_timing_index);
         else
         {
            /* conect all others to the first line. in normal mode should not happened */
            sprintf(temp_buf, "0 %d 0", line_index);
         }
         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-336), shaper ID (0-31) or extended CD ID (32-335)] */
         if (clock_rec_lines[line_index] == WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC)
            sprintf(temp_buf, "0 %d %d", line_index, adap_timing_index);
         else if (clock_rec_lines[line_index] == WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC)
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+ext_diff_timing_index);
         else
         {
            /* conect all others to the first line. in normal mode should not happened */
            sprintf(temp_buf, "0 %d 0", line_index);
         }
         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, shaper ID / ext. CD ID */

         /* increment CD index */
         if (clock_rec_lines[line_index] == WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC)
            adap_timing_index++;
         else if (clock_rec_lines[line_index] == WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC)
            ext_diff_timing_index++;

      }
   }
   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();

   /* Temux Setup:
     0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas */
   CLI_F_UfeTemuxSetup("0 0");

   CLI_F_UfeChipInitLineSetup("");
   /* ----------------------------- Set Clock Recovery Paramters ------------------------- */
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      if (clock_rec_lines[i] == WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC)
      {
         the_system->clock_rec[i].operation_mode = WP_IW_CLOCK_REC_ADAPTIVE_MODE;
         the_system->clock_rec[i].direct_factor = 28;
         the_system->clock_rec[i].integration_factor = 32;
         the_system->clock_rec[i].divisor_update_period = 4;
         the_system->clock_rec[i].phase_error_threshold = 6000;
         the_system->clock_rec[i].freq_error_rec_period = 128;
         the_system->clock_rec[i].average_divisor_factor = 4;
         the_system->clock_rec[i].allowed_dummy_packets = 16;
         the_system->clock_rec[i].pm_threshold = 2;
         the_system->clock_rec[i].max_pm_threshold = 4;
         the_system->clock_rec[i].pm_error_threshold = 600;
      }
      if (clock_rec_lines[i] == WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC)
      {
         the_system->clock_rec[i].operation_mode = WP_IW_CLOCK_REC_DIFFERENTIAL_MODE;
         the_system->clock_rec[i].direct_factor = 1;
         the_system->clock_rec[i].integration_factor =
            the_system->clock_rec[i].direct_factor + 8;
         the_system->clock_rec[i].divisor_update_period = 32;
         the_system->clock_rec[i].phase_error_threshold = 0;
         the_system->clock_rec[i ].freq_error_rec_period = 0;
         the_system->clock_rec[i ].average_divisor_factor = 10;
         the_system->clock_rec[i ].allowed_dummy_packets = 0;
      }
   }

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   /* Init timing indexes to zero */
   adap_timing_index = 0;
   ext_diff_timing_index = 0;

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_T1_LINES_PER_SPE + j;

         sprintf(temp_buf, "0 %d 48 48", line_index);/* The line index of this PW */
         CLI_F_PwConfigureUnframed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 192");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 198 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

         /* Rx timing is used in differential or ext. differential modes */
         /* set timing according to mode */
         if (clock_rec_pw_tdm2psn[pw_index] == WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC)
            sprintf(temp_buf, "0 1 1 %d", adap_timing_index);
         else if (clock_rec_pw_tdm2psn[pw_index] == WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC)
            sprintf(temp_buf, "0 1 1 %d", cr_number_offset + ext_diff_timing_index);
         else
         {
            /* In differential mode all other pw uses CD#0. In normal mode, this should not happened */
            sprintf(temp_buf, "0 1 1 0");
         }
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-335)] */

         /**************** PSN --> TDM IW *****************/
         /* if clock recovery is set -> Tx timing is used */
         if (clock_rec_pw_psn2tdm[pw_index] != 0)
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/
         if (clock_rec_pw_psn2tdm[pw_index] != 0)
         {
            /* CR master Rx and Tx direction */
            CLI_F_PwCreate("0 0 1 1"); /* CR master */
            sprintf(temp_buf, "0 %d 1",pw_index);
         }
         else
         {  /* Not TX CR PW */
            /* Set all PW in RX to work in shapping mode */
            CLI_F_PwCreate("0 0 1 0"); /* CR master */
            sprintf(temp_buf, "0 %d 0",pw_index);
         }
         CLI_F_PwEnable(temp_buf);

         /* increment CD index */
         if (clock_rec_pw_tdm2psn[pw_index] == WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC)
            adap_timing_index++;
         else if (clock_rec_pw_tdm2psn[pw_index] == WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC)
            ext_diff_timing_index++;

      } /* end for (configure each line) */
   }
}

void CLI_F_140_SBI_E1_F_CR_COMBINED_DIFF_ADAP_NoCas_Two_Boards_N_EXT_CD_M_REG_CD_252Lines (char *StrPrm)
{
   /* test case 3.4.2.3 */
   WP_U32 i, j, line_index, spe_index, pw_index;
   WP_U32 adap_timing_index, ext_diff_timing_index;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 cr_number_offset = WTI_CESOP_MAX_CLOCK_REC_INTERFACES; /* first CD in ext_diff mode */
#if WTI_EXT_DIFF_MODE_ACTIVE
   int num_of_active_ext_diff_cd =
      ((global_active_cr_extdiff_mode <= 252) ? global_active_cr_extdiff_mode : 252);
#else
   int num_of_active_ext_diff_cd = 0;
#endif
   WP_U8   clock_rec_lines[399] = {0}; /* list of master lines */
   WP_U8   clock_rec_pw_psn2tdm[399] = {0};
   WP_U8   clock_rec_pw_tdm2psn[399] = {0};

#if WTI_CLOCK_REC_MODE
   printf("WORNING!!! This test is for adaptive + extended differential. Please set WTI_CLOCK_REC_MODE to '0'\n");
   printf("Type '9' to continue with the current configuration or any other key to exit\n");
   i = getchar();
   if (i != '9')
      exit(1);
#endif /* WTI_CLOCK_REC_MODE */

   /* Set the CR lines (both for RX and TX direction */
   for (i=0; i< global_active_cr_async_mode; i++)
   {/* Set lines to be CR master in regular mode*/
      clock_rec_lines[CLI_F_AttacheLineToPwNumber(i)] = WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC;
      clock_rec_pw_psn2tdm[i] = WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC;
      clock_rec_pw_tdm2psn[i] = WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC;
   }
   for (i=global_active_cr_async_mode; i<global_active_cr_async_mode+num_of_active_ext_diff_cd; i++)
   {/* Set lines to be CR master in extended mode*/
      clock_rec_lines[CLI_F_AttacheLineToPwNumber(i)] = WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC;
      clock_rec_pw_psn2tdm[i] = WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC;
      clock_rec_pw_tdm2psn[i] = WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC;
   }

#if WTI_DEBUG_LEVEL
   printf("clock_rec structures:\n");
   for (i=0; i<336; i++)
   {
      if (clock_rec_lines[i] != 0)
         printf(" index %d in clock_rec_lines is %d\n", i, clock_rec_lines[i]);
      if (clock_rec_pw_psn2tdm[i] != 0)
         printf(" index %d in clock_rec_pw_psn2tdm is %d\n", i, clock_rec_pw_psn2tdm[i]);
      if (clock_rec_pw_tdm2psn[i] != 0)
         printf(" index %d in clock_rec_pw_tdm2psn is %d\n", i, clock_rec_pw_tdm2psn[i]);
   }
#endif

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-regular differential) */
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */

   /* Init timing indexes to zero */
   adap_timing_index = 0;
   ext_diff_timing_index = 0;

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         /* verify legal timing values */
         if (adap_timing_index > 64 ||
               ext_diff_timing_index > 336 ||
               (adap_timing_index + ext_diff_timing_index > 336))
         {
            printf("ERROR!! Atempting to initial invalid clock domain index.\n");
            continue;
         }

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-336))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         /* line uses CR RX/TX or both */
         if (clock_rec_lines[line_index] != 0)
         {
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 3 3",line_index);
         }
         else
         {
            /* set ufe Rx direction only */
            sprintf(temp_buf, "0 %d 3 2",line_index);
         }
         CLI_F_UfeTransferMode(temp_buf);
         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-336)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-336), translator ID (0-31/336)] */
         if (clock_rec_lines[line_index] == WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC)
            sprintf(temp_buf, "0 %d %d", line_index, adap_timing_index);
         else if (clock_rec_lines[line_index] == WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC)
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+ext_diff_timing_index);
         else
         {
            /* conect all others to the first line. in normal mode should not happened */
            sprintf(temp_buf, "0 %d 0", line_index);
         }
         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-336), shaper ID (0-31) or extended CD ID (32-335)] */
         if (clock_rec_lines[line_index] == WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC)
            sprintf(temp_buf, "0 %d %d", line_index, adap_timing_index);
         else if (clock_rec_lines[line_index] == WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC)
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+ext_diff_timing_index);
         else
         {
            /* conect all others to the first line. in normal mode should not happened */
            sprintf(temp_buf, "0 %d 0", line_index);
         }
         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, shaper ID / ext. CD ID */

         /* increment CD index */
         if (clock_rec_lines[line_index] == WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC)
            adap_timing_index++;
         else if (clock_rec_lines[line_index] == WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC)
            ext_diff_timing_index++;

      }
   }
   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();

   /* Temux Setup:
     0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas */
   CLI_F_UfeTemuxSetup("0 3");

   CLI_F_UfeChipInitLineSetup("");
   /* ----------------------------- Set Clock Recovery Paramters ------------------------- */
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      if (clock_rec_lines[i] == WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC)
      {
         the_system->clock_rec[i].operation_mode = WP_IW_CLOCK_REC_ADAPTIVE_MODE;
         the_system->clock_rec[i].direct_factor = 28;
         the_system->clock_rec[i].integration_factor = 32;
         the_system->clock_rec[i].divisor_update_period = 4;
         the_system->clock_rec[i].phase_error_threshold = 6000;
         the_system->clock_rec[i].freq_error_rec_period = 128;
         the_system->clock_rec[i].average_divisor_factor = 4;
         the_system->clock_rec[i].allowed_dummy_packets = 16;
         the_system->clock_rec[i].pm_threshold = 2;
         the_system->clock_rec[i].max_pm_threshold = 4;
         the_system->clock_rec[i].pm_error_threshold = 600;
      }
      if (clock_rec_lines[i] == WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC)
      {
         the_system->clock_rec[i].operation_mode = WP_IW_CLOCK_REC_DIFFERENTIAL_MODE;
         the_system->clock_rec[i].direct_factor = 1;
         the_system->clock_rec[i].integration_factor =
            the_system->clock_rec[i].direct_factor + 8;
         the_system->clock_rec[i].divisor_update_period = 32;
         the_system->clock_rec[i].phase_error_threshold = 0;
         the_system->clock_rec[i ].freq_error_rec_period = 0;
         the_system->clock_rec[i ].average_divisor_factor = 10;
         the_system->clock_rec[i ].allowed_dummy_packets = 0;
      }
   }

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   /* Init timing indexes to zero */
   adap_timing_index = 0;
   ext_diff_timing_index = 0;

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_E1_LINES_PER_SPE + j;

         sprintf(temp_buf, "0 %d 64 64 32 0-31", line_index);/* The line index of this PW */
         CLI_F_PwConfigureFramed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 256");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 108 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

         /* Rx timing is used in differential or ext. differential modes */
         /* set timing according to mode */
         if (clock_rec_pw_tdm2psn[pw_index] == WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC)
            sprintf(temp_buf, "0 1 1 %d", adap_timing_index);
         else if (clock_rec_pw_tdm2psn[pw_index] == WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC)
            sprintf(temp_buf, "0 1 1 %d", cr_number_offset + ext_diff_timing_index);
         else
         {
            /* In differential mode all other pw uses CD#0. In normal mode, this should not happened */
            sprintf(temp_buf, "0 1 1 0");
         }
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-335)] */

         /**************** PSN --> TDM IW *****************/
         /* if clock recovery is set -> Tx timing is used */
         if (clock_rec_pw_psn2tdm[pw_index] != 0)
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/
         if (clock_rec_pw_psn2tdm[pw_index] != 0)
         {
            /* CR master Rx and Tx direction */
            CLI_F_PwCreate("0 0 1 1"); /* CR master */
            sprintf(temp_buf, "0 %d 1",pw_index);
         }
         else
         {  /* Not TX CR PW */
            /* Set all PW in RX to work in shapping mode */
            CLI_F_PwCreate("0 0 1 0"); /* CR master */
            sprintf(temp_buf, "0 %d 0",pw_index);
         }
         CLI_F_PwEnable(temp_buf);

         /* increment CD index */
         if (clock_rec_pw_tdm2psn[pw_index] == WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC)
            adap_timing_index++;
         else if (clock_rec_pw_tdm2psn[pw_index] == WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC)
            ext_diff_timing_index++;

      } /* end for (configure each line) */
   }
}

void CLI_F_140_SBI_T1_F_CR_COMBINED_DIFF_ADAP_NoCas_Two_Boards_N_EXT_CD_M_REG_CD_336Lines (char *StrPrm)
{
   /* test case 3.4.2.4 */
   WP_U32 i, j, line_index, spe_index, pw_index;
   WP_U32 adap_timing_index, ext_diff_timing_index;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 cr_number_offset = WTI_CESOP_MAX_CLOCK_REC_INTERFACES; /* first CD in ext_diff mode */
#if WTI_EXT_DIFF_MODE_ACTIVE
   int num_of_active_ext_diff_cd = global_active_cr_extdiff_mode;
#else
   int num_of_active_ext_diff_cd = 0;
#endif
   WP_U8   clock_rec_lines[399] = {0}; /* list of master lines */
   WP_U8   clock_rec_pw_psn2tdm[399] = {0};
   WP_U8   clock_rec_pw_tdm2psn[399] = {0};

#if WTI_CLOCK_REC_MODE
   printf("WORNING!!! This test is for adaptive + extended differential. Please set WTI_CLOCK_REC_MODE to '0'\n");
   printf("Type '9' to continue with the current configuration or any other key to exit\n");
   i = getchar();
   if (i != '9')
      exit(1);
#endif /* WTI_CLOCK_REC_MODE */

   /* Set the CR lines (both for RX and TX direction */
   for (i=0; i< global_active_cr_async_mode; i++)
   {/* Set lines to be CR master in regular mode*/
      clock_rec_lines[i] = WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC;
      clock_rec_pw_psn2tdm[i] = WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC;
      clock_rec_pw_tdm2psn[i] = WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC;
   }
   for (i=global_active_cr_async_mode; i<global_active_cr_async_mode+num_of_active_ext_diff_cd; i++)
   {/* Set lines to be CR master in extended mode*/
      clock_rec_lines[i] = WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC;
      clock_rec_pw_psn2tdm[i] = WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC;
      clock_rec_pw_tdm2psn[i] = WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC;
   }

#if WTI_DEBUG_LEVEL
   printf("clock_rec structures:\n");
   for (i=0; i<336; i++)
   {
      if (clock_rec_lines[i] != 0)
         printf(" index %d in clock_rec_lines is %d\n", i, clock_rec_lines[i]);
      if (clock_rec_pw_psn2tdm[i] != 0)
         printf(" index %d in clock_rec_pw_psn2tdm is %d\n", i, clock_rec_pw_psn2tdm[i]);
      if (clock_rec_pw_tdm2psn[i] != 0)
         printf(" index %d in clock_rec_pw_tdm2psn is %d\n", i, clock_rec_pw_tdm2psn[i]);
   }
#endif

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 2",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-regular differential) */
#if WTI_CLOCK_REC_MODE
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");
#else
   /* ufe system in adaptive mode */
   CLI_F_UfeSystemClkRecMethodSet("0 0");
#endif /* WTI_CLOCK_REC_MODE */

   /* Init timing indexes to zero */
   adap_timing_index = 0;
   ext_diff_timing_index = 0;

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         /* verify legal timing values */
         if (adap_timing_index > 64 ||
               ext_diff_timing_index > 336 ||
               (adap_timing_index + ext_diff_timing_index > 336))
         {
            printf("ERROR!! Atempting to initial invalid clock domain index.\n");
            continue;
         }

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-336))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         /* line uses CR RX/TX or both */
         if (clock_rec_lines[line_index] != 0)
         {
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 1 3",line_index);
         }
         else
         {
            /* set ufe Rx direction only */
            sprintf(temp_buf, "0 %d 1 2",line_index);
         }
         CLI_F_UfeTransferMode(temp_buf);
         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-336)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-336), translator ID (0-31/336)] */
         if (clock_rec_lines[line_index] == WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC)
            sprintf(temp_buf, "0 %d %d", line_index, adap_timing_index);
         else if (clock_rec_lines[line_index] == WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC)
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+ext_diff_timing_index);
         else
         {
            /* conect all others to the first line. in normal mode should not happened */
            sprintf(temp_buf, "0 %d 0", line_index);
         }
         CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-336), shaper ID (0-31) or extended CD ID (32-335)] */
         if (clock_rec_lines[line_index] == WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC)
            sprintf(temp_buf, "0 %d %d", line_index, adap_timing_index);
         else if (clock_rec_lines[line_index] == WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC)
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+ext_diff_timing_index);
         else
         {
            /* conect all others to the first line. in normal mode should not happened */
            sprintf(temp_buf, "0 %d 0", line_index);
         }
         CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, shaper ID / ext. CD ID */

         /* increment CD index */
         if (clock_rec_lines[line_index] == WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC)
            adap_timing_index++;
         else if (clock_rec_lines[line_index] == WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC)
            ext_diff_timing_index++;

      }
   }
   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();

   /* Temux Setup:
     0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas */
   CLI_F_UfeTemuxSetup("0 1");

   CLI_F_UfeChipInitLineSetup("");
   /* ----------------------------- Set Clock Recovery Paramters ------------------------- */
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      if (clock_rec_lines[i] == WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC)
      {
         the_system->clock_rec[i].operation_mode = WP_IW_CLOCK_REC_ADAPTIVE_MODE;
         the_system->clock_rec[i].direct_factor = 28;
         the_system->clock_rec[i].integration_factor = 32;
         the_system->clock_rec[i].divisor_update_period = 4;
         the_system->clock_rec[i].phase_error_threshold = 6000;
         the_system->clock_rec[i].freq_error_rec_period = 128;
         the_system->clock_rec[i].average_divisor_factor = 4;
         the_system->clock_rec[i].allowed_dummy_packets = 16;
         the_system->clock_rec[i].pm_threshold = 2;
         the_system->clock_rec[i].max_pm_threshold = 4;
         the_system->clock_rec[i].pm_error_threshold = 600;
      }
      if (clock_rec_lines[i] == WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC)
      {
         the_system->clock_rec[i].operation_mode = WP_IW_CLOCK_REC_DIFFERENTIAL_MODE;
         the_system->clock_rec[i].direct_factor = 1;
         the_system->clock_rec[i].integration_factor =
            the_system->clock_rec[i].direct_factor + 8;
         the_system->clock_rec[i].divisor_update_period = 32;
         the_system->clock_rec[i].phase_error_threshold = 0;
         the_system->clock_rec[i ].freq_error_rec_period = 0;
         the_system->clock_rec[i ].average_divisor_factor = 10;
         the_system->clock_rec[i ].allowed_dummy_packets = 0;
      }
   }

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   /* Init timing indexes to zero */
   adap_timing_index = 0;
   ext_diff_timing_index = 0;

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_T1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_T1_LINES_PER_SPE + j;

         sprintf(temp_buf, "0 %d 48 48 24 0-23", line_index);/* The line index of this PW */
         CLI_F_PwConfigureFramed(temp_buf);

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         CLI_F_Pwe3ChannelRxBufferSize("0 384");
         CLI_F_Pwe3ChannelStatmode("0 1");
         CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
         CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 258 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

         /* Rx timing is used in differential or ext. differential modes */
         /* set timing according to mode */
         if (clock_rec_pw_tdm2psn[pw_index] == WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC)
            sprintf(temp_buf, "0 1 1 %d", adap_timing_index);
         else if (clock_rec_pw_tdm2psn[pw_index] == WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC)
            sprintf(temp_buf, "0 1 1 %d", cr_number_offset + ext_diff_timing_index);
         else
         {
            /* In differential mode all other pw uses CD#0. In normal mode, this should not happened */
            sprintf(temp_buf, "0 1 1 0");
         }
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-335)] */

         /**************** PSN --> TDM IW *****************/
         /* if clock recovery is set -> Tx timing is used */
         if (clock_rec_pw_psn2tdm[pw_index] != 0)
            CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
         else
            CLI_F_Psn2TdmFlowAggTsParams("0 0 0"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/
         if (clock_rec_pw_psn2tdm[pw_index] != 0)
         {
            /* CR master Rx and Tx direction */
            CLI_F_PwCreate("0 0 1 1"); /* CR master */
            sprintf(temp_buf, "0 %d 1",pw_index);
         }
         else
         {  /* Not TX CR PW */
            /* Set all PW in RX to work in shapping mode */
            CLI_F_PwCreate("0 0 1 0"); /* CR master */
            sprintf(temp_buf, "0 %d 0",pw_index);
         }
         CLI_F_PwEnable(temp_buf);

         /* increment CD index */
         if (clock_rec_pw_tdm2psn[pw_index] == WT_CLOCK_REC_ACTIVE_ADAP_CLOCK_REC)
            adap_timing_index++;
         else if (clock_rec_pw_tdm2psn[pw_index] == WT_CLOCK_REC_ACTIVE_EXT_DIFF_CLOCK_REC)
            ext_diff_timing_index++;

      } /* end for (configure each line) */
   }
}
void CLI_F_150_SBI_E1_F_CR_EXTENDED_DIFF_NoCas_Two_Boards_252CD_DIFFERENT_DU_PACKET_SIZE (char *StrPrm)
{ /* test case 3.3.2.23 */
   WP_U32 i, j, line_index, spe_index, timing_index, pw_index;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 cr_number_offset = WTI_CESOP_MAX_CLOCK_REC_INTERFACES; /* first CD in ext_diff mode */
   int num_of_active_ext_diff_cd =
      ((global_active_cr_extdiff_mode <= 252) ? global_active_cr_extdiff_mode : 252);
   WP_U8  clock_rec_lines[336] = {0}; /* list of master lines */
   WP_U32 du_size, ps;

   /* Set the CR lines (both for RX and TX direction */
   for (i=0; i<num_of_active_ext_diff_cd; i++)
   {
      clock_rec_lines[CLI_F_AttacheLineToPwNumber(i)] = 1;
   }


   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration - UPI0 or UPI1 */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");

   /* FPGA mode [1-OCTAL, 2-SBI] */
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   /* Clock mode [0-LOOP TIMING, 1-EXTERNAL] */
   if (rx_looptime_clock == WP_TRUE)
      CLI_F_UfeClockMode("0 0");
   else
      CLI_F_UfeClockMode("0 1");

   /* SBI loopback mode [0-NORMAL, 1-LOOPBACK] */
   CLI_F_UfeSbiLoopbackMode("0 0");

   /* Set UFE clock recovery method (0-adaptive, 1-differential) for regular mode */
   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");

   /* UFE line configuration */
   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)

      {
         line_index = i*28 + j;
         timing_index = i*WTI_E1_LINES_PER_SPE + j;

         /* ----------------------------- Set line transfer mode --------------------------------- */
         /* Transfer mode [line_index (octal (0-7), SBI (0-83))  */
         /* Transfer_mode (1-T1_FRM, 2-T1_UNFRM 3-E1_FRM 4-E1_UNFRM */
         /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex */

         /* Set defult setup */
         if (clock_rec_lines[line_index] == 1)     /* line uses CR RX/TX or both */
         {
            /* set ufe Tx and Rx direction */
            sprintf(temp_buf, "0 %d 3 3",line_index);
            CLI_F_UfeTransferMode(temp_buf);
         }
         /* ------------------------- End of line transfer mode settings ------------------------------ */

         /* CAS mode [line_index (octal (0-7), SBI (0-83)) cas_mode (0-DISABLE, 1-ENABLE) */
         sprintf(temp_buf, "0 %d 0",line_index);
         CLI_F_UfeCasMode(temp_buf);

         /* match between clock tarnslators and lines for the CR lines   */
         /* Clock translator ID [line_index(0-83), translator ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+timing_index);
            CLI_F_UfeLineSbiClkTransSet(temp_buf); /* line_index, trans_id */
         }

         /* Set UFE line to work in the Tx clock master mode */
         /* The UFE will take the Tx clock from the clock recovery logic */
         sprintf(temp_buf, "0 %d", line_index);
         CLI_F_UfeLineTxClkMasterSet(temp_buf); /* for each clock_trans - set master */

         /* match between clock shaper and lines for the CR lines   */
         /* Clock shaper ID [line_index(0-83), shaper ID (0-31)] */
         if (clock_rec_lines[line_index] == 1)
         {
            sprintf(temp_buf, "0 %d %d", line_index, cr_number_offset+timing_index);
            CLI_F_UfeLineSbiClkShaperSet(temp_buf); /* line_index, trans_id */
         }
      }
   }

   /* ------ create an empty CESOP system with no PW ------- */
   WTI_DemoConfigStart();

   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/
   CLI_F_UfeTemuxSetup("0 3");

   CLI_F_UfeChipInitLineSetup("");

   /* ----------------------------- Set Clock Recovery Paramters ---------------------------------- */
   /* configure the clock recovery parameters */
   for (i=0; i<N_MAX_UFE_SBI_LINE; i++)
   {
      if (clock_rec_lines[i] == 0)
         continue;

      /* Set the defult PSN2TDM clock recoevry paramters */
      WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
   }

   /* ------------------------------- Set PWE L2 and L3 Paramters --------------------------------------- */
#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_E1_LINES_PER_SPE + j;

         /* set DU size and PS */
         if ((pw_index%3) == 0)
         {
            du_size = 64;
            sprintf(temp_buf, "0 %d %d %d 32 0-31", line_index, du_size, du_size);
         }
         else if ((pw_index%3) == 1)
         {
            du_size = 32;
            sprintf(temp_buf, "0 %d %d %d 32 0-31", line_index, du_size, du_size);
         }
         else
         {
            du_size = 16;
            sprintf(temp_buf, "0 %d %d %d 16 0-15", line_index, du_size, du_size);
         }
         CLI_F_PwConfigureFramed(temp_buf);

         if ((pw_index%2))
            ps = 128;
         else
            ps = 256;

         /* PWE3 channel configuration */
         CLI_F_Pwe3ChannelJitterBufferSize("0 32");
         sprintf(temp_buf, "0 %d", ps);
         CLI_F_Pwe3ChannelRxBufferSize(temp_buf);
         CLI_F_Pwe3ChannelStatmode("0 1");
         if ((pw_index%3) == 2)
         {
            CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15");
            CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39");
         }
         else
         {
            CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
            CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
         }
         CLI_F_Pwe3ChannelUdpDummyMode("0 1");
         CLI_F_Pwe3ChannelTxUdcas("0 f");

         /**************** TDM --> PSN IW *****************/

#if WTI_ENET_IEEE_802
         CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
         CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+pw_index,0x0a00020a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
         sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+pw_index,0x0a00010a+pw_index);
         CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
         CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 0 0");
         CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
         CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

         /* Rx timing is used in differential mode */
         sprintf(temp_buf, "0 1 1 %d",cr_number_offset+pw_index);
         CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS_MASTER ),ts_diff_if_id(0-31)] */

         /**************** PSN --> TDM IW *****************/
         /* if clock recovery is set -> Tx timing is used */
         CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */

         CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
         CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

         /**************** PSN --> TDM Tx binding*****************/
         CLI_F_PwCreate("0 0 1 1"); /* CR master */

         sprintf(temp_buf, "0 %d 1",pw_index);
         CLI_F_PwEnable(temp_buf);
      } /* end for (configure each line) */
   }

   /* Check DU size and Packet size */

   for (i=0; i<N_ACTIVE_UFE_SBI_SPE; i++)
   {
      for (j=0; j<WTI_E1_LINES_PER_SPE; j++)
      {
         line_index = i*28 + j;
         pw_index = i*WTI_E1_LINES_PER_SPE + j;

         /* read DU size and PAcket sizes */
      }
   }

}


/*---------------------------------------------------------------------------------------------*/
/*-----------------------------  Clock recovery tests section x -------------------------------*/
/* All following Clock Recovery OCTAL Over UFE (CAD) tests work in extended differential mode  */
/* or in multi-timing modes (ABS, adap, regular differential  with extended differential.      */
/*---------------------------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------------------------*/


/********************************************************************************************
 * Description:
 *            The test create 4 PWs (there location may changes according to synthesis)
 *            each line uses different CD.
 *            The test can run upto 4 lines (all use same PS and DUS).
 * TDM2PSN :  The test uses 4 CD for the 4 PWs.
 *            each CD uses different shaper.
 * PSN2TDM :
 ***************************************************************/
void CLI_F_230_CAD_E1_U_CR_EXTENDED_DIFF_NoCas_Two_Boards_4CD_4Lines(char *StrPrm)
{
   /* test case 3.3.2.1 */
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR   ip_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 i, cr_number_offset = WTI_CESOP_MAX_CLOCK_REC_INTERFACES /* CR offset for extended mode */;

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);
   memset(ip_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");

   /* clock recovery system config */

   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");

   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex] */
      /* set ufe Tx and Rx direction */
      sprintf(temp_buf, "0 %d 4 3",i);
      CLI_F_UfeTransferMode(temp_buf);

      /* Use shaper only in diff mode */
      /* Conect each line to its shaper */
      sprintf(temp_buf, "0 %d %d",i,cr_number_offset+i);
      CLI_F_UfeLineOctalClkShaperSet(temp_buf); /* line_index, trans_id */

      sprintf(temp_buf, "0 %d 1", i);
      CLI_F_UfeLineOctalClkTxTimingSet(temp_buf); /* line_index, extended_mode_active */
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   /* configure the clock recovery parameters */
   for (i=0; i<84; i++)
   {
      if (i<N_ACTIVE_UFE_OCT_LINES)
      {
         /* Set the defult PSN2TDM clock recoevry paramters */
         WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      }
   }

#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   CLI_F_UfeChipInitLineSetup("");

   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 32 32",i);
      CLI_F_PwConfigureUnframed(temp_buf);

      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 256");
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/
#if WTI_ENET_IEEE_802
      CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
      CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

      /* Rx timing is used */
      sprintf(temp_buf, "0 1 1 %d",cr_number_offset+i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS),ts_diff_if_id(0-31)] */


      /**************** PSN --> TDM Tx binding*****************/
      /* if clock recovery is set -> Tx timing is used */
      CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

      /* CR master Rx and Tx direction */
      CLI_F_PwCreate("0 0 1 1"); /* CR master */

      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_PwEnable(temp_buf);
   }
}

/********************************************************************************************
 * Description:
 *            The test create 4 PWs (there location may changes according to synthesis)
 *            each line uses different CD.
 *            The test can run upto 4 lines (all use same PS and DUS).
 * TDM2PSN :  The test uses 4 CD for the 4 PWs.
 *            each CD uses different shaper.
 * PSN2TDM :
 ***************************************************************/
void CLI_F_230_CAD_T1_U_CR_EXTENDED_DIFF_NoCas_Two_Boards_4CD_4Lines(char *StrPrm)
{
   /* test case 3.3.2.2 */
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR   ip_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 i, cr_number_offset = WTI_CESOP_MAX_CLOCK_REC_INTERFACES /* CR offset for extended mode */;

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);
   memset(ip_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");

   /* clock recovery system config */

   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");

   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex] */
      /* set ufe Tx and Rx direction */
      sprintf(temp_buf, "0 %d 2 3",i);
      CLI_F_UfeTransferMode(temp_buf);

      /* Use shaper only in diff mode */
      /* Conect each line to its shaper */
      sprintf(temp_buf, "0 %d %d",i,cr_number_offset+i);
      CLI_F_UfeLineOctalClkShaperSet(temp_buf); /* line_index, trans_id */

      sprintf(temp_buf, "0 %d 1", i);
      CLI_F_UfeLineOctalClkTxTimingSet(temp_buf); /* line_index, extended_mode_active */
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   /* configure the clock recovery parameters */
   for (i=0; i<84; i++)
   {
      if (i<N_ACTIVE_UFE_OCT_LINES)
      {
         /* Set the defult PSN2TDM clock recoevry paramters */
         WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      }
   }

#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   CLI_F_UfeChipInitLineSetup("");

   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 24 24",i);
      CLI_F_PwConfigureUnframed(temp_buf);

      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 192");
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/
#if WTI_ENET_IEEE_802
      CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
      CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 d8 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

      /* Rx timing is used */
      sprintf(temp_buf, "0 1 1 %d",cr_number_offset+i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS),ts_diff_if_id(0-31)] */


      /**************** PSN --> TDM Tx binding*****************/
      /* if clock recovery is set -> Tx timing is used */
      CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

      /* CR master Rx and Tx direction */
      CLI_F_PwCreate("0 0 1 1"); /* CR master */

      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_PwEnable(temp_buf);
   }
}

/********************************************************************************************
 * Description:
 *            The test create 4 PWs (there location may changes according to synthesis)
 *            each line uses different CD.
 *            The test can run upto 4 lines (all use same PS and DUS).
 * TDM2PSN :  The test uses 4 CD for the 4 PWs.
 *            each CD uses different shaper.
 * PSN2TDM :
 ***************************************************************/
void CLI_F_230_CAD_E1_F_CR_EXTENDED_DIFF_NoCas_Two_Boards_4CD_4Lines(char *StrPrm)
{
   /* test case 3.3.2.3 */
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR   ip_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 i, cr_number_offset = WTI_CESOP_MAX_CLOCK_REC_INTERFACES /* CR offset for extended mode */;

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);
   memset(ip_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");

   /* clock recovery system config */

   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");

   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex] */
      /* set ufe Tx and Rx direction */
      sprintf(temp_buf, "0 %d 3 3",i);
      CLI_F_UfeTransferMode(temp_buf);

      /* Use shaper only in diff mode */
      /* Conect each line to its shaper */
      sprintf(temp_buf, "0 %d %d",i,cr_number_offset+i);
      CLI_F_UfeLineOctalClkShaperSet(temp_buf); /* line_index, trans_id */

      sprintf(temp_buf, "0 %d 1", i);
      CLI_F_UfeLineOctalClkTxTimingSet(temp_buf); /* line_index, extended_mode_active */
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   /* configure the clock recovery parameters */
   for (i=0; i<84; i++)
   {
      if (i<N_ACTIVE_UFE_OCT_LINES)
      {
         /* Set the defult PSN2TDM clock recoevry paramters */
         WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      }
   }

#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   CLI_F_UfeChipInitLineSetup("");

   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 32 32 32 0-31",i);
      CLI_F_PwConfigureFramed(temp_buf);

      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 256");
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/
#if WTI_ENET_IEEE_802
      CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
      CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

      /* Rx timing is used */
      sprintf(temp_buf, "0 1 1 %d",cr_number_offset+i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS),ts_diff_if_id(0-31)] */


      /**************** PSN --> TDM Tx binding*****************/
      /* if clock recovery is set -> Tx timing is used */
      CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

      /* CR master Rx and Tx direction */
      CLI_F_PwCreate("0 0 1 1"); /* CR master */

      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_PwEnable(temp_buf);
   }
}

/********************************************************************************************
 * Description:
 *            The test create 4 PWs (there location may changes according to synthesis)
 *            each line uses different CD.
 *            The test can run upto 4 lines (all use same PS and DUS).
 * TDM2PSN :  The test uses 4 CD for the 4 PWs.
 *            each CD uses different shaper.
 * PSN2TDM :
 ***************************************************************/
void CLI_F_230_CAD_T1_F_CR_EXTENDED_DIFF_NoCas_Two_Boards_4CD_4Lines(char *StrPrm)
{
   /* test case 3.3.2.4 */
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR   ip_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 i, cr_number_offset = WTI_CESOP_MAX_CLOCK_REC_INTERFACES /* CR offset for extended mode */;

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);
   memset(ip_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");

   /* clock recovery system config */

   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");

   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex] */
      /* set ufe Tx and Rx direction */
      sprintf(temp_buf, "0 %d 1 3",i);
      CLI_F_UfeTransferMode(temp_buf);

      /* Use shaper only in diff mode */
      /* Conect each line to its shaper */
      sprintf(temp_buf, "0 %d %d",i,cr_number_offset+i);
      CLI_F_UfeLineOctalClkShaperSet(temp_buf); /* line_index, trans_id */

      sprintf(temp_buf, "0 %d 1", i);
      CLI_F_UfeLineOctalClkTxTimingSet(temp_buf); /* line_index, extended_mode_active */
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   /* configure the clock recovery parameters */
   for (i=0; i<84; i++)
   {
      if (i<N_ACTIVE_UFE_OCT_LINES)
      {
         /* Set the defult PSN2TDM clock recoevry paramters */
         WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      }
   }

#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   CLI_F_UfeChipInitLineSetup("");

   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 24 24 24 0-23",i);
      CLI_F_PwConfigureFramed(temp_buf);

      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 192");
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/
#if WTI_ENET_IEEE_802
      CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
      CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 d8 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

      /* Rx timing is used */
      sprintf(temp_buf, "0 1 1 %d",cr_number_offset+i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS),ts_diff_if_id(0-31)] */


      /**************** PSN --> TDM Tx binding*****************/
      /* if clock recovery is set -> Tx timing is used */
      CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

      /* CR master Rx and Tx direction */
      CLI_F_PwCreate("0 0 1 1"); /* CR master */

      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_PwEnable(temp_buf);
   }
}

/********************************************************************************************
 * Description:
 *            The test create 4 PWs (there location may changes according to synthesis)
 *            each line uses different CD.
 *            The test can run upto 4 lines (all use same PS and DUS).
 * TDM2PSN :  The test uses 4 CD for the 4 PWs.
 *            each CD uses different shaper.
 * PSN2TDM :
 ***************************************************************/
void CLI_F_231_CAD_E1_F_1DS0_CR_EXTENDED_DIFF_NoCas_Two_Boards_4CD_4Lines_128Pw(char *StrPrm)
{
   /* test case 3.3.2.5 */
   int recover_by_pw = 0;
   WP_CHAR enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR ip_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 i, cr_number_offset = WTI_CESOP_MAX_CLOCK_REC_INTERFACES /* CR offset for extended mode */;
   WP_U8 clock_rec_pw_psn2tdm[64*32] = {0}; /* list of active CR PWs in the TX direction */
   WP_U32 pw_per_line = 32;

   if (recover_by_pw >= pw_per_line)
   {
      printf("WORNING! recover PW (%d) is bigger than number of PW per line (%d). Recover by the first PW on each line\n", recover_by_pw, pw_per_line);
      recover_by_pw = 0;
   }

   for (i=0; i<N_ACTIVE_UFE_OCT_LINES; i++)
   {
      clock_rec_pw_psn2tdm[i*pw_per_line+recover_by_pw] = 1; /* select the Pw to recovers the clock on */



   }

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);
   memset(ip_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");

   /* clock recovery system config */

   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");

   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex] */
      /* set ufe Tx and Rx direction */
      sprintf(temp_buf, "0 %d 3 3",i);
      CLI_F_UfeTransferMode(temp_buf);

      /* Use shaper only in diff mode */
      /* Conect each line to its shaper */
      sprintf(temp_buf, "0 %d %d",i,cr_number_offset+i);
      CLI_F_UfeLineOctalClkShaperSet(temp_buf); /* line_index, trans_id */

      sprintf(temp_buf, "0 %d 1", i);
      CLI_F_UfeLineOctalClkTxTimingSet(temp_buf); /* line_index, extended_mode_active */
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   /* configure the clock recovery parameters */
   for (i=0; i<84; i++)
   {
      if (i<N_ACTIVE_UFE_OCT_LINES)
      {
         /* Set the defult PSN2TDM clock recoevry paramters */
         WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      }
   }

#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   CLI_F_UfeChipInitLineSetup("");

   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 32 32 32 0-31",i);
      CLI_F_PwConfigureFramed(temp_buf);

      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 256");
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/
#if WTI_ENET_IEEE_802
      CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
      CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 118 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

      /* Rx timing is used */
      sprintf(temp_buf, "0 1 1 %d",cr_number_offset+i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS),ts_diff_if_id(0-31)] */


      /**************** PSN --> TDM Tx binding*****************/
      /* if clock recovery is set -> Tx timing is used */
      CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

      /* CR master Rx and Tx direction */
      CLI_F_PwCreate("0 0 1 1"); /* CR master */

      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_PwEnable(temp_buf);
   }
}

/********************************************************************************************
 * Description:
 *            The test create 4 PWs (there location may changes according to synthesis)
 *            each line uses different CD.
 *            The test can run upto 4 lines (all use same PS and DUS).
 * TDM2PSN :  The test uses 4 CD for the 4 PWs.
 *            each CD uses different shaper.
 * PSN2TDM :
 ***************************************************************/
void CLI_F_231_CAD_T1_F_1DS0_CR_EXTENDED_DIFF_NoCas_Two_Boards_4CD_4Lines_96Pw(char *StrPrm)
{
   /* test case 3.3.2.6 */
   WP_CHAR   enet_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR   ip_hdr[WTI_MAX_STRING_SIZE];
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 i, cr_number_offset = WTI_CESOP_MAX_CLOCK_REC_INTERFACES /* CR offset for extended mode */;

   memset(enet_hdr,0,WTI_MAX_STRING_SIZE);
   memset(ip_hdr,0,WTI_MAX_STRING_SIZE);

   /* allocate CESoP system */
   WTI_SystemAlloc();

   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 1");

   /* clock recovery system config */

   /* ufe system in differential mode */
   CLI_F_UfeSystemClkRecMethodSet("0 1");

   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      /* Last paramter set  clock_rec_mode 0-disable 1-tx 2-rx 3-duplex] */
      /* set ufe Tx and Rx direction */
      sprintf(temp_buf, "0 %d 1 3",i);
      CLI_F_UfeTransferMode(temp_buf);

      /* Use shaper only in diff mode */
      /* Conect each line to its shaper */
      sprintf(temp_buf, "0 %d %d",i,cr_number_offset+i);
      CLI_F_UfeLineOctalClkShaperSet(temp_buf); /* line_index, trans_id */

      sprintf(temp_buf, "0 %d 1", i);
      CLI_F_UfeLineOctalClkTxTimingSet(temp_buf); /* line_index, extended_mode_active */
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }
   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_UfeCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   /* configure the clock recovery parameters */
   for (i=0; i<84; i++)
   {
      if (i<N_ACTIVE_UFE_OCT_LINES)
      {
         /* Set the defult PSN2TDM clock recoevry paramters */
         WTI_ClockRecoveryPSN2TDMDefultParamesConfig(i);
      }
   }

#ifdef WTI_BOARD_1
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E  00 50 FC E2 0A D9 8100 e008 0800");/* Priority 7 vlan 8 */
#else
   strcpy(enet_hdr, "0 00 08 74 AC 53 1E 00 50 FC E2 0A D9 0800");
#endif
#else /* WTI_BOARD_1 */
#if WTI_ENET_IEEE_802
   /* 0,dest mac,source mac,8100,(includes 3 bits for priority(7),1 bit CFI(0) and 12 bits vlan id()),0800 */
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 8100 e007 0800");/* Priority 7 vlan 7 */
#else
   strcpy(enet_hdr, "0 00 50 FC E2 0A D9 00 08 74 AC 53 1E 0800");
#endif
#endif /* WTI_BOARD_1 */

#if __linux__
   for (i = 0; i < 6; i++)
   {
      sprintf(enet_hdr + 20 + i*3, "%02x ", tun_shadow.my_mac[i]);
   }
#if WTI_ENET_IEEE_802
   strcat(enet_hdr, "8100 e001 0800");
#else
   strcat(enet_hdr, "0800");
#endif
#endif

   CLI_F_UfeChipInitLineSetup("");

   for (i=0;i<N_ACTIVE_UFE_OCT_LINES;i++)
   {
      sprintf(temp_buf, "0 %d 24 24 24 0-23",i);
      CLI_F_PwConfigureFramed(temp_buf);

      /* PWE3 channel configuration */
      CLI_F_Pwe3ChannelJitterBufferSize("0 32");
      CLI_F_Pwe3ChannelRxBufferSize("0 192");
      CLI_F_Pwe3ChannelStatmode("0 1");
      CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23");
      CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47");
      CLI_F_Pwe3ChannelUdpDummyMode("0 1");
      CLI_F_Pwe3ChannelTxUdcas("0 f");

      /**************** TDM --> PSN IW *****************/
#if WTI_ENET_IEEE_802
      CLI_F_Tdm2PsnFlowAggEnet802Header(enet_hdr);
#else
      CLI_F_Tdm2PsnFlowAggEnetHeader(enet_hdr);
#endif
#ifdef WTI_BOARD_1
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00010a+i,0x0a00020a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#else
      sprintf(temp_buf, "0 45000000 811e0000 40110000 %x %x",0x0a00020a+i,0x0a00010a+i);
      CLI_F_Tdm2PsnFlowAggIpHeader(temp_buf);
#endif
      CLI_F_Tdm2PsnFlowAggUdpHeader("0 1010 0001 d8 0");
      CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");
      CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");

      /* Rx timing is used */
      sprintf(temp_buf, "0 1 1 %d",cr_number_offset+i);
      CLI_F_Tdm2PsnFlowAggTsParams(temp_buf); /* [ts_used(1-used,0-unused),ts_method(0-WP_IW_CESOP_ABS_TS,1-WP_IW_CESOP_DIFF_TS),ts_diff_if_id(0-31)] */


      /**************** PSN --> TDM Tx binding*****************/
      /* if clock recovery is set -> Tx timing is used */
      CLI_F_Psn2TdmFlowAggTsParams("0 1 3000"); /* [ts_used(1-used,0-unused),ts_diff_const(0-0xffff)] */
      CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
      CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");

      /* CR master Rx and Tx direction */
      CLI_F_PwCreate("0 0 1 1"); /* CR master */

      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_PwEnable(temp_buf);
   }
}

/*---------------------------------------------------------------------------------------*/
/*-----------------------------  end of section x ---------------------------------------*/
/*---------------------------------------------------------------------------------------*/


#endif /* WTI_EXT_DIFF_MODE_ACTIVE */

#if WTI_CESOP_MEF8_ENCAP


void CLI_F_MEF8_ENCAP_1_Vlan(char *StrPrm)
{
   WP_U32 i;
   WP_CHAR temp_buf[WTI_MAX_STRING_SIZE];
   WP_U32 spe_index;

   WP_CHAR ethernet_type[4];

   /* allocate CESoP system */
   WTI_SystemAlloc();

#if WTI_CESOP_TDI
   /* init all active TDM interfaces to the default configuration:
      E1, FRAMED, CAS */
   CLI_F_TdiConfigInit("");

   /* configure TDM interfaces to E1 UNFRAMED no CAS */
   for (i=0;i<3;i++)
   {
      sprintf(temp_buf, "0 %d 1",i);
      CLI_F_TdiOperationMode(temp_buf);
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiFramingMode(temp_buf);
      sprintf(temp_buf, "0 %d 0",i);
      CLI_F_TdiCasMode(temp_buf);
   }

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();

   CLI_F_PwConfigureUnframedTdi("0 1 1");
#else
   /* UFE configuration */
   if (WTI_UFE_UPI_PORT == WP_PORT_UPI1)
      CLI_F_UfeUpiPort("0 0");
   else
      CLI_F_UfeUpiPort("0 1");
   CLI_F_UfeFpgaMode("0 2");

   /* SPE transfer mode [spe_id (0-2) spe_transfer_mode (0-IDLE, 1-E1, 2-T1 3-DS3, 4-E3) */
   for(spe_index = 0; spe_index < N_ACTIVE_UFE_SBI_SPE; spe_index++)
   {
      sprintf(temp_buf, "0 %d 1",spe_index);
      CLI_F_UfeSbiSpeTransferMode(temp_buf);
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   if (rx_looptime_clock == WP_TRUE)
   {
      CLI_F_UfeClockMode("0 0");
   }
   else
   {
      CLI_F_UfeClockMode("0 1");
   }

   /* UFE line configuration */
   for (i=0;i<WTI_E1_LINES_PER_SPE;++i)
   {
      sprintf(temp_buf,"0 %d 4 0", i);
      CLI_F_UfeTransferMode(temp_buf);
      sprintf(temp_buf,"0 %d 0", i);
      CLI_F_UfeCasMode(temp_buf);
   }

   CLI_F_UfeSbiLoopbackMode("0 0");

   /* create an empty CESOP system with no PW */
   WTI_DemoConfigStart();
   /*0-t1 unframed, 1-t1 framed, 2-e1 unframed, 3-e1 framed
     4-ds3 unframed, 5-ds3 framed, 6-e3 unframed, 7-e3 framed
     8-t1-esf  9-e1-cas*/

   CLI_F_UfeTemuxSetup("0 2");
   CLI_F_UfeChipInitLineSetup("");

   CLI_F_PwConfigureUnframed("0 1 64 32");
#endif

   /* PWE3 channel configuration */
   CLI_F_Pwe3ChannelJitterBufferSize("0 32");
   CLI_F_Pwe3ChannelRxBufferSize("0 130");/*256*/
   CLI_F_Pwe3ChannelStatmode("0 1");
   CLI_F_Pwe3ChannelTxUdpattern("0 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31");
   CLI_F_Pwe3ChannelTxDummyUdpattern("0 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55");
   CLI_F_Pwe3ChannelUdpDummyMode("0 1");
   CLI_F_Pwe3ChannelTxUdcas("0 f");

   /**************** TDM --> PSN IW *****************/

   CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 88d8");

#if WTI_NUM_OF_VLAN_TAGS == 2
   CLI_F_Tdm2PsnFlowAggOuterVlan("0 34"); /* 81 01 00 34 */
#endif
#if WTI_NUM_OF_VLAN_TAGS > 0
   CLI_F_Tdm2PsnFlowAggInnerVlan("0 36"); /* 81 00 00 36 */
#endif

   // #if WTI_NUM_OF_VLAN_TAGS == 0
   //    CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 88d8");
   // #elif WTI_NUM_OF_VLAN_TAGS == 1
   //    CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 8100");
   //    CLI_F_Tdm2PsnFlowAggOuterVlan("0 34");
   //    CLI_F_Tdm2PsnFlowAggMef8EthType("0");
   // #else
   //    CLI_F_Tdm2PsnFlowAggEnetHeader("0 aa aa aa aa aa aa 00 aa 00 aa 00 aa 8101");
   //    CLI_F_Tdm2PsnFlowAggOuterVlan("0 34");
   //    CLI_F_Tdm2PsnFlowAggInnerVlan("0 36");
   //    CLI_F_Tdm2PsnFlowAggMef8EthType("0");
   // #endif
   CLI_F_Tdm2PsnFlowAggEcidHeader("0 55555 102");

   //   CLI_F_Tdm2PsnFlowAggIpHeader("0 45000000 811e0000 40110000 11111111 1a1a1a1a");
   CLI_F_Tdm2PsnFlowAggControlWord("0 0 0 0");
   CLI_F_Tdm2PsnFlowAggRtpHeader("0 50 0 0 0 0");


#if WTI_ACTIVE_ABSOLUTE_MODE
   sprintf(temp_buf, "0 1 0 0");
#else
   sprintf(temp_buf, "0 0 0 0");
#endif
   CLI_F_Tdm2PsnFlowAggTsParams(temp_buf);
   CLI_F_Tdm2PsnFlowAggTsConstSet("0 4");/*3*/

   /* example for ABS mode:
   1. RxBufferSize = 200
      TsConst = 6
      therefore: N*(RxBuf*8(bits/byte)/256) = 6*(200*8)/256 = 37.5
      => in Hexa we will get 25h/26h alternately.
      follow the RTP's TS and see the results.
   2. if TsConst=3 => 18.75 => [12,13,13,13]
    */
   /**************** PSN --> TDM IW *****************/

   CLI_F_Psn2TdmFlowAggTsParams("0 0 0");

   /**************** PSN --> TDM Tx binding*****************/

   CLI_F_Psn2TdmTxBinWindowThreshold("0 16");
   CLI_F_Psn2TdmTxBinWindowSwitchoverThreshold("0 8");
   CLI_F_Psn2TdmTxBinLOPSDetection("0 1 6 4");

   CLI_F_PwCreate("0 0 0 0");
   CLI_F_PwEnable("0 0 0");

   CLI_F_PwConfigureUnframed("0 2 64 32");

}


#endif /* WTI_CESOP_MEF8_ENCAP */

#endif /* !WTI_CESOP_TDI - 'if' located in the beggining of section 4*/
